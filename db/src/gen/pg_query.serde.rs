// @generated
impl serde::Serialize for AArrayExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.elements.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.A_ArrayExpr", len)?;
        if !self.elements.is_empty() {
            struct_ser.serialize_field("elements", &self.elements)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AArrayExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "elements",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Elements,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "elements" => Ok(GeneratedField::Elements),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AArrayExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_ArrayExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AArrayExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut elements__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Elements => {
                            if elements__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elements"));
                            }
                            elements__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AArrayExpr {
                    elements: elements__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_ArrayExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AConst {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.isnull {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        if self.val.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.A_Const", len)?;
        if self.isnull {
            struct_ser.serialize_field("isnull", &self.isnull)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        if let Some(v) = self.val.as_ref() {
            match v {
                a_const::Val::Ival(v) => {
                    struct_ser.serialize_field("ival", v)?;
                }
                a_const::Val::Fval(v) => {
                    struct_ser.serialize_field("fval", v)?;
                }
                a_const::Val::Boolval(v) => {
                    struct_ser.serialize_field("boolval", v)?;
                }
                a_const::Val::Sval(v) => {
                    struct_ser.serialize_field("sval", v)?;
                }
                a_const::Val::Bsval(v) => {
                    struct_ser.serialize_field("bsval", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AConst {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "isnull",
            "location",
            "ival",
            "fval",
            "boolval",
            "sval",
            "bsval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Isnull,
            Location,
            Ival,
            Fval,
            Boolval,
            Sval,
            Bsval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isnull" => Ok(GeneratedField::Isnull),
                            "location" => Ok(GeneratedField::Location),
                            "ival" => Ok(GeneratedField::Ival),
                            "fval" => Ok(GeneratedField::Fval),
                            "boolval" => Ok(GeneratedField::Boolval),
                            "sval" => Ok(GeneratedField::Sval),
                            "bsval" => Ok(GeneratedField::Bsval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AConst;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_Const")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AConst, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut isnull__ = None;
                let mut location__ = None;
                let mut val__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Isnull => {
                            if isnull__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isnull"));
                            }
                            isnull__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Ival => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ival"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(a_const::Val::Ival)
;
                        }
                        GeneratedField::Fval => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fval"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(a_const::Val::Fval)
;
                        }
                        GeneratedField::Boolval => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boolval"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(a_const::Val::Boolval)
;
                        }
                        GeneratedField::Sval => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sval"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(a_const::Val::Sval)
;
                        }
                        GeneratedField::Bsval => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bsval"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(a_const::Val::Bsval)
;
                        }
                    }
                }
                Ok(AConst {
                    isnull: isnull__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                    val: val__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_Const", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.lexpr.is_some() {
            len += 1;
        }
        if self.rexpr.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.A_Expr", len)?;
        if self.kind != 0 {
            let v = AExprKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.lexpr.as_ref() {
            struct_ser.serialize_field("lexpr", v)?;
        }
        if let Some(v) = self.rexpr.as_ref() {
            struct_ser.serialize_field("rexpr", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "name",
            "lexpr",
            "rexpr",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Name,
            Lexpr,
            Rexpr,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "name" => Ok(GeneratedField::Name),
                            "lexpr" => Ok(GeneratedField::Lexpr),
                            "rexpr" => Ok(GeneratedField::Rexpr),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_Expr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut name__ = None;
                let mut lexpr__ = None;
                let mut rexpr__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<AExprKind>()? as i32);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Lexpr => {
                            if lexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lexpr"));
                            }
                            lexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Rexpr => {
                            if rexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rexpr"));
                            }
                            rexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AExpr {
                    kind: kind__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    lexpr: lexpr__,
                    rexpr: rexpr__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_Expr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AExprKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "A_EXPR_KIND_UNDEFINED",
            Self::AexprOp => "AEXPR_OP",
            Self::AexprOpAny => "AEXPR_OP_ANY",
            Self::AexprOpAll => "AEXPR_OP_ALL",
            Self::AexprDistinct => "AEXPR_DISTINCT",
            Self::AexprNotDistinct => "AEXPR_NOT_DISTINCT",
            Self::AexprNullif => "AEXPR_NULLIF",
            Self::AexprIn => "AEXPR_IN",
            Self::AexprLike => "AEXPR_LIKE",
            Self::AexprIlike => "AEXPR_ILIKE",
            Self::AexprSimilar => "AEXPR_SIMILAR",
            Self::AexprBetween => "AEXPR_BETWEEN",
            Self::AexprNotBetween => "AEXPR_NOT_BETWEEN",
            Self::AexprBetweenSym => "AEXPR_BETWEEN_SYM",
            Self::AexprNotBetweenSym => "AEXPR_NOT_BETWEEN_SYM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AExprKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "A_EXPR_KIND_UNDEFINED",
            "AEXPR_OP",
            "AEXPR_OP_ANY",
            "AEXPR_OP_ALL",
            "AEXPR_DISTINCT",
            "AEXPR_NOT_DISTINCT",
            "AEXPR_NULLIF",
            "AEXPR_IN",
            "AEXPR_LIKE",
            "AEXPR_ILIKE",
            "AEXPR_SIMILAR",
            "AEXPR_BETWEEN",
            "AEXPR_NOT_BETWEEN",
            "AEXPR_BETWEEN_SYM",
            "AEXPR_NOT_BETWEEN_SYM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AExprKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "A_EXPR_KIND_UNDEFINED" => Ok(AExprKind::Undefined),
                    "AEXPR_OP" => Ok(AExprKind::AexprOp),
                    "AEXPR_OP_ANY" => Ok(AExprKind::AexprOpAny),
                    "AEXPR_OP_ALL" => Ok(AExprKind::AexprOpAll),
                    "AEXPR_DISTINCT" => Ok(AExprKind::AexprDistinct),
                    "AEXPR_NOT_DISTINCT" => Ok(AExprKind::AexprNotDistinct),
                    "AEXPR_NULLIF" => Ok(AExprKind::AexprNullif),
                    "AEXPR_IN" => Ok(AExprKind::AexprIn),
                    "AEXPR_LIKE" => Ok(AExprKind::AexprLike),
                    "AEXPR_ILIKE" => Ok(AExprKind::AexprIlike),
                    "AEXPR_SIMILAR" => Ok(AExprKind::AexprSimilar),
                    "AEXPR_BETWEEN" => Ok(AExprKind::AexprBetween),
                    "AEXPR_NOT_BETWEEN" => Ok(AExprKind::AexprNotBetween),
                    "AEXPR_BETWEEN_SYM" => Ok(AExprKind::AexprBetweenSym),
                    "AEXPR_NOT_BETWEEN_SYM" => Ok(AExprKind::AexprNotBetweenSym),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AIndices {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_slice {
            len += 1;
        }
        if self.lidx.is_some() {
            len += 1;
        }
        if self.uidx.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.A_Indices", len)?;
        if self.is_slice {
            struct_ser.serialize_field("is_slice", &self.is_slice)?;
        }
        if let Some(v) = self.lidx.as_ref() {
            struct_ser.serialize_field("lidx", v)?;
        }
        if let Some(v) = self.uidx.as_ref() {
            struct_ser.serialize_field("uidx", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AIndices {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_slice",
            "lidx",
            "uidx",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsSlice,
            Lidx,
            Uidx,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "is_slice" => Ok(GeneratedField::IsSlice),
                            "lidx" => Ok(GeneratedField::Lidx),
                            "uidx" => Ok(GeneratedField::Uidx),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AIndices;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_Indices")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AIndices, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_slice__ = None;
                let mut lidx__ = None;
                let mut uidx__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsSlice => {
                            if is_slice__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_slice"));
                            }
                            is_slice__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Lidx => {
                            if lidx__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lidx"));
                            }
                            lidx__ = map_.next_value()?;
                        }
                        GeneratedField::Uidx => {
                            if uidx__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uidx"));
                            }
                            uidx__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AIndices {
                    is_slice: is_slice__.unwrap_or_default(),
                    lidx: lidx__,
                    uidx: uidx__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_Indices", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AIndirection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.arg.is_some() {
            len += 1;
        }
        if !self.indirection.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.A_Indirection", len)?;
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if !self.indirection.is_empty() {
            struct_ser.serialize_field("indirection", &self.indirection)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AIndirection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arg",
            "indirection",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arg,
            Indirection,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arg" => Ok(GeneratedField::Arg),
                            "indirection" => Ok(GeneratedField::Indirection),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AIndirection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_Indirection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AIndirection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arg__ = None;
                let mut indirection__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Indirection => {
                            if indirection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indirection"));
                            }
                            indirection__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AIndirection {
                    arg: arg__,
                    indirection: indirection__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_Indirection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AStar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("pg_query.A_Star", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AStar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AStar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.A_Star")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AStar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(AStar {
                })
            }
        }
        deserializer.deserialize_struct("pg_query.A_Star", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AccessPriv {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.priv_name.is_empty() {
            len += 1;
        }
        if !self.cols.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AccessPriv", len)?;
        if !self.priv_name.is_empty() {
            struct_ser.serialize_field("priv_name", &self.priv_name)?;
        }
        if !self.cols.is_empty() {
            struct_ser.serialize_field("cols", &self.cols)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AccessPriv {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "priv_name",
            "cols",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrivName,
            Cols,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "priv_name" => Ok(GeneratedField::PrivName),
                            "cols" => Ok(GeneratedField::Cols),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AccessPriv;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AccessPriv")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AccessPriv, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut priv_name__ = None;
                let mut cols__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrivName => {
                            if priv_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("priv_name"));
                            }
                            priv_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cols => {
                            if cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cols"));
                            }
                            cols__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AccessPriv {
                    priv_name: priv_name__.unwrap_or_default(),
                    cols: cols__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AccessPriv", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AggSplit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "AGG_SPLIT_UNDEFINED",
            Self::AggsplitSimple => "AGGSPLIT_SIMPLE",
            Self::AggsplitInitialSerial => "AGGSPLIT_INITIAL_SERIAL",
            Self::AggsplitFinalDeserial => "AGGSPLIT_FINAL_DESERIAL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AggSplit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AGG_SPLIT_UNDEFINED",
            "AGGSPLIT_SIMPLE",
            "AGGSPLIT_INITIAL_SERIAL",
            "AGGSPLIT_FINAL_DESERIAL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggSplit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AGG_SPLIT_UNDEFINED" => Ok(AggSplit::Undefined),
                    "AGGSPLIT_SIMPLE" => Ok(AggSplit::AggsplitSimple),
                    "AGGSPLIT_INITIAL_SERIAL" => Ok(AggSplit::AggsplitInitialSerial),
                    "AGGSPLIT_FINAL_DESERIAL" => Ok(AggSplit::AggsplitFinalDeserial),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AggStrategy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "AGG_STRATEGY_UNDEFINED",
            Self::AggPlain => "AGG_PLAIN",
            Self::AggSorted => "AGG_SORTED",
            Self::AggHashed => "AGG_HASHED",
            Self::AggMixed => "AGG_MIXED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AggStrategy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AGG_STRATEGY_UNDEFINED",
            "AGG_PLAIN",
            "AGG_SORTED",
            "AGG_HASHED",
            "AGG_MIXED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggStrategy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AGG_STRATEGY_UNDEFINED" => Ok(AggStrategy::Undefined),
                    "AGG_PLAIN" => Ok(AggStrategy::AggPlain),
                    "AGG_SORTED" => Ok(AggStrategy::AggSorted),
                    "AGG_HASHED" => Ok(AggStrategy::AggHashed),
                    "AGG_MIXED" => Ok(AggStrategy::AggMixed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Aggref {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.aggfnoid != 0 {
            len += 1;
        }
        if self.aggtype != 0 {
            len += 1;
        }
        if self.aggcollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.aggargtypes.is_empty() {
            len += 1;
        }
        if !self.aggdirectargs.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if !self.aggorder.is_empty() {
            len += 1;
        }
        if !self.aggdistinct.is_empty() {
            len += 1;
        }
        if self.aggfilter.is_some() {
            len += 1;
        }
        if self.aggstar {
            len += 1;
        }
        if self.aggvariadic {
            len += 1;
        }
        if !self.aggkind.is_empty() {
            len += 1;
        }
        if self.agglevelsup != 0 {
            len += 1;
        }
        if self.aggsplit != 0 {
            len += 1;
        }
        if self.aggno != 0 {
            len += 1;
        }
        if self.aggtransno != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Aggref", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.aggfnoid != 0 {
            struct_ser.serialize_field("aggfnoid", &self.aggfnoid)?;
        }
        if self.aggtype != 0 {
            struct_ser.serialize_field("aggtype", &self.aggtype)?;
        }
        if self.aggcollid != 0 {
            struct_ser.serialize_field("aggcollid", &self.aggcollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.aggargtypes.is_empty() {
            struct_ser.serialize_field("aggargtypes", &self.aggargtypes)?;
        }
        if !self.aggdirectargs.is_empty() {
            struct_ser.serialize_field("aggdirectargs", &self.aggdirectargs)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if !self.aggorder.is_empty() {
            struct_ser.serialize_field("aggorder", &self.aggorder)?;
        }
        if !self.aggdistinct.is_empty() {
            struct_ser.serialize_field("aggdistinct", &self.aggdistinct)?;
        }
        if let Some(v) = self.aggfilter.as_ref() {
            struct_ser.serialize_field("aggfilter", v)?;
        }
        if self.aggstar {
            struct_ser.serialize_field("aggstar", &self.aggstar)?;
        }
        if self.aggvariadic {
            struct_ser.serialize_field("aggvariadic", &self.aggvariadic)?;
        }
        if !self.aggkind.is_empty() {
            struct_ser.serialize_field("aggkind", &self.aggkind)?;
        }
        if self.agglevelsup != 0 {
            struct_ser.serialize_field("agglevelsup", &self.agglevelsup)?;
        }
        if self.aggsplit != 0 {
            let v = AggSplit::try_from(self.aggsplit)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.aggsplit)))?;
            struct_ser.serialize_field("aggsplit", &v)?;
        }
        if self.aggno != 0 {
            struct_ser.serialize_field("aggno", &self.aggno)?;
        }
        if self.aggtransno != 0 {
            struct_ser.serialize_field("aggtransno", &self.aggtransno)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Aggref {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "aggfnoid",
            "aggtype",
            "aggcollid",
            "inputcollid",
            "aggargtypes",
            "aggdirectargs",
            "args",
            "aggorder",
            "aggdistinct",
            "aggfilter",
            "aggstar",
            "aggvariadic",
            "aggkind",
            "agglevelsup",
            "aggsplit",
            "aggno",
            "aggtransno",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Aggfnoid,
            Aggtype,
            Aggcollid,
            Inputcollid,
            Aggargtypes,
            Aggdirectargs,
            Args,
            Aggorder,
            Aggdistinct,
            Aggfilter,
            Aggstar,
            Aggvariadic,
            Aggkind,
            Agglevelsup,
            Aggsplit,
            Aggno,
            Aggtransno,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "aggfnoid" => Ok(GeneratedField::Aggfnoid),
                            "aggtype" => Ok(GeneratedField::Aggtype),
                            "aggcollid" => Ok(GeneratedField::Aggcollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "aggargtypes" => Ok(GeneratedField::Aggargtypes),
                            "aggdirectargs" => Ok(GeneratedField::Aggdirectargs),
                            "args" => Ok(GeneratedField::Args),
                            "aggorder" => Ok(GeneratedField::Aggorder),
                            "aggdistinct" => Ok(GeneratedField::Aggdistinct),
                            "aggfilter" => Ok(GeneratedField::Aggfilter),
                            "aggstar" => Ok(GeneratedField::Aggstar),
                            "aggvariadic" => Ok(GeneratedField::Aggvariadic),
                            "aggkind" => Ok(GeneratedField::Aggkind),
                            "agglevelsup" => Ok(GeneratedField::Agglevelsup),
                            "aggsplit" => Ok(GeneratedField::Aggsplit),
                            "aggno" => Ok(GeneratedField::Aggno),
                            "aggtransno" => Ok(GeneratedField::Aggtransno),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Aggref;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Aggref")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Aggref, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut aggfnoid__ = None;
                let mut aggtype__ = None;
                let mut aggcollid__ = None;
                let mut inputcollid__ = None;
                let mut aggargtypes__ = None;
                let mut aggdirectargs__ = None;
                let mut args__ = None;
                let mut aggorder__ = None;
                let mut aggdistinct__ = None;
                let mut aggfilter__ = None;
                let mut aggstar__ = None;
                let mut aggvariadic__ = None;
                let mut aggkind__ = None;
                let mut agglevelsup__ = None;
                let mut aggsplit__ = None;
                let mut aggno__ = None;
                let mut aggtransno__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Aggfnoid => {
                            if aggfnoid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggfnoid"));
                            }
                            aggfnoid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Aggtype => {
                            if aggtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggtype"));
                            }
                            aggtype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Aggcollid => {
                            if aggcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggcollid"));
                            }
                            aggcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Aggargtypes => {
                            if aggargtypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggargtypes"));
                            }
                            aggargtypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggdirectargs => {
                            if aggdirectargs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggdirectargs"));
                            }
                            aggdirectargs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggorder => {
                            if aggorder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggorder"));
                            }
                            aggorder__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggdistinct => {
                            if aggdistinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggdistinct"));
                            }
                            aggdistinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggfilter => {
                            if aggfilter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggfilter"));
                            }
                            aggfilter__ = map_.next_value()?;
                        }
                        GeneratedField::Aggstar => {
                            if aggstar__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggstar"));
                            }
                            aggstar__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggvariadic => {
                            if aggvariadic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggvariadic"));
                            }
                            aggvariadic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggkind => {
                            if aggkind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggkind"));
                            }
                            aggkind__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Agglevelsup => {
                            if agglevelsup__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agglevelsup"));
                            }
                            agglevelsup__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Aggsplit => {
                            if aggsplit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggsplit"));
                            }
                            aggsplit__ = Some(map_.next_value::<AggSplit>()? as i32);
                        }
                        GeneratedField::Aggno => {
                            if aggno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggno"));
                            }
                            aggno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Aggtransno => {
                            if aggtransno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggtransno"));
                            }
                            aggtransno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Aggref {
                    xpr: xpr__,
                    aggfnoid: aggfnoid__.unwrap_or_default(),
                    aggtype: aggtype__.unwrap_or_default(),
                    aggcollid: aggcollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    aggargtypes: aggargtypes__.unwrap_or_default(),
                    aggdirectargs: aggdirectargs__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    aggorder: aggorder__.unwrap_or_default(),
                    aggdistinct: aggdistinct__.unwrap_or_default(),
                    aggfilter: aggfilter__,
                    aggstar: aggstar__.unwrap_or_default(),
                    aggvariadic: aggvariadic__.unwrap_or_default(),
                    aggkind: aggkind__.unwrap_or_default(),
                    agglevelsup: agglevelsup__.unwrap_or_default(),
                    aggsplit: aggsplit__.unwrap_or_default(),
                    aggno: aggno__.unwrap_or_default(),
                    aggtransno: aggtransno__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Aggref", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Alias {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.aliasname.is_empty() {
            len += 1;
        }
        if !self.colnames.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Alias", len)?;
        if !self.aliasname.is_empty() {
            struct_ser.serialize_field("aliasname", &self.aliasname)?;
        }
        if !self.colnames.is_empty() {
            struct_ser.serialize_field("colnames", &self.colnames)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Alias {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aliasname",
            "colnames",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Aliasname,
            Colnames,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aliasname" => Ok(GeneratedField::Aliasname),
                            "colnames" => Ok(GeneratedField::Colnames),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Alias;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Alias")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Alias, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut aliasname__ = None;
                let mut colnames__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Aliasname => {
                            if aliasname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aliasname"));
                            }
                            aliasname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Colnames => {
                            if colnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colnames"));
                            }
                            colnames__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Alias {
                    aliasname: aliasname__.unwrap_or_default(),
                    colnames: colnames__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Alias", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterCollationStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.collname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterCollationStmt", len)?;
        if !self.collname.is_empty() {
            struct_ser.serialize_field("collname", &self.collname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterCollationStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "collname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Collname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "collname" => Ok(GeneratedField::Collname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterCollationStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterCollationStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterCollationStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut collname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Collname => {
                            if collname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collname"));
                            }
                            collname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterCollationStmt {
                    collname: collname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterCollationStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterDatabaseRefreshCollStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dbname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterDatabaseRefreshCollStmt", len)?;
        if !self.dbname.is_empty() {
            struct_ser.serialize_field("dbname", &self.dbname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterDatabaseRefreshCollStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dbname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dbname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dbname" => Ok(GeneratedField::Dbname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterDatabaseRefreshCollStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterDatabaseRefreshCollStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterDatabaseRefreshCollStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dbname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dbname => {
                            if dbname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dbname"));
                            }
                            dbname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterDatabaseRefreshCollStmt {
                    dbname: dbname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterDatabaseRefreshCollStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterDatabaseSetStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dbname.is_empty() {
            len += 1;
        }
        if self.setstmt.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterDatabaseSetStmt", len)?;
        if !self.dbname.is_empty() {
            struct_ser.serialize_field("dbname", &self.dbname)?;
        }
        if let Some(v) = self.setstmt.as_ref() {
            struct_ser.serialize_field("setstmt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterDatabaseSetStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dbname",
            "setstmt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dbname,
            Setstmt,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dbname" => Ok(GeneratedField::Dbname),
                            "setstmt" => Ok(GeneratedField::Setstmt),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterDatabaseSetStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterDatabaseSetStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterDatabaseSetStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dbname__ = None;
                let mut setstmt__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dbname => {
                            if dbname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dbname"));
                            }
                            dbname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Setstmt => {
                            if setstmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setstmt"));
                            }
                            setstmt__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterDatabaseSetStmt {
                    dbname: dbname__.unwrap_or_default(),
                    setstmt: setstmt__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterDatabaseSetStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterDatabaseStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dbname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterDatabaseStmt", len)?;
        if !self.dbname.is_empty() {
            struct_ser.serialize_field("dbname", &self.dbname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterDatabaseStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dbname",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dbname,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dbname" => Ok(GeneratedField::Dbname),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterDatabaseStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterDatabaseStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterDatabaseStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dbname__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dbname => {
                            if dbname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dbname"));
                            }
                            dbname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterDatabaseStmt {
                    dbname: dbname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterDatabaseStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterDefaultPrivilegesStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.options.is_empty() {
            len += 1;
        }
        if self.action.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterDefaultPrivilegesStmt", len)?;
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.action.as_ref() {
            struct_ser.serialize_field("action", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterDefaultPrivilegesStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "options",
            "action",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Options,
            Action,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "options" => Ok(GeneratedField::Options),
                            "action" => Ok(GeneratedField::Action),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterDefaultPrivilegesStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterDefaultPrivilegesStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterDefaultPrivilegesStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut options__ = None;
                let mut action__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterDefaultPrivilegesStmt {
                    options: options__.unwrap_or_default(),
                    action: action__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterDefaultPrivilegesStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterDomainStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subtype.is_empty() {
            len += 1;
        }
        if !self.type_name.is_empty() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.def.is_some() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterDomainStmt", len)?;
        if !self.subtype.is_empty() {
            struct_ser.serialize_field("subtype", &self.subtype)?;
        }
        if !self.type_name.is_empty() {
            struct_ser.serialize_field("typeName", &self.type_name)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.def.as_ref() {
            struct_ser.serialize_field("def", v)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterDomainStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subtype",
            "type_name",
            "typeName",
            "name",
            "def",
            "behavior",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Subtype,
            TypeName,
            Name,
            Def,
            Behavior,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subtype" => Ok(GeneratedField::Subtype),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "name" => Ok(GeneratedField::Name),
                            "def" => Ok(GeneratedField::Def),
                            "behavior" => Ok(GeneratedField::Behavior),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterDomainStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterDomainStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterDomainStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subtype__ = None;
                let mut type_name__ = None;
                let mut name__ = None;
                let mut def__ = None;
                let mut behavior__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Subtype => {
                            if subtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subtype"));
                            }
                            subtype__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Def => {
                            if def__.is_some() {
                                return Err(serde::de::Error::duplicate_field("def"));
                            }
                            def__ = map_.next_value()?;
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterDomainStmt {
                    subtype: subtype__.unwrap_or_default(),
                    type_name: type_name__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    def: def__,
                    behavior: behavior__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterDomainStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterEnumStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.type_name.is_empty() {
            len += 1;
        }
        if !self.old_val.is_empty() {
            len += 1;
        }
        if !self.new_val.is_empty() {
            len += 1;
        }
        if !self.new_val_neighbor.is_empty() {
            len += 1;
        }
        if self.new_val_is_after {
            len += 1;
        }
        if self.skip_if_new_val_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterEnumStmt", len)?;
        if !self.type_name.is_empty() {
            struct_ser.serialize_field("typeName", &self.type_name)?;
        }
        if !self.old_val.is_empty() {
            struct_ser.serialize_field("oldVal", &self.old_val)?;
        }
        if !self.new_val.is_empty() {
            struct_ser.serialize_field("newVal", &self.new_val)?;
        }
        if !self.new_val_neighbor.is_empty() {
            struct_ser.serialize_field("newValNeighbor", &self.new_val_neighbor)?;
        }
        if self.new_val_is_after {
            struct_ser.serialize_field("newValIsAfter", &self.new_val_is_after)?;
        }
        if self.skip_if_new_val_exists {
            struct_ser.serialize_field("skipIfNewValExists", &self.skip_if_new_val_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterEnumStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "old_val",
            "oldVal",
            "new_val",
            "newVal",
            "new_val_neighbor",
            "newValNeighbor",
            "new_val_is_after",
            "newValIsAfter",
            "skip_if_new_val_exists",
            "skipIfNewValExists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            OldVal,
            NewVal,
            NewValNeighbor,
            NewValIsAfter,
            SkipIfNewValExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "oldVal" | "old_val" => Ok(GeneratedField::OldVal),
                            "newVal" | "new_val" => Ok(GeneratedField::NewVal),
                            "newValNeighbor" | "new_val_neighbor" => Ok(GeneratedField::NewValNeighbor),
                            "newValIsAfter" | "new_val_is_after" => Ok(GeneratedField::NewValIsAfter),
                            "skipIfNewValExists" | "skip_if_new_val_exists" => Ok(GeneratedField::SkipIfNewValExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterEnumStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterEnumStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterEnumStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut old_val__ = None;
                let mut new_val__ = None;
                let mut new_val_neighbor__ = None;
                let mut new_val_is_after__ = None;
                let mut skip_if_new_val_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OldVal => {
                            if old_val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oldVal"));
                            }
                            old_val__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewVal => {
                            if new_val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newVal"));
                            }
                            new_val__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewValNeighbor => {
                            if new_val_neighbor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newValNeighbor"));
                            }
                            new_val_neighbor__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewValIsAfter => {
                            if new_val_is_after__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newValIsAfter"));
                            }
                            new_val_is_after__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SkipIfNewValExists => {
                            if skip_if_new_val_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skipIfNewValExists"));
                            }
                            skip_if_new_val_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterEnumStmt {
                    type_name: type_name__.unwrap_or_default(),
                    old_val: old_val__.unwrap_or_default(),
                    new_val: new_val__.unwrap_or_default(),
                    new_val_neighbor: new_val_neighbor__.unwrap_or_default(),
                    new_val_is_after: new_val_is_after__.unwrap_or_default(),
                    skip_if_new_val_exists: skip_if_new_val_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterEnumStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterEventTrigStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.trigname.is_empty() {
            len += 1;
        }
        if !self.tgenabled.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterEventTrigStmt", len)?;
        if !self.trigname.is_empty() {
            struct_ser.serialize_field("trigname", &self.trigname)?;
        }
        if !self.tgenabled.is_empty() {
            struct_ser.serialize_field("tgenabled", &self.tgenabled)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterEventTrigStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "trigname",
            "tgenabled",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Trigname,
            Tgenabled,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "trigname" => Ok(GeneratedField::Trigname),
                            "tgenabled" => Ok(GeneratedField::Tgenabled),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterEventTrigStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterEventTrigStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterEventTrigStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut trigname__ = None;
                let mut tgenabled__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Trigname => {
                            if trigname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trigname"));
                            }
                            trigname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Tgenabled => {
                            if tgenabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tgenabled"));
                            }
                            tgenabled__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterEventTrigStmt {
                    trigname: trigname__.unwrap_or_default(),
                    tgenabled: tgenabled__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterEventTrigStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterExtensionContentsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.extname.is_empty() {
            len += 1;
        }
        if self.action != 0 {
            len += 1;
        }
        if self.objtype != 0 {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterExtensionContentsStmt", len)?;
        if !self.extname.is_empty() {
            struct_ser.serialize_field("extname", &self.extname)?;
        }
        if self.action != 0 {
            struct_ser.serialize_field("action", &self.action)?;
        }
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterExtensionContentsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "extname",
            "action",
            "objtype",
            "object",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Extname,
            Action,
            Objtype,
            Object,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "extname" => Ok(GeneratedField::Extname),
                            "action" => Ok(GeneratedField::Action),
                            "objtype" => Ok(GeneratedField::Objtype),
                            "object" => Ok(GeneratedField::Object),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterExtensionContentsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterExtensionContentsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterExtensionContentsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut extname__ = None;
                let mut action__ = None;
                let mut objtype__ = None;
                let mut object__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Extname => {
                            if extname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extname"));
                            }
                            extname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterExtensionContentsStmt {
                    extname: extname__.unwrap_or_default(),
                    action: action__.unwrap_or_default(),
                    objtype: objtype__.unwrap_or_default(),
                    object: object__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterExtensionContentsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterExtensionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.extname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterExtensionStmt", len)?;
        if !self.extname.is_empty() {
            struct_ser.serialize_field("extname", &self.extname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterExtensionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "extname",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Extname,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "extname" => Ok(GeneratedField::Extname),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterExtensionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterExtensionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterExtensionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut extname__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Extname => {
                            if extname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extname"));
                            }
                            extname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterExtensionStmt {
                    extname: extname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterExtensionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterFdwStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fdwname.is_empty() {
            len += 1;
        }
        if !self.func_options.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterFdwStmt", len)?;
        if !self.fdwname.is_empty() {
            struct_ser.serialize_field("fdwname", &self.fdwname)?;
        }
        if !self.func_options.is_empty() {
            struct_ser.serialize_field("func_options", &self.func_options)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterFdwStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fdwname",
            "func_options",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fdwname,
            FuncOptions,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fdwname" => Ok(GeneratedField::Fdwname),
                            "func_options" => Ok(GeneratedField::FuncOptions),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterFdwStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterFdwStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterFdwStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fdwname__ = None;
                let mut func_options__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fdwname => {
                            if fdwname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fdwname"));
                            }
                            fdwname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FuncOptions => {
                            if func_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func_options"));
                            }
                            func_options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterFdwStmt {
                    fdwname: fdwname__.unwrap_or_default(),
                    func_options: func_options__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterFdwStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterForeignServerStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.servername.is_empty() {
            len += 1;
        }
        if !self.version.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.has_version {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterForeignServerStmt", len)?;
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if !self.version.is_empty() {
            struct_ser.serialize_field("version", &self.version)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.has_version {
            struct_ser.serialize_field("has_version", &self.has_version)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterForeignServerStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "servername",
            "version",
            "options",
            "has_version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Servername,
            Version,
            Options,
            HasVersion,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "servername" => Ok(GeneratedField::Servername),
                            "version" => Ok(GeneratedField::Version),
                            "options" => Ok(GeneratedField::Options),
                            "has_version" => Ok(GeneratedField::HasVersion),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterForeignServerStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterForeignServerStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterForeignServerStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut servername__ = None;
                let mut version__ = None;
                let mut options__ = None;
                let mut has_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasVersion => {
                            if has_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("has_version"));
                            }
                            has_version__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterForeignServerStmt {
                    servername: servername__.unwrap_or_default(),
                    version: version__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    has_version: has_version__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterForeignServerStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterFunctionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.objtype != 0 {
            len += 1;
        }
        if self.func.is_some() {
            len += 1;
        }
        if !self.actions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterFunctionStmt", len)?;
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if let Some(v) = self.func.as_ref() {
            struct_ser.serialize_field("func", v)?;
        }
        if !self.actions.is_empty() {
            struct_ser.serialize_field("actions", &self.actions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterFunctionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objtype",
            "func",
            "actions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objtype,
            Func,
            Actions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objtype" => Ok(GeneratedField::Objtype),
                            "func" => Ok(GeneratedField::Func),
                            "actions" => Ok(GeneratedField::Actions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterFunctionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterFunctionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterFunctionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objtype__ = None;
                let mut func__ = None;
                let mut actions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = map_.next_value()?;
                        }
                        GeneratedField::Actions => {
                            if actions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("actions"));
                            }
                            actions__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterFunctionStmt {
                    objtype: objtype__.unwrap_or_default(),
                    func: func__,
                    actions: actions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterFunctionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterObjectDependsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_type != 0 {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if self.extname.is_some() {
            len += 1;
        }
        if self.remove {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterObjectDependsStmt", len)?;
        if self.object_type != 0 {
            let v = ObjectType::try_from(self.object_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.object_type)))?;
            struct_ser.serialize_field("objectType", &v)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if let Some(v) = self.extname.as_ref() {
            struct_ser.serialize_field("extname", v)?;
        }
        if self.remove {
            struct_ser.serialize_field("remove", &self.remove)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterObjectDependsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_type",
            "objectType",
            "relation",
            "object",
            "extname",
            "remove",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectType,
            Relation,
            Object,
            Extname,
            Remove,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            "relation" => Ok(GeneratedField::Relation),
                            "object" => Ok(GeneratedField::Object),
                            "extname" => Ok(GeneratedField::Extname),
                            "remove" => Ok(GeneratedField::Remove),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterObjectDependsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterObjectDependsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterObjectDependsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_type__ = None;
                let mut relation__ = None;
                let mut object__ = None;
                let mut extname__ = None;
                let mut remove__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Extname => {
                            if extname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extname"));
                            }
                            extname__ = map_.next_value()?;
                        }
                        GeneratedField::Remove => {
                            if remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remove"));
                            }
                            remove__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterObjectDependsStmt {
                    object_type: object_type__.unwrap_or_default(),
                    relation: relation__,
                    object: object__,
                    extname: extname__,
                    remove: remove__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterObjectDependsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterObjectSchemaStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_type != 0 {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if !self.newschema.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterObjectSchemaStmt", len)?;
        if self.object_type != 0 {
            let v = ObjectType::try_from(self.object_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.object_type)))?;
            struct_ser.serialize_field("objectType", &v)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if !self.newschema.is_empty() {
            struct_ser.serialize_field("newschema", &self.newschema)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterObjectSchemaStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_type",
            "objectType",
            "relation",
            "object",
            "newschema",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectType,
            Relation,
            Object,
            Newschema,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            "relation" => Ok(GeneratedField::Relation),
                            "object" => Ok(GeneratedField::Object),
                            "newschema" => Ok(GeneratedField::Newschema),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterObjectSchemaStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterObjectSchemaStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterObjectSchemaStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_type__ = None;
                let mut relation__ = None;
                let mut object__ = None;
                let mut newschema__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Newschema => {
                            if newschema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newschema"));
                            }
                            newschema__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterObjectSchemaStmt {
                    object_type: object_type__.unwrap_or_default(),
                    relation: relation__,
                    object: object__,
                    newschema: newschema__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterObjectSchemaStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterOpFamilyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.opfamilyname.is_empty() {
            len += 1;
        }
        if !self.amname.is_empty() {
            len += 1;
        }
        if self.is_drop {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterOpFamilyStmt", len)?;
        if !self.opfamilyname.is_empty() {
            struct_ser.serialize_field("opfamilyname", &self.opfamilyname)?;
        }
        if !self.amname.is_empty() {
            struct_ser.serialize_field("amname", &self.amname)?;
        }
        if self.is_drop {
            struct_ser.serialize_field("isDrop", &self.is_drop)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterOpFamilyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "opfamilyname",
            "amname",
            "is_drop",
            "isDrop",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Opfamilyname,
            Amname,
            IsDrop,
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opfamilyname" => Ok(GeneratedField::Opfamilyname),
                            "amname" => Ok(GeneratedField::Amname),
                            "isDrop" | "is_drop" => Ok(GeneratedField::IsDrop),
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterOpFamilyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterOpFamilyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterOpFamilyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut opfamilyname__ = None;
                let mut amname__ = None;
                let mut is_drop__ = None;
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Opfamilyname => {
                            if opfamilyname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opfamilyname"));
                            }
                            opfamilyname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amname => {
                            if amname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amname"));
                            }
                            amname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsDrop => {
                            if is_drop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isDrop"));
                            }
                            is_drop__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterOpFamilyStmt {
                    opfamilyname: opfamilyname__.unwrap_or_default(),
                    amname: amname__.unwrap_or_default(),
                    is_drop: is_drop__.unwrap_or_default(),
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterOpFamilyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterOperatorStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.opername.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterOperatorStmt", len)?;
        if let Some(v) = self.opername.as_ref() {
            struct_ser.serialize_field("opername", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterOperatorStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "opername",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Opername,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opername" => Ok(GeneratedField::Opername),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterOperatorStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterOperatorStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterOperatorStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut opername__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Opername => {
                            if opername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opername"));
                            }
                            opername__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterOperatorStmt {
                    opername: opername__,
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterOperatorStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterOwnerStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_type != 0 {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if self.newowner.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterOwnerStmt", len)?;
        if self.object_type != 0 {
            let v = ObjectType::try_from(self.object_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.object_type)))?;
            struct_ser.serialize_field("objectType", &v)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if let Some(v) = self.newowner.as_ref() {
            struct_ser.serialize_field("newowner", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterOwnerStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_type",
            "objectType",
            "relation",
            "object",
            "newowner",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectType,
            Relation,
            Object,
            Newowner,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            "relation" => Ok(GeneratedField::Relation),
                            "object" => Ok(GeneratedField::Object),
                            "newowner" => Ok(GeneratedField::Newowner),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterOwnerStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterOwnerStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterOwnerStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_type__ = None;
                let mut relation__ = None;
                let mut object__ = None;
                let mut newowner__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Newowner => {
                            if newowner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newowner"));
                            }
                            newowner__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterOwnerStmt {
                    object_type: object_type__.unwrap_or_default(),
                    relation: relation__,
                    object: object__,
                    newowner: newowner__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterOwnerStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterPolicyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.policy_name.is_empty() {
            len += 1;
        }
        if self.table.is_some() {
            len += 1;
        }
        if !self.roles.is_empty() {
            len += 1;
        }
        if self.qual.is_some() {
            len += 1;
        }
        if self.with_check.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterPolicyStmt", len)?;
        if !self.policy_name.is_empty() {
            struct_ser.serialize_field("policy_name", &self.policy_name)?;
        }
        if let Some(v) = self.table.as_ref() {
            struct_ser.serialize_field("table", v)?;
        }
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if let Some(v) = self.qual.as_ref() {
            struct_ser.serialize_field("qual", v)?;
        }
        if let Some(v) = self.with_check.as_ref() {
            struct_ser.serialize_field("with_check", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterPolicyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "policy_name",
            "table",
            "roles",
            "qual",
            "with_check",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PolicyName,
            Table,
            Roles,
            Qual,
            WithCheck,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "policy_name" => Ok(GeneratedField::PolicyName),
                            "table" => Ok(GeneratedField::Table),
                            "roles" => Ok(GeneratedField::Roles),
                            "qual" => Ok(GeneratedField::Qual),
                            "with_check" => Ok(GeneratedField::WithCheck),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterPolicyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterPolicyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterPolicyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut policy_name__ = None;
                let mut table__ = None;
                let mut roles__ = None;
                let mut qual__ = None;
                let mut with_check__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PolicyName => {
                            if policy_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("policy_name"));
                            }
                            policy_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Table => {
                            if table__.is_some() {
                                return Err(serde::de::Error::duplicate_field("table"));
                            }
                            table__ = map_.next_value()?;
                        }
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Qual => {
                            if qual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("qual"));
                            }
                            qual__ = map_.next_value()?;
                        }
                        GeneratedField::WithCheck => {
                            if with_check__.is_some() {
                                return Err(serde::de::Error::duplicate_field("with_check"));
                            }
                            with_check__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterPolicyStmt {
                    policy_name: policy_name__.unwrap_or_default(),
                    table: table__,
                    roles: roles__.unwrap_or_default(),
                    qual: qual__,
                    with_check: with_check__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterPolicyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterPublicationAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ALTER_PUBLICATION_ACTION_UNDEFINED",
            Self::ApAddObjects => "AP_AddObjects",
            Self::ApDropObjects => "AP_DropObjects",
            Self::ApSetObjects => "AP_SetObjects",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlterPublicationAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALTER_PUBLICATION_ACTION_UNDEFINED",
            "AP_AddObjects",
            "AP_DropObjects",
            "AP_SetObjects",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterPublicationAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALTER_PUBLICATION_ACTION_UNDEFINED" => Ok(AlterPublicationAction::Undefined),
                    "AP_AddObjects" => Ok(AlterPublicationAction::ApAddObjects),
                    "AP_DropObjects" => Ok(AlterPublicationAction::ApDropObjects),
                    "AP_SetObjects" => Ok(AlterPublicationAction::ApSetObjects),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlterPublicationStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pubname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if !self.pubobjects.is_empty() {
            len += 1;
        }
        if self.for_all_tables {
            len += 1;
        }
        if self.action != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterPublicationStmt", len)?;
        if !self.pubname.is_empty() {
            struct_ser.serialize_field("pubname", &self.pubname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if !self.pubobjects.is_empty() {
            struct_ser.serialize_field("pubobjects", &self.pubobjects)?;
        }
        if self.for_all_tables {
            struct_ser.serialize_field("for_all_tables", &self.for_all_tables)?;
        }
        if self.action != 0 {
            let v = AlterPublicationAction::try_from(self.action)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.action)))?;
            struct_ser.serialize_field("action", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterPublicationStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pubname",
            "options",
            "pubobjects",
            "for_all_tables",
            "action",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Pubname,
            Options,
            Pubobjects,
            ForAllTables,
            Action,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pubname" => Ok(GeneratedField::Pubname),
                            "options" => Ok(GeneratedField::Options),
                            "pubobjects" => Ok(GeneratedField::Pubobjects),
                            "for_all_tables" => Ok(GeneratedField::ForAllTables),
                            "action" => Ok(GeneratedField::Action),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterPublicationStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterPublicationStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterPublicationStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pubname__ = None;
                let mut options__ = None;
                let mut pubobjects__ = None;
                let mut for_all_tables__ = None;
                let mut action__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Pubname => {
                            if pubname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubname"));
                            }
                            pubname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pubobjects => {
                            if pubobjects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubobjects"));
                            }
                            pubobjects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForAllTables => {
                            if for_all_tables__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_all_tables"));
                            }
                            for_all_tables__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = Some(map_.next_value::<AlterPublicationAction>()? as i32);
                        }
                    }
                }
                Ok(AlterPublicationStmt {
                    pubname: pubname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    pubobjects: pubobjects__.unwrap_or_default(),
                    for_all_tables: for_all_tables__.unwrap_or_default(),
                    action: action__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterPublicationStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterRoleSetStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.role.is_some() {
            len += 1;
        }
        if !self.database.is_empty() {
            len += 1;
        }
        if self.setstmt.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterRoleSetStmt", len)?;
        if let Some(v) = self.role.as_ref() {
            struct_ser.serialize_field("role", v)?;
        }
        if !self.database.is_empty() {
            struct_ser.serialize_field("database", &self.database)?;
        }
        if let Some(v) = self.setstmt.as_ref() {
            struct_ser.serialize_field("setstmt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterRoleSetStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "role",
            "database",
            "setstmt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Role,
            Database,
            Setstmt,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "role" => Ok(GeneratedField::Role),
                            "database" => Ok(GeneratedField::Database),
                            "setstmt" => Ok(GeneratedField::Setstmt),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterRoleSetStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterRoleSetStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterRoleSetStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut role__ = None;
                let mut database__ = None;
                let mut setstmt__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Role => {
                            if role__.is_some() {
                                return Err(serde::de::Error::duplicate_field("role"));
                            }
                            role__ = map_.next_value()?;
                        }
                        GeneratedField::Database => {
                            if database__.is_some() {
                                return Err(serde::de::Error::duplicate_field("database"));
                            }
                            database__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Setstmt => {
                            if setstmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setstmt"));
                            }
                            setstmt__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterRoleSetStmt {
                    role: role__,
                    database: database__.unwrap_or_default(),
                    setstmt: setstmt__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterRoleSetStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterRoleStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.role.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.action != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterRoleStmt", len)?;
        if let Some(v) = self.role.as_ref() {
            struct_ser.serialize_field("role", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.action != 0 {
            struct_ser.serialize_field("action", &self.action)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterRoleStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "role",
            "options",
            "action",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Role,
            Options,
            Action,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "role" => Ok(GeneratedField::Role),
                            "options" => Ok(GeneratedField::Options),
                            "action" => Ok(GeneratedField::Action),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterRoleStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterRoleStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterRoleStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut role__ = None;
                let mut options__ = None;
                let mut action__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Role => {
                            if role__.is_some() {
                                return Err(serde::de::Error::duplicate_field("role"));
                            }
                            role__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AlterRoleStmt {
                    role: role__,
                    options: options__.unwrap_or_default(),
                    action: action__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterRoleStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterSeqStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.sequence.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.for_identity {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterSeqStmt", len)?;
        if let Some(v) = self.sequence.as_ref() {
            struct_ser.serialize_field("sequence", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.for_identity {
            struct_ser.serialize_field("for_identity", &self.for_identity)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterSeqStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sequence",
            "options",
            "for_identity",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sequence,
            Options,
            ForIdentity,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sequence" => Ok(GeneratedField::Sequence),
                            "options" => Ok(GeneratedField::Options),
                            "for_identity" => Ok(GeneratedField::ForIdentity),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterSeqStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterSeqStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterSeqStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sequence__ = None;
                let mut options__ = None;
                let mut for_identity__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sequence => {
                            if sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequence"));
                            }
                            sequence__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForIdentity => {
                            if for_identity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_identity"));
                            }
                            for_identity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterSeqStmt {
                    sequence: sequence__,
                    options: options__.unwrap_or_default(),
                    for_identity: for_identity__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterSeqStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterStatsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.defnames.is_empty() {
            len += 1;
        }
        if self.stxstattarget != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterStatsStmt", len)?;
        if !self.defnames.is_empty() {
            struct_ser.serialize_field("defnames", &self.defnames)?;
        }
        if self.stxstattarget != 0 {
            struct_ser.serialize_field("stxstattarget", &self.stxstattarget)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterStatsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "defnames",
            "stxstattarget",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Defnames,
            Stxstattarget,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "defnames" => Ok(GeneratedField::Defnames),
                            "stxstattarget" => Ok(GeneratedField::Stxstattarget),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterStatsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterStatsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterStatsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut defnames__ = None;
                let mut stxstattarget__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Defnames => {
                            if defnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defnames"));
                            }
                            defnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Stxstattarget => {
                            if stxstattarget__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stxstattarget"));
                            }
                            stxstattarget__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterStatsStmt {
                    defnames: defnames__.unwrap_or_default(),
                    stxstattarget: stxstattarget__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterStatsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterSubscriptionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.subname.is_empty() {
            len += 1;
        }
        if !self.conninfo.is_empty() {
            len += 1;
        }
        if !self.publication.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterSubscriptionStmt", len)?;
        if self.kind != 0 {
            let v = AlterSubscriptionType::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.subname.is_empty() {
            struct_ser.serialize_field("subname", &self.subname)?;
        }
        if !self.conninfo.is_empty() {
            struct_ser.serialize_field("conninfo", &self.conninfo)?;
        }
        if !self.publication.is_empty() {
            struct_ser.serialize_field("publication", &self.publication)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterSubscriptionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "subname",
            "conninfo",
            "publication",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Subname,
            Conninfo,
            Publication,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "subname" => Ok(GeneratedField::Subname),
                            "conninfo" => Ok(GeneratedField::Conninfo),
                            "publication" => Ok(GeneratedField::Publication),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterSubscriptionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterSubscriptionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterSubscriptionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut subname__ = None;
                let mut conninfo__ = None;
                let mut publication__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<AlterSubscriptionType>()? as i32);
                        }
                        GeneratedField::Subname => {
                            if subname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subname"));
                            }
                            subname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Conninfo => {
                            if conninfo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conninfo"));
                            }
                            conninfo__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Publication => {
                            if publication__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publication"));
                            }
                            publication__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterSubscriptionStmt {
                    kind: kind__.unwrap_or_default(),
                    subname: subname__.unwrap_or_default(),
                    conninfo: conninfo__.unwrap_or_default(),
                    publication: publication__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterSubscriptionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterSubscriptionType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ALTER_SUBSCRIPTION_TYPE_UNDEFINED",
            Self::AlterSubscriptionOptions => "ALTER_SUBSCRIPTION_OPTIONS",
            Self::AlterSubscriptionConnection => "ALTER_SUBSCRIPTION_CONNECTION",
            Self::AlterSubscriptionSetPublication => "ALTER_SUBSCRIPTION_SET_PUBLICATION",
            Self::AlterSubscriptionAddPublication => "ALTER_SUBSCRIPTION_ADD_PUBLICATION",
            Self::AlterSubscriptionDropPublication => "ALTER_SUBSCRIPTION_DROP_PUBLICATION",
            Self::AlterSubscriptionRefresh => "ALTER_SUBSCRIPTION_REFRESH",
            Self::AlterSubscriptionEnabled => "ALTER_SUBSCRIPTION_ENABLED",
            Self::AlterSubscriptionSkip => "ALTER_SUBSCRIPTION_SKIP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlterSubscriptionType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALTER_SUBSCRIPTION_TYPE_UNDEFINED",
            "ALTER_SUBSCRIPTION_OPTIONS",
            "ALTER_SUBSCRIPTION_CONNECTION",
            "ALTER_SUBSCRIPTION_SET_PUBLICATION",
            "ALTER_SUBSCRIPTION_ADD_PUBLICATION",
            "ALTER_SUBSCRIPTION_DROP_PUBLICATION",
            "ALTER_SUBSCRIPTION_REFRESH",
            "ALTER_SUBSCRIPTION_ENABLED",
            "ALTER_SUBSCRIPTION_SKIP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterSubscriptionType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALTER_SUBSCRIPTION_TYPE_UNDEFINED" => Ok(AlterSubscriptionType::Undefined),
                    "ALTER_SUBSCRIPTION_OPTIONS" => Ok(AlterSubscriptionType::AlterSubscriptionOptions),
                    "ALTER_SUBSCRIPTION_CONNECTION" => Ok(AlterSubscriptionType::AlterSubscriptionConnection),
                    "ALTER_SUBSCRIPTION_SET_PUBLICATION" => Ok(AlterSubscriptionType::AlterSubscriptionSetPublication),
                    "ALTER_SUBSCRIPTION_ADD_PUBLICATION" => Ok(AlterSubscriptionType::AlterSubscriptionAddPublication),
                    "ALTER_SUBSCRIPTION_DROP_PUBLICATION" => Ok(AlterSubscriptionType::AlterSubscriptionDropPublication),
                    "ALTER_SUBSCRIPTION_REFRESH" => Ok(AlterSubscriptionType::AlterSubscriptionRefresh),
                    "ALTER_SUBSCRIPTION_ENABLED" => Ok(AlterSubscriptionType::AlterSubscriptionEnabled),
                    "ALTER_SUBSCRIPTION_SKIP" => Ok(AlterSubscriptionType::AlterSubscriptionSkip),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlterSystemStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.setstmt.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterSystemStmt", len)?;
        if let Some(v) = self.setstmt.as_ref() {
            struct_ser.serialize_field("setstmt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterSystemStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "setstmt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Setstmt,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "setstmt" => Ok(GeneratedField::Setstmt),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterSystemStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterSystemStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterSystemStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut setstmt__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Setstmt => {
                            if setstmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setstmt"));
                            }
                            setstmt__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlterSystemStmt {
                    setstmt: setstmt__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterSystemStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTsConfigType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AlterTsconfigTypeUndefined => "ALTER_TSCONFIG_TYPE_UNDEFINED",
            Self::AlterTsconfigAddMapping => "ALTER_TSCONFIG_ADD_MAPPING",
            Self::AlterTsconfigAlterMappingForToken => "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN",
            Self::AlterTsconfigReplaceDict => "ALTER_TSCONFIG_REPLACE_DICT",
            Self::AlterTsconfigReplaceDictForToken => "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN",
            Self::AlterTsconfigDropMapping => "ALTER_TSCONFIG_DROP_MAPPING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlterTsConfigType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALTER_TSCONFIG_TYPE_UNDEFINED",
            "ALTER_TSCONFIG_ADD_MAPPING",
            "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN",
            "ALTER_TSCONFIG_REPLACE_DICT",
            "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN",
            "ALTER_TSCONFIG_DROP_MAPPING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTsConfigType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALTER_TSCONFIG_TYPE_UNDEFINED" => Ok(AlterTsConfigType::AlterTsconfigTypeUndefined),
                    "ALTER_TSCONFIG_ADD_MAPPING" => Ok(AlterTsConfigType::AlterTsconfigAddMapping),
                    "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN" => Ok(AlterTsConfigType::AlterTsconfigAlterMappingForToken),
                    "ALTER_TSCONFIG_REPLACE_DICT" => Ok(AlterTsConfigType::AlterTsconfigReplaceDict),
                    "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN" => Ok(AlterTsConfigType::AlterTsconfigReplaceDictForToken),
                    "ALTER_TSCONFIG_DROP_MAPPING" => Ok(AlterTsConfigType::AlterTsconfigDropMapping),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTsConfigurationStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.cfgname.is_empty() {
            len += 1;
        }
        if !self.tokentype.is_empty() {
            len += 1;
        }
        if !self.dicts.is_empty() {
            len += 1;
        }
        if self.r#override {
            len += 1;
        }
        if self.replace {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTSConfigurationStmt", len)?;
        if self.kind != 0 {
            let v = AlterTsConfigType::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.cfgname.is_empty() {
            struct_ser.serialize_field("cfgname", &self.cfgname)?;
        }
        if !self.tokentype.is_empty() {
            struct_ser.serialize_field("tokentype", &self.tokentype)?;
        }
        if !self.dicts.is_empty() {
            struct_ser.serialize_field("dicts", &self.dicts)?;
        }
        if self.r#override {
            struct_ser.serialize_field("override", &self.r#override)?;
        }
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTsConfigurationStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "cfgname",
            "tokentype",
            "dicts",
            "override",
            "replace",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Cfgname,
            Tokentype,
            Dicts,
            Override,
            Replace,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "cfgname" => Ok(GeneratedField::Cfgname),
                            "tokentype" => Ok(GeneratedField::Tokentype),
                            "dicts" => Ok(GeneratedField::Dicts),
                            "override" => Ok(GeneratedField::Override),
                            "replace" => Ok(GeneratedField::Replace),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTsConfigurationStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTSConfigurationStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTsConfigurationStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut cfgname__ = None;
                let mut tokentype__ = None;
                let mut dicts__ = None;
                let mut r#override__ = None;
                let mut replace__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<AlterTsConfigType>()? as i32);
                        }
                        GeneratedField::Cfgname => {
                            if cfgname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cfgname"));
                            }
                            cfgname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Tokentype => {
                            if tokentype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tokentype"));
                            }
                            tokentype__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Dicts => {
                            if dicts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dicts"));
                            }
                            dicts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Override => {
                            if r#override__.is_some() {
                                return Err(serde::de::Error::duplicate_field("override"));
                            }
                            r#override__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTsConfigurationStmt {
                    kind: kind__.unwrap_or_default(),
                    cfgname: cfgname__.unwrap_or_default(),
                    tokentype: tokentype__.unwrap_or_default(),
                    dicts: dicts__.unwrap_or_default(),
                    r#override: r#override__.unwrap_or_default(),
                    replace: replace__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTSConfigurationStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTsDictionaryStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dictname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTSDictionaryStmt", len)?;
        if !self.dictname.is_empty() {
            struct_ser.serialize_field("dictname", &self.dictname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTsDictionaryStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dictname",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dictname,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dictname" => Ok(GeneratedField::Dictname),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTsDictionaryStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTSDictionaryStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTsDictionaryStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dictname__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dictname => {
                            if dictname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dictname"));
                            }
                            dictname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTsDictionaryStmt {
                    dictname: dictname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTSDictionaryStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTableCmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.subtype != 0 {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.num != 0 {
            len += 1;
        }
        if self.newowner.is_some() {
            len += 1;
        }
        if self.def.is_some() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        if self.recurse {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTableCmd", len)?;
        if self.subtype != 0 {
            let v = AlterTableType::try_from(self.subtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.subtype)))?;
            struct_ser.serialize_field("subtype", &v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if self.num != 0 {
            struct_ser.serialize_field("num", &self.num)?;
        }
        if let Some(v) = self.newowner.as_ref() {
            struct_ser.serialize_field("newowner", v)?;
        }
        if let Some(v) = self.def.as_ref() {
            struct_ser.serialize_field("def", v)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        if self.recurse {
            struct_ser.serialize_field("recurse", &self.recurse)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTableCmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subtype",
            "name",
            "num",
            "newowner",
            "def",
            "behavior",
            "missing_ok",
            "recurse",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Subtype,
            Name,
            Num,
            Newowner,
            Def,
            Behavior,
            MissingOk,
            Recurse,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subtype" => Ok(GeneratedField::Subtype),
                            "name" => Ok(GeneratedField::Name),
                            "num" => Ok(GeneratedField::Num),
                            "newowner" => Ok(GeneratedField::Newowner),
                            "def" => Ok(GeneratedField::Def),
                            "behavior" => Ok(GeneratedField::Behavior),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            "recurse" => Ok(GeneratedField::Recurse),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTableCmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTableCmd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTableCmd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subtype__ = None;
                let mut name__ = None;
                let mut num__ = None;
                let mut newowner__ = None;
                let mut def__ = None;
                let mut behavior__ = None;
                let mut missing_ok__ = None;
                let mut recurse__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Subtype => {
                            if subtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subtype"));
                            }
                            subtype__ = Some(map_.next_value::<AlterTableType>()? as i32);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Num => {
                            if num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("num"));
                            }
                            num__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Newowner => {
                            if newowner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newowner"));
                            }
                            newowner__ = map_.next_value()?;
                        }
                        GeneratedField::Def => {
                            if def__.is_some() {
                                return Err(serde::de::Error::duplicate_field("def"));
                            }
                            def__ = map_.next_value()?;
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Recurse => {
                            if recurse__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recurse"));
                            }
                            recurse__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTableCmd {
                    subtype: subtype__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    num: num__.unwrap_or_default(),
                    newowner: newowner__,
                    def: def__,
                    behavior: behavior__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                    recurse: recurse__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTableCmd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTableMoveAllStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orig_tablespacename.is_empty() {
            len += 1;
        }
        if self.objtype != 0 {
            len += 1;
        }
        if !self.roles.is_empty() {
            len += 1;
        }
        if !self.new_tablespacename.is_empty() {
            len += 1;
        }
        if self.nowait {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTableMoveAllStmt", len)?;
        if !self.orig_tablespacename.is_empty() {
            struct_ser.serialize_field("orig_tablespacename", &self.orig_tablespacename)?;
        }
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if !self.new_tablespacename.is_empty() {
            struct_ser.serialize_field("new_tablespacename", &self.new_tablespacename)?;
        }
        if self.nowait {
            struct_ser.serialize_field("nowait", &self.nowait)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTableMoveAllStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "orig_tablespacename",
            "objtype",
            "roles",
            "new_tablespacename",
            "nowait",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrigTablespacename,
            Objtype,
            Roles,
            NewTablespacename,
            Nowait,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orig_tablespacename" => Ok(GeneratedField::OrigTablespacename),
                            "objtype" => Ok(GeneratedField::Objtype),
                            "roles" => Ok(GeneratedField::Roles),
                            "new_tablespacename" => Ok(GeneratedField::NewTablespacename),
                            "nowait" => Ok(GeneratedField::Nowait),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTableMoveAllStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTableMoveAllStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTableMoveAllStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut orig_tablespacename__ = None;
                let mut objtype__ = None;
                let mut roles__ = None;
                let mut new_tablespacename__ = None;
                let mut nowait__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrigTablespacename => {
                            if orig_tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orig_tablespacename"));
                            }
                            orig_tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewTablespacename => {
                            if new_tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("new_tablespacename"));
                            }
                            new_tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Nowait => {
                            if nowait__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nowait"));
                            }
                            nowait__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTableMoveAllStmt {
                    orig_tablespacename: orig_tablespacename__.unwrap_or_default(),
                    objtype: objtype__.unwrap_or_default(),
                    roles: roles__.unwrap_or_default(),
                    new_tablespacename: new_tablespacename__.unwrap_or_default(),
                    nowait: nowait__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTableMoveAllStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTableSpaceOptionsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.tablespacename.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.is_reset {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTableSpaceOptionsStmt", len)?;
        if !self.tablespacename.is_empty() {
            struct_ser.serialize_field("tablespacename", &self.tablespacename)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.is_reset {
            struct_ser.serialize_field("isReset", &self.is_reset)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTableSpaceOptionsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tablespacename",
            "options",
            "is_reset",
            "isReset",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tablespacename,
            Options,
            IsReset,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tablespacename" => Ok(GeneratedField::Tablespacename),
                            "options" => Ok(GeneratedField::Options),
                            "isReset" | "is_reset" => Ok(GeneratedField::IsReset),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTableSpaceOptionsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTableSpaceOptionsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTableSpaceOptionsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tablespacename__ = None;
                let mut options__ = None;
                let mut is_reset__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tablespacename => {
                            if tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablespacename"));
                            }
                            tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsReset => {
                            if is_reset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isReset"));
                            }
                            is_reset__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTableSpaceOptionsStmt {
                    tablespacename: tablespacename__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    is_reset: is_reset__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTableSpaceOptionsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTableStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.cmds.is_empty() {
            len += 1;
        }
        if self.objtype != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTableStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.cmds.is_empty() {
            struct_ser.serialize_field("cmds", &self.cmds)?;
        }
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTableStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "cmds",
            "objtype",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Cmds,
            Objtype,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "cmds" => Ok(GeneratedField::Cmds),
                            "objtype" => Ok(GeneratedField::Objtype),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTableStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTableStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTableStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut cmds__ = None;
                let mut objtype__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Cmds => {
                            if cmds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmds"));
                            }
                            cmds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTableStmt {
                    relation: relation__,
                    cmds: cmds__.unwrap_or_default(),
                    objtype: objtype__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTableStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTableType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ALTER_TABLE_TYPE_UNDEFINED",
            Self::AtAddColumn => "AT_AddColumn",
            Self::AtAddColumnToView => "AT_AddColumnToView",
            Self::AtColumnDefault => "AT_ColumnDefault",
            Self::AtCookedColumnDefault => "AT_CookedColumnDefault",
            Self::AtDropNotNull => "AT_DropNotNull",
            Self::AtSetNotNull => "AT_SetNotNull",
            Self::AtDropExpression => "AT_DropExpression",
            Self::AtCheckNotNull => "AT_CheckNotNull",
            Self::AtSetStatistics => "AT_SetStatistics",
            Self::AtSetOptions => "AT_SetOptions",
            Self::AtResetOptions => "AT_ResetOptions",
            Self::AtSetStorage => "AT_SetStorage",
            Self::AtSetCompression => "AT_SetCompression",
            Self::AtDropColumn => "AT_DropColumn",
            Self::AtAddIndex => "AT_AddIndex",
            Self::AtReAddIndex => "AT_ReAddIndex",
            Self::AtAddConstraint => "AT_AddConstraint",
            Self::AtReAddConstraint => "AT_ReAddConstraint",
            Self::AtReAddDomainConstraint => "AT_ReAddDomainConstraint",
            Self::AtAlterConstraint => "AT_AlterConstraint",
            Self::AtValidateConstraint => "AT_ValidateConstraint",
            Self::AtAddIndexConstraint => "AT_AddIndexConstraint",
            Self::AtDropConstraint => "AT_DropConstraint",
            Self::AtReAddComment => "AT_ReAddComment",
            Self::AtAlterColumnType => "AT_AlterColumnType",
            Self::AtAlterColumnGenericOptions => "AT_AlterColumnGenericOptions",
            Self::AtChangeOwner => "AT_ChangeOwner",
            Self::AtClusterOn => "AT_ClusterOn",
            Self::AtDropCluster => "AT_DropCluster",
            Self::AtSetLogged => "AT_SetLogged",
            Self::AtSetUnLogged => "AT_SetUnLogged",
            Self::AtDropOids => "AT_DropOids",
            Self::AtSetAccessMethod => "AT_SetAccessMethod",
            Self::AtSetTableSpace => "AT_SetTableSpace",
            Self::AtSetRelOptions => "AT_SetRelOptions",
            Self::AtResetRelOptions => "AT_ResetRelOptions",
            Self::AtReplaceRelOptions => "AT_ReplaceRelOptions",
            Self::AtEnableTrig => "AT_EnableTrig",
            Self::AtEnableAlwaysTrig => "AT_EnableAlwaysTrig",
            Self::AtEnableReplicaTrig => "AT_EnableReplicaTrig",
            Self::AtDisableTrig => "AT_DisableTrig",
            Self::AtEnableTrigAll => "AT_EnableTrigAll",
            Self::AtDisableTrigAll => "AT_DisableTrigAll",
            Self::AtEnableTrigUser => "AT_EnableTrigUser",
            Self::AtDisableTrigUser => "AT_DisableTrigUser",
            Self::AtEnableRule => "AT_EnableRule",
            Self::AtEnableAlwaysRule => "AT_EnableAlwaysRule",
            Self::AtEnableReplicaRule => "AT_EnableReplicaRule",
            Self::AtDisableRule => "AT_DisableRule",
            Self::AtAddInherit => "AT_AddInherit",
            Self::AtDropInherit => "AT_DropInherit",
            Self::AtAddOf => "AT_AddOf",
            Self::AtDropOf => "AT_DropOf",
            Self::AtReplicaIdentity => "AT_ReplicaIdentity",
            Self::AtEnableRowSecurity => "AT_EnableRowSecurity",
            Self::AtDisableRowSecurity => "AT_DisableRowSecurity",
            Self::AtForceRowSecurity => "AT_ForceRowSecurity",
            Self::AtNoForceRowSecurity => "AT_NoForceRowSecurity",
            Self::AtGenericOptions => "AT_GenericOptions",
            Self::AtAttachPartition => "AT_AttachPartition",
            Self::AtDetachPartition => "AT_DetachPartition",
            Self::AtDetachPartitionFinalize => "AT_DetachPartitionFinalize",
            Self::AtAddIdentity => "AT_AddIdentity",
            Self::AtSetIdentity => "AT_SetIdentity",
            Self::AtDropIdentity => "AT_DropIdentity",
            Self::AtReAddStatistics => "AT_ReAddStatistics",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlterTableType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALTER_TABLE_TYPE_UNDEFINED",
            "AT_AddColumn",
            "AT_AddColumnToView",
            "AT_ColumnDefault",
            "AT_CookedColumnDefault",
            "AT_DropNotNull",
            "AT_SetNotNull",
            "AT_DropExpression",
            "AT_CheckNotNull",
            "AT_SetStatistics",
            "AT_SetOptions",
            "AT_ResetOptions",
            "AT_SetStorage",
            "AT_SetCompression",
            "AT_DropColumn",
            "AT_AddIndex",
            "AT_ReAddIndex",
            "AT_AddConstraint",
            "AT_ReAddConstraint",
            "AT_ReAddDomainConstraint",
            "AT_AlterConstraint",
            "AT_ValidateConstraint",
            "AT_AddIndexConstraint",
            "AT_DropConstraint",
            "AT_ReAddComment",
            "AT_AlterColumnType",
            "AT_AlterColumnGenericOptions",
            "AT_ChangeOwner",
            "AT_ClusterOn",
            "AT_DropCluster",
            "AT_SetLogged",
            "AT_SetUnLogged",
            "AT_DropOids",
            "AT_SetAccessMethod",
            "AT_SetTableSpace",
            "AT_SetRelOptions",
            "AT_ResetRelOptions",
            "AT_ReplaceRelOptions",
            "AT_EnableTrig",
            "AT_EnableAlwaysTrig",
            "AT_EnableReplicaTrig",
            "AT_DisableTrig",
            "AT_EnableTrigAll",
            "AT_DisableTrigAll",
            "AT_EnableTrigUser",
            "AT_DisableTrigUser",
            "AT_EnableRule",
            "AT_EnableAlwaysRule",
            "AT_EnableReplicaRule",
            "AT_DisableRule",
            "AT_AddInherit",
            "AT_DropInherit",
            "AT_AddOf",
            "AT_DropOf",
            "AT_ReplicaIdentity",
            "AT_EnableRowSecurity",
            "AT_DisableRowSecurity",
            "AT_ForceRowSecurity",
            "AT_NoForceRowSecurity",
            "AT_GenericOptions",
            "AT_AttachPartition",
            "AT_DetachPartition",
            "AT_DetachPartitionFinalize",
            "AT_AddIdentity",
            "AT_SetIdentity",
            "AT_DropIdentity",
            "AT_ReAddStatistics",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTableType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALTER_TABLE_TYPE_UNDEFINED" => Ok(AlterTableType::Undefined),
                    "AT_AddColumn" => Ok(AlterTableType::AtAddColumn),
                    "AT_AddColumnToView" => Ok(AlterTableType::AtAddColumnToView),
                    "AT_ColumnDefault" => Ok(AlterTableType::AtColumnDefault),
                    "AT_CookedColumnDefault" => Ok(AlterTableType::AtCookedColumnDefault),
                    "AT_DropNotNull" => Ok(AlterTableType::AtDropNotNull),
                    "AT_SetNotNull" => Ok(AlterTableType::AtSetNotNull),
                    "AT_DropExpression" => Ok(AlterTableType::AtDropExpression),
                    "AT_CheckNotNull" => Ok(AlterTableType::AtCheckNotNull),
                    "AT_SetStatistics" => Ok(AlterTableType::AtSetStatistics),
                    "AT_SetOptions" => Ok(AlterTableType::AtSetOptions),
                    "AT_ResetOptions" => Ok(AlterTableType::AtResetOptions),
                    "AT_SetStorage" => Ok(AlterTableType::AtSetStorage),
                    "AT_SetCompression" => Ok(AlterTableType::AtSetCompression),
                    "AT_DropColumn" => Ok(AlterTableType::AtDropColumn),
                    "AT_AddIndex" => Ok(AlterTableType::AtAddIndex),
                    "AT_ReAddIndex" => Ok(AlterTableType::AtReAddIndex),
                    "AT_AddConstraint" => Ok(AlterTableType::AtAddConstraint),
                    "AT_ReAddConstraint" => Ok(AlterTableType::AtReAddConstraint),
                    "AT_ReAddDomainConstraint" => Ok(AlterTableType::AtReAddDomainConstraint),
                    "AT_AlterConstraint" => Ok(AlterTableType::AtAlterConstraint),
                    "AT_ValidateConstraint" => Ok(AlterTableType::AtValidateConstraint),
                    "AT_AddIndexConstraint" => Ok(AlterTableType::AtAddIndexConstraint),
                    "AT_DropConstraint" => Ok(AlterTableType::AtDropConstraint),
                    "AT_ReAddComment" => Ok(AlterTableType::AtReAddComment),
                    "AT_AlterColumnType" => Ok(AlterTableType::AtAlterColumnType),
                    "AT_AlterColumnGenericOptions" => Ok(AlterTableType::AtAlterColumnGenericOptions),
                    "AT_ChangeOwner" => Ok(AlterTableType::AtChangeOwner),
                    "AT_ClusterOn" => Ok(AlterTableType::AtClusterOn),
                    "AT_DropCluster" => Ok(AlterTableType::AtDropCluster),
                    "AT_SetLogged" => Ok(AlterTableType::AtSetLogged),
                    "AT_SetUnLogged" => Ok(AlterTableType::AtSetUnLogged),
                    "AT_DropOids" => Ok(AlterTableType::AtDropOids),
                    "AT_SetAccessMethod" => Ok(AlterTableType::AtSetAccessMethod),
                    "AT_SetTableSpace" => Ok(AlterTableType::AtSetTableSpace),
                    "AT_SetRelOptions" => Ok(AlterTableType::AtSetRelOptions),
                    "AT_ResetRelOptions" => Ok(AlterTableType::AtResetRelOptions),
                    "AT_ReplaceRelOptions" => Ok(AlterTableType::AtReplaceRelOptions),
                    "AT_EnableTrig" => Ok(AlterTableType::AtEnableTrig),
                    "AT_EnableAlwaysTrig" => Ok(AlterTableType::AtEnableAlwaysTrig),
                    "AT_EnableReplicaTrig" => Ok(AlterTableType::AtEnableReplicaTrig),
                    "AT_DisableTrig" => Ok(AlterTableType::AtDisableTrig),
                    "AT_EnableTrigAll" => Ok(AlterTableType::AtEnableTrigAll),
                    "AT_DisableTrigAll" => Ok(AlterTableType::AtDisableTrigAll),
                    "AT_EnableTrigUser" => Ok(AlterTableType::AtEnableTrigUser),
                    "AT_DisableTrigUser" => Ok(AlterTableType::AtDisableTrigUser),
                    "AT_EnableRule" => Ok(AlterTableType::AtEnableRule),
                    "AT_EnableAlwaysRule" => Ok(AlterTableType::AtEnableAlwaysRule),
                    "AT_EnableReplicaRule" => Ok(AlterTableType::AtEnableReplicaRule),
                    "AT_DisableRule" => Ok(AlterTableType::AtDisableRule),
                    "AT_AddInherit" => Ok(AlterTableType::AtAddInherit),
                    "AT_DropInherit" => Ok(AlterTableType::AtDropInherit),
                    "AT_AddOf" => Ok(AlterTableType::AtAddOf),
                    "AT_DropOf" => Ok(AlterTableType::AtDropOf),
                    "AT_ReplicaIdentity" => Ok(AlterTableType::AtReplicaIdentity),
                    "AT_EnableRowSecurity" => Ok(AlterTableType::AtEnableRowSecurity),
                    "AT_DisableRowSecurity" => Ok(AlterTableType::AtDisableRowSecurity),
                    "AT_ForceRowSecurity" => Ok(AlterTableType::AtForceRowSecurity),
                    "AT_NoForceRowSecurity" => Ok(AlterTableType::AtNoForceRowSecurity),
                    "AT_GenericOptions" => Ok(AlterTableType::AtGenericOptions),
                    "AT_AttachPartition" => Ok(AlterTableType::AtAttachPartition),
                    "AT_DetachPartition" => Ok(AlterTableType::AtDetachPartition),
                    "AT_DetachPartitionFinalize" => Ok(AlterTableType::AtDetachPartitionFinalize),
                    "AT_AddIdentity" => Ok(AlterTableType::AtAddIdentity),
                    "AT_SetIdentity" => Ok(AlterTableType::AtSetIdentity),
                    "AT_DropIdentity" => Ok(AlterTableType::AtDropIdentity),
                    "AT_ReAddStatistics" => Ok(AlterTableType::AtReAddStatistics),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlterTypeStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.type_name.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterTypeStmt", len)?;
        if !self.type_name.is_empty() {
            struct_ser.serialize_field("typeName", &self.type_name)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterTypeStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterTypeStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterTypeStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterTypeStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterTypeStmt {
                    type_name: type_name__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterTypeStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlterUserMappingStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.user.is_some() {
            len += 1;
        }
        if !self.servername.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlterUserMappingStmt", len)?;
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlterUserMappingStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user",
            "servername",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            User,
            Servername,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "user" => Ok(GeneratedField::User),
                            "servername" => Ok(GeneratedField::Servername),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlterUserMappingStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlterUserMappingStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlterUserMappingStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user__ = None;
                let mut servername__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map_.next_value()?;
                        }
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlterUserMappingStmt {
                    user: user__,
                    servername: servername__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlterUserMappingStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlternativeSubPlan {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if !self.subplans.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.AlternativeSubPlan", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if !self.subplans.is_empty() {
            struct_ser.serialize_field("subplans", &self.subplans)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlternativeSubPlan {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "subplans",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Subplans,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "subplans" => Ok(GeneratedField::Subplans),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlternativeSubPlan;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.AlternativeSubPlan")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlternativeSubPlan, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut subplans__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Subplans => {
                            if subplans__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subplans"));
                            }
                            subplans__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlternativeSubPlan {
                    xpr: xpr__,
                    subplans: subplans__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.AlternativeSubPlan", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ArrayCoerceExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.elemexpr.is_some() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.resulttypmod != 0 {
            len += 1;
        }
        if self.resultcollid != 0 {
            len += 1;
        }
        if self.coerceformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ArrayCoerceExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if let Some(v) = self.elemexpr.as_ref() {
            struct_ser.serialize_field("elemexpr", v)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.resulttypmod != 0 {
            struct_ser.serialize_field("resulttypmod", &self.resulttypmod)?;
        }
        if self.resultcollid != 0 {
            struct_ser.serialize_field("resultcollid", &self.resultcollid)?;
        }
        if self.coerceformat != 0 {
            let v = CoercionForm::try_from(self.coerceformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.coerceformat)))?;
            struct_ser.serialize_field("coerceformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ArrayCoerceExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "elemexpr",
            "resulttype",
            "resulttypmod",
            "resultcollid",
            "coerceformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Elemexpr,
            Resulttype,
            Resulttypmod,
            Resultcollid,
            Coerceformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "elemexpr" => Ok(GeneratedField::Elemexpr),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "resulttypmod" => Ok(GeneratedField::Resulttypmod),
                            "resultcollid" => Ok(GeneratedField::Resultcollid),
                            "coerceformat" => Ok(GeneratedField::Coerceformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ArrayCoerceExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ArrayCoerceExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ArrayCoerceExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut elemexpr__ = None;
                let mut resulttype__ = None;
                let mut resulttypmod__ = None;
                let mut resultcollid__ = None;
                let mut coerceformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Elemexpr => {
                            if elemexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elemexpr"));
                            }
                            elemexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resulttypmod => {
                            if resulttypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttypmod"));
                            }
                            resulttypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resultcollid => {
                            if resultcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultcollid"));
                            }
                            resultcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Coerceformat => {
                            if coerceformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coerceformat"));
                            }
                            coerceformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ArrayCoerceExpr {
                    xpr: xpr__,
                    arg: arg__,
                    elemexpr: elemexpr__,
                    resulttype: resulttype__.unwrap_or_default(),
                    resulttypmod: resulttypmod__.unwrap_or_default(),
                    resultcollid: resultcollid__.unwrap_or_default(),
                    coerceformat: coerceformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ArrayCoerceExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ArrayExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.array_typeid != 0 {
            len += 1;
        }
        if self.array_collid != 0 {
            len += 1;
        }
        if self.element_typeid != 0 {
            len += 1;
        }
        if !self.elements.is_empty() {
            len += 1;
        }
        if self.multidims {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ArrayExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.array_typeid != 0 {
            struct_ser.serialize_field("array_typeid", &self.array_typeid)?;
        }
        if self.array_collid != 0 {
            struct_ser.serialize_field("array_collid", &self.array_collid)?;
        }
        if self.element_typeid != 0 {
            struct_ser.serialize_field("element_typeid", &self.element_typeid)?;
        }
        if !self.elements.is_empty() {
            struct_ser.serialize_field("elements", &self.elements)?;
        }
        if self.multidims {
            struct_ser.serialize_field("multidims", &self.multidims)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ArrayExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "array_typeid",
            "array_collid",
            "element_typeid",
            "elements",
            "multidims",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            ArrayTypeid,
            ArrayCollid,
            ElementTypeid,
            Elements,
            Multidims,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "array_typeid" => Ok(GeneratedField::ArrayTypeid),
                            "array_collid" => Ok(GeneratedField::ArrayCollid),
                            "element_typeid" => Ok(GeneratedField::ElementTypeid),
                            "elements" => Ok(GeneratedField::Elements),
                            "multidims" => Ok(GeneratedField::Multidims),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ArrayExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ArrayExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ArrayExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut array_typeid__ = None;
                let mut array_collid__ = None;
                let mut element_typeid__ = None;
                let mut elements__ = None;
                let mut multidims__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::ArrayTypeid => {
                            if array_typeid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("array_typeid"));
                            }
                            array_typeid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ArrayCollid => {
                            if array_collid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("array_collid"));
                            }
                            array_collid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ElementTypeid => {
                            if element_typeid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("element_typeid"));
                            }
                            element_typeid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Elements => {
                            if elements__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elements"));
                            }
                            elements__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Multidims => {
                            if multidims__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multidims"));
                            }
                            multidims__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ArrayExpr {
                    xpr: xpr__,
                    array_typeid: array_typeid__.unwrap_or_default(),
                    array_collid: array_collid__.unwrap_or_default(),
                    element_typeid: element_typeid__.unwrap_or_default(),
                    elements: elements__.unwrap_or_default(),
                    multidims: multidims__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ArrayExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BitString {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.bsval.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.BitString", len)?;
        if !self.bsval.is_empty() {
            struct_ser.serialize_field("bsval", &self.bsval)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BitString {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bsval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bsval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bsval" => Ok(GeneratedField::Bsval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BitString;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.BitString")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BitString, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bsval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bsval => {
                            if bsval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bsval"));
                            }
                            bsval__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BitString {
                    bsval: bsval__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.BitString", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BoolExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.boolop != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.BoolExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.boolop != 0 {
            let v = BoolExprType::try_from(self.boolop)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.boolop)))?;
            struct_ser.serialize_field("boolop", &v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BoolExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "boolop",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Boolop,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "boolop" => Ok(GeneratedField::Boolop),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BoolExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.BoolExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BoolExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut boolop__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Boolop => {
                            if boolop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boolop"));
                            }
                            boolop__ = Some(map_.next_value::<BoolExprType>()? as i32);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BoolExpr {
                    xpr: xpr__,
                    boolop: boolop__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.BoolExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BoolExprType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "BOOL_EXPR_TYPE_UNDEFINED",
            Self::AndExpr => "AND_EXPR",
            Self::OrExpr => "OR_EXPR",
            Self::NotExpr => "NOT_EXPR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for BoolExprType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BOOL_EXPR_TYPE_UNDEFINED",
            "AND_EXPR",
            "OR_EXPR",
            "NOT_EXPR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BoolExprType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BOOL_EXPR_TYPE_UNDEFINED" => Ok(BoolExprType::Undefined),
                    "AND_EXPR" => Ok(BoolExprType::AndExpr),
                    "OR_EXPR" => Ok(BoolExprType::OrExpr),
                    "NOT_EXPR" => Ok(BoolExprType::NotExpr),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BoolTestType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "BOOL_TEST_TYPE_UNDEFINED",
            Self::IsTrue => "IS_TRUE",
            Self::IsNotTrue => "IS_NOT_TRUE",
            Self::IsFalse => "IS_FALSE",
            Self::IsNotFalse => "IS_NOT_FALSE",
            Self::IsUnknown => "IS_UNKNOWN",
            Self::IsNotUnknown => "IS_NOT_UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for BoolTestType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BOOL_TEST_TYPE_UNDEFINED",
            "IS_TRUE",
            "IS_NOT_TRUE",
            "IS_FALSE",
            "IS_NOT_FALSE",
            "IS_UNKNOWN",
            "IS_NOT_UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BoolTestType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BOOL_TEST_TYPE_UNDEFINED" => Ok(BoolTestType::Undefined),
                    "IS_TRUE" => Ok(BoolTestType::IsTrue),
                    "IS_NOT_TRUE" => Ok(BoolTestType::IsNotTrue),
                    "IS_FALSE" => Ok(BoolTestType::IsFalse),
                    "IS_NOT_FALSE" => Ok(BoolTestType::IsNotFalse),
                    "IS_UNKNOWN" => Ok(BoolTestType::IsUnknown),
                    "IS_NOT_UNKNOWN" => Ok(BoolTestType::IsNotUnknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Boolean {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.boolval {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Boolean", len)?;
        if self.boolval {
            struct_ser.serialize_field("boolval", &self.boolval)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Boolean {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "boolval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Boolval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "boolval" => Ok(GeneratedField::Boolval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Boolean;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Boolean")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Boolean, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut boolval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Boolval => {
                            if boolval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boolval"));
                            }
                            boolval__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Boolean {
                    boolval: boolval__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Boolean", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BooleanTest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.booltesttype != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.BooleanTest", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.booltesttype != 0 {
            let v = BoolTestType::try_from(self.booltesttype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.booltesttype)))?;
            struct_ser.serialize_field("booltesttype", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BooleanTest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "booltesttype",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Booltesttype,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "booltesttype" => Ok(GeneratedField::Booltesttype),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BooleanTest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.BooleanTest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BooleanTest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut booltesttype__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Booltesttype => {
                            if booltesttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("booltesttype"));
                            }
                            booltesttype__ = Some(map_.next_value::<BoolTestType>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BooleanTest {
                    xpr: xpr__,
                    arg: arg__,
                    booltesttype: booltesttype__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.BooleanTest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CteCycleClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.cycle_col_list.is_empty() {
            len += 1;
        }
        if !self.cycle_mark_column.is_empty() {
            len += 1;
        }
        if self.cycle_mark_value.is_some() {
            len += 1;
        }
        if self.cycle_mark_default.is_some() {
            len += 1;
        }
        if !self.cycle_path_column.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        if self.cycle_mark_type != 0 {
            len += 1;
        }
        if self.cycle_mark_typmod != 0 {
            len += 1;
        }
        if self.cycle_mark_collation != 0 {
            len += 1;
        }
        if self.cycle_mark_neop != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CTECycleClause", len)?;
        if !self.cycle_col_list.is_empty() {
            struct_ser.serialize_field("cycle_col_list", &self.cycle_col_list)?;
        }
        if !self.cycle_mark_column.is_empty() {
            struct_ser.serialize_field("cycle_mark_column", &self.cycle_mark_column)?;
        }
        if let Some(v) = self.cycle_mark_value.as_ref() {
            struct_ser.serialize_field("cycle_mark_value", v)?;
        }
        if let Some(v) = self.cycle_mark_default.as_ref() {
            struct_ser.serialize_field("cycle_mark_default", v)?;
        }
        if !self.cycle_path_column.is_empty() {
            struct_ser.serialize_field("cycle_path_column", &self.cycle_path_column)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        if self.cycle_mark_type != 0 {
            struct_ser.serialize_field("cycle_mark_type", &self.cycle_mark_type)?;
        }
        if self.cycle_mark_typmod != 0 {
            struct_ser.serialize_field("cycle_mark_typmod", &self.cycle_mark_typmod)?;
        }
        if self.cycle_mark_collation != 0 {
            struct_ser.serialize_field("cycle_mark_collation", &self.cycle_mark_collation)?;
        }
        if self.cycle_mark_neop != 0 {
            struct_ser.serialize_field("cycle_mark_neop", &self.cycle_mark_neop)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CteCycleClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cycle_col_list",
            "cycle_mark_column",
            "cycle_mark_value",
            "cycle_mark_default",
            "cycle_path_column",
            "location",
            "cycle_mark_type",
            "cycle_mark_typmod",
            "cycle_mark_collation",
            "cycle_mark_neop",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CycleColList,
            CycleMarkColumn,
            CycleMarkValue,
            CycleMarkDefault,
            CyclePathColumn,
            Location,
            CycleMarkType,
            CycleMarkTypmod,
            CycleMarkCollation,
            CycleMarkNeop,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cycle_col_list" => Ok(GeneratedField::CycleColList),
                            "cycle_mark_column" => Ok(GeneratedField::CycleMarkColumn),
                            "cycle_mark_value" => Ok(GeneratedField::CycleMarkValue),
                            "cycle_mark_default" => Ok(GeneratedField::CycleMarkDefault),
                            "cycle_path_column" => Ok(GeneratedField::CyclePathColumn),
                            "location" => Ok(GeneratedField::Location),
                            "cycle_mark_type" => Ok(GeneratedField::CycleMarkType),
                            "cycle_mark_typmod" => Ok(GeneratedField::CycleMarkTypmod),
                            "cycle_mark_collation" => Ok(GeneratedField::CycleMarkCollation),
                            "cycle_mark_neop" => Ok(GeneratedField::CycleMarkNeop),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CteCycleClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CTECycleClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CteCycleClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cycle_col_list__ = None;
                let mut cycle_mark_column__ = None;
                let mut cycle_mark_value__ = None;
                let mut cycle_mark_default__ = None;
                let mut cycle_path_column__ = None;
                let mut location__ = None;
                let mut cycle_mark_type__ = None;
                let mut cycle_mark_typmod__ = None;
                let mut cycle_mark_collation__ = None;
                let mut cycle_mark_neop__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CycleColList => {
                            if cycle_col_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_col_list"));
                            }
                            cycle_col_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CycleMarkColumn => {
                            if cycle_mark_column__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_column"));
                            }
                            cycle_mark_column__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CycleMarkValue => {
                            if cycle_mark_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_value"));
                            }
                            cycle_mark_value__ = map_.next_value()?;
                        }
                        GeneratedField::CycleMarkDefault => {
                            if cycle_mark_default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_default"));
                            }
                            cycle_mark_default__ = map_.next_value()?;
                        }
                        GeneratedField::CyclePathColumn => {
                            if cycle_path_column__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_path_column"));
                            }
                            cycle_path_column__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CycleMarkType => {
                            if cycle_mark_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_type"));
                            }
                            cycle_mark_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CycleMarkTypmod => {
                            if cycle_mark_typmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_typmod"));
                            }
                            cycle_mark_typmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CycleMarkCollation => {
                            if cycle_mark_collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_collation"));
                            }
                            cycle_mark_collation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CycleMarkNeop => {
                            if cycle_mark_neop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_mark_neop"));
                            }
                            cycle_mark_neop__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CteCycleClause {
                    cycle_col_list: cycle_col_list__.unwrap_or_default(),
                    cycle_mark_column: cycle_mark_column__.unwrap_or_default(),
                    cycle_mark_value: cycle_mark_value__,
                    cycle_mark_default: cycle_mark_default__,
                    cycle_path_column: cycle_path_column__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                    cycle_mark_type: cycle_mark_type__.unwrap_or_default(),
                    cycle_mark_typmod: cycle_mark_typmod__.unwrap_or_default(),
                    cycle_mark_collation: cycle_mark_collation__.unwrap_or_default(),
                    cycle_mark_neop: cycle_mark_neop__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CTECycleClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CteMaterialize {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::CtematerializeUndefined => "CTEMATERIALIZE_UNDEFINED",
            Self::Default => "CTEMaterializeDefault",
            Self::Always => "CTEMaterializeAlways",
            Self::Never => "CTEMaterializeNever",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CteMaterialize {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CTEMATERIALIZE_UNDEFINED",
            "CTEMaterializeDefault",
            "CTEMaterializeAlways",
            "CTEMaterializeNever",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CteMaterialize;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CTEMATERIALIZE_UNDEFINED" => Ok(CteMaterialize::CtematerializeUndefined),
                    "CTEMaterializeDefault" => Ok(CteMaterialize::Default),
                    "CTEMaterializeAlways" => Ok(CteMaterialize::Always),
                    "CTEMaterializeNever" => Ok(CteMaterialize::Never),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CteSearchClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.search_col_list.is_empty() {
            len += 1;
        }
        if self.search_breadth_first {
            len += 1;
        }
        if !self.search_seq_column.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CTESearchClause", len)?;
        if !self.search_col_list.is_empty() {
            struct_ser.serialize_field("search_col_list", &self.search_col_list)?;
        }
        if self.search_breadth_first {
            struct_ser.serialize_field("search_breadth_first", &self.search_breadth_first)?;
        }
        if !self.search_seq_column.is_empty() {
            struct_ser.serialize_field("search_seq_column", &self.search_seq_column)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CteSearchClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "search_col_list",
            "search_breadth_first",
            "search_seq_column",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SearchColList,
            SearchBreadthFirst,
            SearchSeqColumn,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "search_col_list" => Ok(GeneratedField::SearchColList),
                            "search_breadth_first" => Ok(GeneratedField::SearchBreadthFirst),
                            "search_seq_column" => Ok(GeneratedField::SearchSeqColumn),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CteSearchClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CTESearchClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CteSearchClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut search_col_list__ = None;
                let mut search_breadth_first__ = None;
                let mut search_seq_column__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SearchColList => {
                            if search_col_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("search_col_list"));
                            }
                            search_col_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SearchBreadthFirst => {
                            if search_breadth_first__.is_some() {
                                return Err(serde::de::Error::duplicate_field("search_breadth_first"));
                            }
                            search_breadth_first__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SearchSeqColumn => {
                            if search_seq_column__.is_some() {
                                return Err(serde::de::Error::duplicate_field("search_seq_column"));
                            }
                            search_seq_column__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CteSearchClause {
                    search_col_list: search_col_list__.unwrap_or_default(),
                    search_breadth_first: search_breadth_first__.unwrap_or_default(),
                    search_seq_column: search_seq_column__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CTESearchClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CallContext {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.atomic {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CallContext", len)?;
        if self.atomic {
            struct_ser.serialize_field("atomic", &self.atomic)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CallContext {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "atomic",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Atomic,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "atomic" => Ok(GeneratedField::Atomic),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CallContext;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CallContext")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CallContext, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut atomic__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Atomic => {
                            if atomic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("atomic"));
                            }
                            atomic__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CallContext {
                    atomic: atomic__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CallContext", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CallStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.funccall.is_some() {
            len += 1;
        }
        if self.funcexpr.is_some() {
            len += 1;
        }
        if !self.outargs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CallStmt", len)?;
        if let Some(v) = self.funccall.as_ref() {
            struct_ser.serialize_field("funccall", v)?;
        }
        if let Some(v) = self.funcexpr.as_ref() {
            struct_ser.serialize_field("funcexpr", v)?;
        }
        if !self.outargs.is_empty() {
            struct_ser.serialize_field("outargs", &self.outargs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CallStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "funccall",
            "funcexpr",
            "outargs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Funccall,
            Funcexpr,
            Outargs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "funccall" => Ok(GeneratedField::Funccall),
                            "funcexpr" => Ok(GeneratedField::Funcexpr),
                            "outargs" => Ok(GeneratedField::Outargs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CallStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CallStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CallStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut funccall__ = None;
                let mut funcexpr__ = None;
                let mut outargs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Funccall => {
                            if funccall__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccall"));
                            }
                            funccall__ = map_.next_value()?;
                        }
                        GeneratedField::Funcexpr => {
                            if funcexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcexpr"));
                            }
                            funcexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Outargs => {
                            if outargs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outargs"));
                            }
                            outargs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CallStmt {
                    funccall: funccall__,
                    funcexpr: funcexpr__,
                    outargs: outargs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CallStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CaseExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.casetype != 0 {
            len += 1;
        }
        if self.casecollid != 0 {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.defresult.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CaseExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.casetype != 0 {
            struct_ser.serialize_field("casetype", &self.casetype)?;
        }
        if self.casecollid != 0 {
            struct_ser.serialize_field("casecollid", &self.casecollid)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.defresult.as_ref() {
            struct_ser.serialize_field("defresult", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CaseExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "casetype",
            "casecollid",
            "arg",
            "args",
            "defresult",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Casetype,
            Casecollid,
            Arg,
            Args,
            Defresult,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "casetype" => Ok(GeneratedField::Casetype),
                            "casecollid" => Ok(GeneratedField::Casecollid),
                            "arg" => Ok(GeneratedField::Arg),
                            "args" => Ok(GeneratedField::Args),
                            "defresult" => Ok(GeneratedField::Defresult),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CaseExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CaseExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CaseExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut casetype__ = None;
                let mut casecollid__ = None;
                let mut arg__ = None;
                let mut args__ = None;
                let mut defresult__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Casetype => {
                            if casetype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("casetype"));
                            }
                            casetype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Casecollid => {
                            if casecollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("casecollid"));
                            }
                            casecollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Defresult => {
                            if defresult__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defresult"));
                            }
                            defresult__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CaseExpr {
                    xpr: xpr__,
                    casetype: casetype__.unwrap_or_default(),
                    casecollid: casecollid__.unwrap_or_default(),
                    arg: arg__,
                    args: args__.unwrap_or_default(),
                    defresult: defresult__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CaseExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CaseTestExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.type_id != 0 {
            len += 1;
        }
        if self.type_mod != 0 {
            len += 1;
        }
        if self.collation != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CaseTestExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.type_id != 0 {
            struct_ser.serialize_field("typeId", &self.type_id)?;
        }
        if self.type_mod != 0 {
            struct_ser.serialize_field("typeMod", &self.type_mod)?;
        }
        if self.collation != 0 {
            struct_ser.serialize_field("collation", &self.collation)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CaseTestExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "type_id",
            "typeId",
            "type_mod",
            "typeMod",
            "collation",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            TypeId,
            TypeMod,
            Collation,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "typeId" | "type_id" => Ok(GeneratedField::TypeId),
                            "typeMod" | "type_mod" => Ok(GeneratedField::TypeMod),
                            "collation" => Ok(GeneratedField::Collation),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CaseTestExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CaseTestExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CaseTestExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut type_id__ = None;
                let mut type_mod__ = None;
                let mut collation__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::TypeId => {
                            if type_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeId"));
                            }
                            type_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeMod => {
                            if type_mod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeMod"));
                            }
                            type_mod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Collation => {
                            if collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collation"));
                            }
                            collation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CaseTestExpr {
                    xpr: xpr__,
                    type_id: type_id__.unwrap_or_default(),
                    type_mod: type_mod__.unwrap_or_default(),
                    collation: collation__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CaseTestExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CaseWhen {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if self.result.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CaseWhen", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if let Some(v) = self.result.as_ref() {
            struct_ser.serialize_field("result", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CaseWhen {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "expr",
            "result",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Expr,
            Result,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "expr" => Ok(GeneratedField::Expr),
                            "result" => Ok(GeneratedField::Result),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CaseWhen;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CaseWhen")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CaseWhen, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut expr__ = None;
                let mut result__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CaseWhen {
                    xpr: xpr__,
                    expr: expr__,
                    result: result__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CaseWhen", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CheckPointStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("pg_query.CheckPointStmt", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CheckPointStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CheckPointStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CheckPointStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CheckPointStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(CheckPointStmt {
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CheckPointStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClosePortalStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.portalname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ClosePortalStmt", len)?;
        if !self.portalname.is_empty() {
            struct_ser.serialize_field("portalname", &self.portalname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClosePortalStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "portalname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Portalname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "portalname" => Ok(GeneratedField::Portalname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClosePortalStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ClosePortalStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClosePortalStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut portalname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Portalname => {
                            if portalname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portalname"));
                            }
                            portalname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ClosePortalStmt {
                    portalname: portalname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ClosePortalStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClusterStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.indexname.is_empty() {
            len += 1;
        }
        if !self.params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ClusterStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.indexname.is_empty() {
            struct_ser.serialize_field("indexname", &self.indexname)?;
        }
        if !self.params.is_empty() {
            struct_ser.serialize_field("params", &self.params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClusterStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "indexname",
            "params",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Indexname,
            Params,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "indexname" => Ok(GeneratedField::Indexname),
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClusterStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ClusterStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClusterStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut indexname__ = None;
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Indexname => {
                            if indexname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexname"));
                            }
                            indexname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ClusterStmt {
                    relation: relation__,
                    indexname: indexname__.unwrap_or_default(),
                    params: params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ClusterStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CmdType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "CMD_TYPE_UNDEFINED",
            Self::CmdUnknown => "CMD_UNKNOWN",
            Self::CmdSelect => "CMD_SELECT",
            Self::CmdUpdate => "CMD_UPDATE",
            Self::CmdInsert => "CMD_INSERT",
            Self::CmdDelete => "CMD_DELETE",
            Self::CmdMerge => "CMD_MERGE",
            Self::CmdUtility => "CMD_UTILITY",
            Self::CmdNothing => "CMD_NOTHING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CmdType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CMD_TYPE_UNDEFINED",
            "CMD_UNKNOWN",
            "CMD_SELECT",
            "CMD_UPDATE",
            "CMD_INSERT",
            "CMD_DELETE",
            "CMD_MERGE",
            "CMD_UTILITY",
            "CMD_NOTHING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CmdType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CMD_TYPE_UNDEFINED" => Ok(CmdType::Undefined),
                    "CMD_UNKNOWN" => Ok(CmdType::CmdUnknown),
                    "CMD_SELECT" => Ok(CmdType::CmdSelect),
                    "CMD_UPDATE" => Ok(CmdType::CmdUpdate),
                    "CMD_INSERT" => Ok(CmdType::CmdInsert),
                    "CMD_DELETE" => Ok(CmdType::CmdDelete),
                    "CMD_MERGE" => Ok(CmdType::CmdMerge),
                    "CMD_UTILITY" => Ok(CmdType::CmdUtility),
                    "CMD_NOTHING" => Ok(CmdType::CmdNothing),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CoalesceExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.coalescetype != 0 {
            len += 1;
        }
        if self.coalescecollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CoalesceExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.coalescetype != 0 {
            struct_ser.serialize_field("coalescetype", &self.coalescetype)?;
        }
        if self.coalescecollid != 0 {
            struct_ser.serialize_field("coalescecollid", &self.coalescecollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoalesceExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "coalescetype",
            "coalescecollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Coalescetype,
            Coalescecollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "coalescetype" => Ok(GeneratedField::Coalescetype),
                            "coalescecollid" => Ok(GeneratedField::Coalescecollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoalesceExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CoalesceExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoalesceExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut coalescetype__ = None;
                let mut coalescecollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Coalescetype => {
                            if coalescetype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coalescetype"));
                            }
                            coalescetype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Coalescecollid => {
                            if coalescecollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coalescecollid"));
                            }
                            coalescecollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CoalesceExpr {
                    xpr: xpr__,
                    coalescetype: coalescetype__.unwrap_or_default(),
                    coalescecollid: coalescecollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CoalesceExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoerceToDomain {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.resulttypmod != 0 {
            len += 1;
        }
        if self.resultcollid != 0 {
            len += 1;
        }
        if self.coercionformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CoerceToDomain", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.resulttypmod != 0 {
            struct_ser.serialize_field("resulttypmod", &self.resulttypmod)?;
        }
        if self.resultcollid != 0 {
            struct_ser.serialize_field("resultcollid", &self.resultcollid)?;
        }
        if self.coercionformat != 0 {
            let v = CoercionForm::try_from(self.coercionformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.coercionformat)))?;
            struct_ser.serialize_field("coercionformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoerceToDomain {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "resulttype",
            "resulttypmod",
            "resultcollid",
            "coercionformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Resulttype,
            Resulttypmod,
            Resultcollid,
            Coercionformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "resulttypmod" => Ok(GeneratedField::Resulttypmod),
                            "resultcollid" => Ok(GeneratedField::Resultcollid),
                            "coercionformat" => Ok(GeneratedField::Coercionformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoerceToDomain;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CoerceToDomain")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoerceToDomain, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut resulttype__ = None;
                let mut resulttypmod__ = None;
                let mut resultcollid__ = None;
                let mut coercionformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resulttypmod => {
                            if resulttypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttypmod"));
                            }
                            resulttypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resultcollid => {
                            if resultcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultcollid"));
                            }
                            resultcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Coercionformat => {
                            if coercionformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coercionformat"));
                            }
                            coercionformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CoerceToDomain {
                    xpr: xpr__,
                    arg: arg__,
                    resulttype: resulttype__.unwrap_or_default(),
                    resulttypmod: resulttypmod__.unwrap_or_default(),
                    resultcollid: resultcollid__.unwrap_or_default(),
                    coercionformat: coercionformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CoerceToDomain", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoerceToDomainValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.type_id != 0 {
            len += 1;
        }
        if self.type_mod != 0 {
            len += 1;
        }
        if self.collation != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CoerceToDomainValue", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.type_id != 0 {
            struct_ser.serialize_field("typeId", &self.type_id)?;
        }
        if self.type_mod != 0 {
            struct_ser.serialize_field("typeMod", &self.type_mod)?;
        }
        if self.collation != 0 {
            struct_ser.serialize_field("collation", &self.collation)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoerceToDomainValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "type_id",
            "typeId",
            "type_mod",
            "typeMod",
            "collation",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            TypeId,
            TypeMod,
            Collation,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "typeId" | "type_id" => Ok(GeneratedField::TypeId),
                            "typeMod" | "type_mod" => Ok(GeneratedField::TypeMod),
                            "collation" => Ok(GeneratedField::Collation),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoerceToDomainValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CoerceToDomainValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoerceToDomainValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut type_id__ = None;
                let mut type_mod__ = None;
                let mut collation__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::TypeId => {
                            if type_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeId"));
                            }
                            type_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeMod => {
                            if type_mod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeMod"));
                            }
                            type_mod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Collation => {
                            if collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collation"));
                            }
                            collation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CoerceToDomainValue {
                    xpr: xpr__,
                    type_id: type_id__.unwrap_or_default(),
                    type_mod: type_mod__.unwrap_or_default(),
                    collation: collation__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CoerceToDomainValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoerceViaIo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.resultcollid != 0 {
            len += 1;
        }
        if self.coerceformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CoerceViaIO", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.resultcollid != 0 {
            struct_ser.serialize_field("resultcollid", &self.resultcollid)?;
        }
        if self.coerceformat != 0 {
            let v = CoercionForm::try_from(self.coerceformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.coerceformat)))?;
            struct_ser.serialize_field("coerceformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoerceViaIo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "resulttype",
            "resultcollid",
            "coerceformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Resulttype,
            Resultcollid,
            Coerceformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "resultcollid" => Ok(GeneratedField::Resultcollid),
                            "coerceformat" => Ok(GeneratedField::Coerceformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoerceViaIo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CoerceViaIO")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoerceViaIo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut resulttype__ = None;
                let mut resultcollid__ = None;
                let mut coerceformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resultcollid => {
                            if resultcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultcollid"));
                            }
                            resultcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Coerceformat => {
                            if coerceformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coerceformat"));
                            }
                            coerceformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CoerceViaIo {
                    xpr: xpr__,
                    arg: arg__,
                    resulttype: resulttype__.unwrap_or_default(),
                    resultcollid: resultcollid__.unwrap_or_default(),
                    coerceformat: coerceformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CoerceViaIO", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoercionContext {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "COERCION_CONTEXT_UNDEFINED",
            Self::CoercionImplicit => "COERCION_IMPLICIT",
            Self::CoercionAssignment => "COERCION_ASSIGNMENT",
            Self::CoercionPlpgsql => "COERCION_PLPGSQL",
            Self::CoercionExplicit => "COERCION_EXPLICIT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CoercionContext {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COERCION_CONTEXT_UNDEFINED",
            "COERCION_IMPLICIT",
            "COERCION_ASSIGNMENT",
            "COERCION_PLPGSQL",
            "COERCION_EXPLICIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoercionContext;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COERCION_CONTEXT_UNDEFINED" => Ok(CoercionContext::Undefined),
                    "COERCION_IMPLICIT" => Ok(CoercionContext::CoercionImplicit),
                    "COERCION_ASSIGNMENT" => Ok(CoercionContext::CoercionAssignment),
                    "COERCION_PLPGSQL" => Ok(CoercionContext::CoercionPlpgsql),
                    "COERCION_EXPLICIT" => Ok(CoercionContext::CoercionExplicit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CoercionForm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "COERCION_FORM_UNDEFINED",
            Self::CoerceExplicitCall => "COERCE_EXPLICIT_CALL",
            Self::CoerceExplicitCast => "COERCE_EXPLICIT_CAST",
            Self::CoerceImplicitCast => "COERCE_IMPLICIT_CAST",
            Self::CoerceSqlSyntax => "COERCE_SQL_SYNTAX",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CoercionForm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COERCION_FORM_UNDEFINED",
            "COERCE_EXPLICIT_CALL",
            "COERCE_EXPLICIT_CAST",
            "COERCE_IMPLICIT_CAST",
            "COERCE_SQL_SYNTAX",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoercionForm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COERCION_FORM_UNDEFINED" => Ok(CoercionForm::Undefined),
                    "COERCE_EXPLICIT_CALL" => Ok(CoercionForm::CoerceExplicitCall),
                    "COERCE_EXPLICIT_CAST" => Ok(CoercionForm::CoerceExplicitCast),
                    "COERCE_IMPLICIT_CAST" => Ok(CoercionForm::CoerceImplicitCast),
                    "COERCE_SQL_SYNTAX" => Ok(CoercionForm::CoerceSqlSyntax),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CollateClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.arg.is_some() {
            len += 1;
        }
        if !self.collname.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CollateClause", len)?;
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if !self.collname.is_empty() {
            struct_ser.serialize_field("collname", &self.collname)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CollateClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arg",
            "collname",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arg,
            Collname,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arg" => Ok(GeneratedField::Arg),
                            "collname" => Ok(GeneratedField::Collname),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CollateClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CollateClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CollateClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arg__ = None;
                let mut collname__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Collname => {
                            if collname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collname"));
                            }
                            collname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CollateClause {
                    arg: arg__,
                    collname: collname__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CollateClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CollateExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.coll_oid != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CollateExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.coll_oid != 0 {
            struct_ser.serialize_field("collOid", &self.coll_oid)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CollateExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "coll_oid",
            "collOid",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            CollOid,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "collOid" | "coll_oid" => Ok(GeneratedField::CollOid),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CollateExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CollateExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CollateExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut coll_oid__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::CollOid => {
                            if coll_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collOid"));
                            }
                            coll_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CollateExpr {
                    xpr: xpr__,
                    arg: arg__,
                    coll_oid: coll_oid__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CollateExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ColumnDef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.colname.is_empty() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if !self.compression.is_empty() {
            len += 1;
        }
        if self.inhcount != 0 {
            len += 1;
        }
        if self.is_local {
            len += 1;
        }
        if self.is_not_null {
            len += 1;
        }
        if self.is_from_type {
            len += 1;
        }
        if !self.storage.is_empty() {
            len += 1;
        }
        if !self.storage_name.is_empty() {
            len += 1;
        }
        if self.raw_default.is_some() {
            len += 1;
        }
        if self.cooked_default.is_some() {
            len += 1;
        }
        if !self.identity.is_empty() {
            len += 1;
        }
        if self.identity_sequence.is_some() {
            len += 1;
        }
        if !self.generated.is_empty() {
            len += 1;
        }
        if self.coll_clause.is_some() {
            len += 1;
        }
        if self.coll_oid != 0 {
            len += 1;
        }
        if !self.constraints.is_empty() {
            len += 1;
        }
        if !self.fdwoptions.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ColumnDef", len)?;
        if !self.colname.is_empty() {
            struct_ser.serialize_field("colname", &self.colname)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if !self.compression.is_empty() {
            struct_ser.serialize_field("compression", &self.compression)?;
        }
        if self.inhcount != 0 {
            struct_ser.serialize_field("inhcount", &self.inhcount)?;
        }
        if self.is_local {
            struct_ser.serialize_field("is_local", &self.is_local)?;
        }
        if self.is_not_null {
            struct_ser.serialize_field("is_not_null", &self.is_not_null)?;
        }
        if self.is_from_type {
            struct_ser.serialize_field("is_from_type", &self.is_from_type)?;
        }
        if !self.storage.is_empty() {
            struct_ser.serialize_field("storage", &self.storage)?;
        }
        if !self.storage_name.is_empty() {
            struct_ser.serialize_field("storage_name", &self.storage_name)?;
        }
        if let Some(v) = self.raw_default.as_ref() {
            struct_ser.serialize_field("raw_default", v)?;
        }
        if let Some(v) = self.cooked_default.as_ref() {
            struct_ser.serialize_field("cooked_default", v)?;
        }
        if !self.identity.is_empty() {
            struct_ser.serialize_field("identity", &self.identity)?;
        }
        if let Some(v) = self.identity_sequence.as_ref() {
            struct_ser.serialize_field("identitySequence", v)?;
        }
        if !self.generated.is_empty() {
            struct_ser.serialize_field("generated", &self.generated)?;
        }
        if let Some(v) = self.coll_clause.as_ref() {
            struct_ser.serialize_field("collClause", v)?;
        }
        if self.coll_oid != 0 {
            struct_ser.serialize_field("collOid", &self.coll_oid)?;
        }
        if !self.constraints.is_empty() {
            struct_ser.serialize_field("constraints", &self.constraints)?;
        }
        if !self.fdwoptions.is_empty() {
            struct_ser.serialize_field("fdwoptions", &self.fdwoptions)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ColumnDef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "colname",
            "type_name",
            "typeName",
            "compression",
            "inhcount",
            "is_local",
            "is_not_null",
            "is_from_type",
            "storage",
            "storage_name",
            "raw_default",
            "cooked_default",
            "identity",
            "identity_sequence",
            "identitySequence",
            "generated",
            "coll_clause",
            "collClause",
            "coll_oid",
            "collOid",
            "constraints",
            "fdwoptions",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Colname,
            TypeName,
            Compression,
            Inhcount,
            IsLocal,
            IsNotNull,
            IsFromType,
            Storage,
            StorageName,
            RawDefault,
            CookedDefault,
            Identity,
            IdentitySequence,
            Generated,
            CollClause,
            CollOid,
            Constraints,
            Fdwoptions,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "colname" => Ok(GeneratedField::Colname),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "compression" => Ok(GeneratedField::Compression),
                            "inhcount" => Ok(GeneratedField::Inhcount),
                            "is_local" => Ok(GeneratedField::IsLocal),
                            "is_not_null" => Ok(GeneratedField::IsNotNull),
                            "is_from_type" => Ok(GeneratedField::IsFromType),
                            "storage" => Ok(GeneratedField::Storage),
                            "storage_name" => Ok(GeneratedField::StorageName),
                            "raw_default" => Ok(GeneratedField::RawDefault),
                            "cooked_default" => Ok(GeneratedField::CookedDefault),
                            "identity" => Ok(GeneratedField::Identity),
                            "identitySequence" | "identity_sequence" => Ok(GeneratedField::IdentitySequence),
                            "generated" => Ok(GeneratedField::Generated),
                            "collClause" | "coll_clause" => Ok(GeneratedField::CollClause),
                            "collOid" | "coll_oid" => Ok(GeneratedField::CollOid),
                            "constraints" => Ok(GeneratedField::Constraints),
                            "fdwoptions" => Ok(GeneratedField::Fdwoptions),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ColumnDef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ColumnDef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ColumnDef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut colname__ = None;
                let mut type_name__ = None;
                let mut compression__ = None;
                let mut inhcount__ = None;
                let mut is_local__ = None;
                let mut is_not_null__ = None;
                let mut is_from_type__ = None;
                let mut storage__ = None;
                let mut storage_name__ = None;
                let mut raw_default__ = None;
                let mut cooked_default__ = None;
                let mut identity__ = None;
                let mut identity_sequence__ = None;
                let mut generated__ = None;
                let mut coll_clause__ = None;
                let mut coll_oid__ = None;
                let mut constraints__ = None;
                let mut fdwoptions__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Colname => {
                            if colname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colname"));
                            }
                            colname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::Compression => {
                            if compression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("compression"));
                            }
                            compression__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Inhcount => {
                            if inhcount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inhcount"));
                            }
                            inhcount__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::IsLocal => {
                            if is_local__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_local"));
                            }
                            is_local__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsNotNull => {
                            if is_not_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_not_null"));
                            }
                            is_not_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsFromType => {
                            if is_from_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_from_type"));
                            }
                            is_from_type__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Storage => {
                            if storage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storage"));
                            }
                            storage__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StorageName => {
                            if storage_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storage_name"));
                            }
                            storage_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RawDefault => {
                            if raw_default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("raw_default"));
                            }
                            raw_default__ = map_.next_value()?;
                        }
                        GeneratedField::CookedDefault => {
                            if cooked_default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cooked_default"));
                            }
                            cooked_default__ = map_.next_value()?;
                        }
                        GeneratedField::Identity => {
                            if identity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("identity"));
                            }
                            identity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IdentitySequence => {
                            if identity_sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("identitySequence"));
                            }
                            identity_sequence__ = map_.next_value()?;
                        }
                        GeneratedField::Generated => {
                            if generated__.is_some() {
                                return Err(serde::de::Error::duplicate_field("generated"));
                            }
                            generated__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CollClause => {
                            if coll_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collClause"));
                            }
                            coll_clause__ = map_.next_value()?;
                        }
                        GeneratedField::CollOid => {
                            if coll_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collOid"));
                            }
                            coll_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Constraints => {
                            if constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraints"));
                            }
                            constraints__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fdwoptions => {
                            if fdwoptions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fdwoptions"));
                            }
                            fdwoptions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ColumnDef {
                    colname: colname__.unwrap_or_default(),
                    type_name: type_name__,
                    compression: compression__.unwrap_or_default(),
                    inhcount: inhcount__.unwrap_or_default(),
                    is_local: is_local__.unwrap_or_default(),
                    is_not_null: is_not_null__.unwrap_or_default(),
                    is_from_type: is_from_type__.unwrap_or_default(),
                    storage: storage__.unwrap_or_default(),
                    storage_name: storage_name__.unwrap_or_default(),
                    raw_default: raw_default__,
                    cooked_default: cooked_default__,
                    identity: identity__.unwrap_or_default(),
                    identity_sequence: identity_sequence__,
                    generated: generated__.unwrap_or_default(),
                    coll_clause: coll_clause__,
                    coll_oid: coll_oid__.unwrap_or_default(),
                    constraints: constraints__.unwrap_or_default(),
                    fdwoptions: fdwoptions__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ColumnDef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ColumnRef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fields.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ColumnRef", len)?;
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ColumnRef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fields",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fields,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fields" => Ok(GeneratedField::Fields),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ColumnRef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ColumnRef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ColumnRef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fields__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ColumnRef {
                    fields: fields__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ColumnRef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommentStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.objtype != 0 {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if !self.comment.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CommentStmt", len)?;
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if !self.comment.is_empty() {
            struct_ser.serialize_field("comment", &self.comment)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommentStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objtype",
            "object",
            "comment",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objtype,
            Object,
            Comment,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objtype" => Ok(GeneratedField::Objtype),
                            "object" => Ok(GeneratedField::Object),
                            "comment" => Ok(GeneratedField::Comment),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommentStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CommentStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommentStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objtype__ = None;
                let mut object__ = None;
                let mut comment__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Comment => {
                            if comment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("comment"));
                            }
                            comment__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CommentStmt {
                    objtype: objtype__.unwrap_or_default(),
                    object: object__,
                    comment: comment__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CommentStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommonTableExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ctename.is_empty() {
            len += 1;
        }
        if !self.aliascolnames.is_empty() {
            len += 1;
        }
        if self.ctematerialized != 0 {
            len += 1;
        }
        if self.ctequery.is_some() {
            len += 1;
        }
        if self.search_clause.is_some() {
            len += 1;
        }
        if self.cycle_clause.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        if self.cterecursive {
            len += 1;
        }
        if self.cterefcount != 0 {
            len += 1;
        }
        if !self.ctecolnames.is_empty() {
            len += 1;
        }
        if !self.ctecoltypes.is_empty() {
            len += 1;
        }
        if !self.ctecoltypmods.is_empty() {
            len += 1;
        }
        if !self.ctecolcollations.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CommonTableExpr", len)?;
        if !self.ctename.is_empty() {
            struct_ser.serialize_field("ctename", &self.ctename)?;
        }
        if !self.aliascolnames.is_empty() {
            struct_ser.serialize_field("aliascolnames", &self.aliascolnames)?;
        }
        if self.ctematerialized != 0 {
            let v = CteMaterialize::try_from(self.ctematerialized)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.ctematerialized)))?;
            struct_ser.serialize_field("ctematerialized", &v)?;
        }
        if let Some(v) = self.ctequery.as_ref() {
            struct_ser.serialize_field("ctequery", v)?;
        }
        if let Some(v) = self.search_clause.as_ref() {
            struct_ser.serialize_field("search_clause", v)?;
        }
        if let Some(v) = self.cycle_clause.as_ref() {
            struct_ser.serialize_field("cycle_clause", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        if self.cterecursive {
            struct_ser.serialize_field("cterecursive", &self.cterecursive)?;
        }
        if self.cterefcount != 0 {
            struct_ser.serialize_field("cterefcount", &self.cterefcount)?;
        }
        if !self.ctecolnames.is_empty() {
            struct_ser.serialize_field("ctecolnames", &self.ctecolnames)?;
        }
        if !self.ctecoltypes.is_empty() {
            struct_ser.serialize_field("ctecoltypes", &self.ctecoltypes)?;
        }
        if !self.ctecoltypmods.is_empty() {
            struct_ser.serialize_field("ctecoltypmods", &self.ctecoltypmods)?;
        }
        if !self.ctecolcollations.is_empty() {
            struct_ser.serialize_field("ctecolcollations", &self.ctecolcollations)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommonTableExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ctename",
            "aliascolnames",
            "ctematerialized",
            "ctequery",
            "search_clause",
            "cycle_clause",
            "location",
            "cterecursive",
            "cterefcount",
            "ctecolnames",
            "ctecoltypes",
            "ctecoltypmods",
            "ctecolcollations",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ctename,
            Aliascolnames,
            Ctematerialized,
            Ctequery,
            SearchClause,
            CycleClause,
            Location,
            Cterecursive,
            Cterefcount,
            Ctecolnames,
            Ctecoltypes,
            Ctecoltypmods,
            Ctecolcollations,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ctename" => Ok(GeneratedField::Ctename),
                            "aliascolnames" => Ok(GeneratedField::Aliascolnames),
                            "ctematerialized" => Ok(GeneratedField::Ctematerialized),
                            "ctequery" => Ok(GeneratedField::Ctequery),
                            "search_clause" => Ok(GeneratedField::SearchClause),
                            "cycle_clause" => Ok(GeneratedField::CycleClause),
                            "location" => Ok(GeneratedField::Location),
                            "cterecursive" => Ok(GeneratedField::Cterecursive),
                            "cterefcount" => Ok(GeneratedField::Cterefcount),
                            "ctecolnames" => Ok(GeneratedField::Ctecolnames),
                            "ctecoltypes" => Ok(GeneratedField::Ctecoltypes),
                            "ctecoltypmods" => Ok(GeneratedField::Ctecoltypmods),
                            "ctecolcollations" => Ok(GeneratedField::Ctecolcollations),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommonTableExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CommonTableExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommonTableExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ctename__ = None;
                let mut aliascolnames__ = None;
                let mut ctematerialized__ = None;
                let mut ctequery__ = None;
                let mut search_clause__ = None;
                let mut cycle_clause__ = None;
                let mut location__ = None;
                let mut cterecursive__ = None;
                let mut cterefcount__ = None;
                let mut ctecolnames__ = None;
                let mut ctecoltypes__ = None;
                let mut ctecoltypmods__ = None;
                let mut ctecolcollations__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ctename => {
                            if ctename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctename"));
                            }
                            ctename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aliascolnames => {
                            if aliascolnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aliascolnames"));
                            }
                            aliascolnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctematerialized => {
                            if ctematerialized__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctematerialized"));
                            }
                            ctematerialized__ = Some(map_.next_value::<CteMaterialize>()? as i32);
                        }
                        GeneratedField::Ctequery => {
                            if ctequery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctequery"));
                            }
                            ctequery__ = map_.next_value()?;
                        }
                        GeneratedField::SearchClause => {
                            if search_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("search_clause"));
                            }
                            search_clause__ = map_.next_value()?;
                        }
                        GeneratedField::CycleClause => {
                            if cycle_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cycle_clause"));
                            }
                            cycle_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Cterecursive => {
                            if cterecursive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cterecursive"));
                            }
                            cterecursive__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cterefcount => {
                            if cterefcount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cterefcount"));
                            }
                            cterefcount__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Ctecolnames => {
                            if ctecolnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctecolnames"));
                            }
                            ctecolnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctecoltypes => {
                            if ctecoltypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctecoltypes"));
                            }
                            ctecoltypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctecoltypmods => {
                            if ctecoltypmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctecoltypmods"));
                            }
                            ctecoltypmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctecolcollations => {
                            if ctecolcollations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctecolcollations"));
                            }
                            ctecolcollations__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CommonTableExpr {
                    ctename: ctename__.unwrap_or_default(),
                    aliascolnames: aliascolnames__.unwrap_or_default(),
                    ctematerialized: ctematerialized__.unwrap_or_default(),
                    ctequery: ctequery__,
                    search_clause: search_clause__,
                    cycle_clause: cycle_clause__,
                    location: location__.unwrap_or_default(),
                    cterecursive: cterecursive__.unwrap_or_default(),
                    cterefcount: cterefcount__.unwrap_or_default(),
                    ctecolnames: ctecolnames__.unwrap_or_default(),
                    ctecoltypes: ctecoltypes__.unwrap_or_default(),
                    ctecoltypmods: ctecoltypmods__.unwrap_or_default(),
                    ctecolcollations: ctecolcollations__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CommonTableExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompositeTypeStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.typevar.is_some() {
            len += 1;
        }
        if !self.coldeflist.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CompositeTypeStmt", len)?;
        if let Some(v) = self.typevar.as_ref() {
            struct_ser.serialize_field("typevar", v)?;
        }
        if !self.coldeflist.is_empty() {
            struct_ser.serialize_field("coldeflist", &self.coldeflist)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompositeTypeStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "typevar",
            "coldeflist",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Typevar,
            Coldeflist,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typevar" => Ok(GeneratedField::Typevar),
                            "coldeflist" => Ok(GeneratedField::Coldeflist),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompositeTypeStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CompositeTypeStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompositeTypeStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut typevar__ = None;
                let mut coldeflist__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Typevar => {
                            if typevar__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typevar"));
                            }
                            typevar__ = map_.next_value()?;
                        }
                        GeneratedField::Coldeflist => {
                            if coldeflist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coldeflist"));
                            }
                            coldeflist__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CompositeTypeStmt {
                    typevar: typevar__,
                    coldeflist: coldeflist__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CompositeTypeStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConstrType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "CONSTR_TYPE_UNDEFINED",
            Self::ConstrNull => "CONSTR_NULL",
            Self::ConstrNotnull => "CONSTR_NOTNULL",
            Self::ConstrDefault => "CONSTR_DEFAULT",
            Self::ConstrIdentity => "CONSTR_IDENTITY",
            Self::ConstrGenerated => "CONSTR_GENERATED",
            Self::ConstrCheck => "CONSTR_CHECK",
            Self::ConstrPrimary => "CONSTR_PRIMARY",
            Self::ConstrUnique => "CONSTR_UNIQUE",
            Self::ConstrExclusion => "CONSTR_EXCLUSION",
            Self::ConstrForeign => "CONSTR_FOREIGN",
            Self::ConstrAttrDeferrable => "CONSTR_ATTR_DEFERRABLE",
            Self::ConstrAttrNotDeferrable => "CONSTR_ATTR_NOT_DEFERRABLE",
            Self::ConstrAttrDeferred => "CONSTR_ATTR_DEFERRED",
            Self::ConstrAttrImmediate => "CONSTR_ATTR_IMMEDIATE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ConstrType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CONSTR_TYPE_UNDEFINED",
            "CONSTR_NULL",
            "CONSTR_NOTNULL",
            "CONSTR_DEFAULT",
            "CONSTR_IDENTITY",
            "CONSTR_GENERATED",
            "CONSTR_CHECK",
            "CONSTR_PRIMARY",
            "CONSTR_UNIQUE",
            "CONSTR_EXCLUSION",
            "CONSTR_FOREIGN",
            "CONSTR_ATTR_DEFERRABLE",
            "CONSTR_ATTR_NOT_DEFERRABLE",
            "CONSTR_ATTR_DEFERRED",
            "CONSTR_ATTR_IMMEDIATE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConstrType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CONSTR_TYPE_UNDEFINED" => Ok(ConstrType::Undefined),
                    "CONSTR_NULL" => Ok(ConstrType::ConstrNull),
                    "CONSTR_NOTNULL" => Ok(ConstrType::ConstrNotnull),
                    "CONSTR_DEFAULT" => Ok(ConstrType::ConstrDefault),
                    "CONSTR_IDENTITY" => Ok(ConstrType::ConstrIdentity),
                    "CONSTR_GENERATED" => Ok(ConstrType::ConstrGenerated),
                    "CONSTR_CHECK" => Ok(ConstrType::ConstrCheck),
                    "CONSTR_PRIMARY" => Ok(ConstrType::ConstrPrimary),
                    "CONSTR_UNIQUE" => Ok(ConstrType::ConstrUnique),
                    "CONSTR_EXCLUSION" => Ok(ConstrType::ConstrExclusion),
                    "CONSTR_FOREIGN" => Ok(ConstrType::ConstrForeign),
                    "CONSTR_ATTR_DEFERRABLE" => Ok(ConstrType::ConstrAttrDeferrable),
                    "CONSTR_ATTR_NOT_DEFERRABLE" => Ok(ConstrType::ConstrAttrNotDeferrable),
                    "CONSTR_ATTR_DEFERRED" => Ok(ConstrType::ConstrAttrDeferred),
                    "CONSTR_ATTR_IMMEDIATE" => Ok(ConstrType::ConstrAttrImmediate),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Constraint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.contype != 0 {
            len += 1;
        }
        if !self.conname.is_empty() {
            len += 1;
        }
        if self.deferrable {
            len += 1;
        }
        if self.initdeferred {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        if self.is_no_inherit {
            len += 1;
        }
        if self.raw_expr.is_some() {
            len += 1;
        }
        if !self.cooked_expr.is_empty() {
            len += 1;
        }
        if !self.generated_when.is_empty() {
            len += 1;
        }
        if self.nulls_not_distinct {
            len += 1;
        }
        if !self.keys.is_empty() {
            len += 1;
        }
        if !self.including.is_empty() {
            len += 1;
        }
        if !self.exclusions.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if !self.indexname.is_empty() {
            len += 1;
        }
        if !self.indexspace.is_empty() {
            len += 1;
        }
        if self.reset_default_tblspc {
            len += 1;
        }
        if !self.access_method.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if self.pktable.is_some() {
            len += 1;
        }
        if !self.fk_attrs.is_empty() {
            len += 1;
        }
        if !self.pk_attrs.is_empty() {
            len += 1;
        }
        if !self.fk_matchtype.is_empty() {
            len += 1;
        }
        if !self.fk_upd_action.is_empty() {
            len += 1;
        }
        if !self.fk_del_action.is_empty() {
            len += 1;
        }
        if !self.fk_del_set_cols.is_empty() {
            len += 1;
        }
        if !self.old_conpfeqop.is_empty() {
            len += 1;
        }
        if self.old_pktable_oid != 0 {
            len += 1;
        }
        if self.skip_validation {
            len += 1;
        }
        if self.initially_valid {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Constraint", len)?;
        if self.contype != 0 {
            let v = ConstrType::try_from(self.contype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.contype)))?;
            struct_ser.serialize_field("contype", &v)?;
        }
        if !self.conname.is_empty() {
            struct_ser.serialize_field("conname", &self.conname)?;
        }
        if self.deferrable {
            struct_ser.serialize_field("deferrable", &self.deferrable)?;
        }
        if self.initdeferred {
            struct_ser.serialize_field("initdeferred", &self.initdeferred)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        if self.is_no_inherit {
            struct_ser.serialize_field("is_no_inherit", &self.is_no_inherit)?;
        }
        if let Some(v) = self.raw_expr.as_ref() {
            struct_ser.serialize_field("raw_expr", v)?;
        }
        if !self.cooked_expr.is_empty() {
            struct_ser.serialize_field("cooked_expr", &self.cooked_expr)?;
        }
        if !self.generated_when.is_empty() {
            struct_ser.serialize_field("generated_when", &self.generated_when)?;
        }
        if self.nulls_not_distinct {
            struct_ser.serialize_field("nulls_not_distinct", &self.nulls_not_distinct)?;
        }
        if !self.keys.is_empty() {
            struct_ser.serialize_field("keys", &self.keys)?;
        }
        if !self.including.is_empty() {
            struct_ser.serialize_field("including", &self.including)?;
        }
        if !self.exclusions.is_empty() {
            struct_ser.serialize_field("exclusions", &self.exclusions)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if !self.indexname.is_empty() {
            struct_ser.serialize_field("indexname", &self.indexname)?;
        }
        if !self.indexspace.is_empty() {
            struct_ser.serialize_field("indexspace", &self.indexspace)?;
        }
        if self.reset_default_tblspc {
            struct_ser.serialize_field("reset_default_tblspc", &self.reset_default_tblspc)?;
        }
        if !self.access_method.is_empty() {
            struct_ser.serialize_field("access_method", &self.access_method)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("where_clause", v)?;
        }
        if let Some(v) = self.pktable.as_ref() {
            struct_ser.serialize_field("pktable", v)?;
        }
        if !self.fk_attrs.is_empty() {
            struct_ser.serialize_field("fk_attrs", &self.fk_attrs)?;
        }
        if !self.pk_attrs.is_empty() {
            struct_ser.serialize_field("pk_attrs", &self.pk_attrs)?;
        }
        if !self.fk_matchtype.is_empty() {
            struct_ser.serialize_field("fk_matchtype", &self.fk_matchtype)?;
        }
        if !self.fk_upd_action.is_empty() {
            struct_ser.serialize_field("fk_upd_action", &self.fk_upd_action)?;
        }
        if !self.fk_del_action.is_empty() {
            struct_ser.serialize_field("fk_del_action", &self.fk_del_action)?;
        }
        if !self.fk_del_set_cols.is_empty() {
            struct_ser.serialize_field("fk_del_set_cols", &self.fk_del_set_cols)?;
        }
        if !self.old_conpfeqop.is_empty() {
            struct_ser.serialize_field("old_conpfeqop", &self.old_conpfeqop)?;
        }
        if self.old_pktable_oid != 0 {
            struct_ser.serialize_field("old_pktable_oid", &self.old_pktable_oid)?;
        }
        if self.skip_validation {
            struct_ser.serialize_field("skip_validation", &self.skip_validation)?;
        }
        if self.initially_valid {
            struct_ser.serialize_field("initially_valid", &self.initially_valid)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Constraint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "contype",
            "conname",
            "deferrable",
            "initdeferred",
            "location",
            "is_no_inherit",
            "raw_expr",
            "cooked_expr",
            "generated_when",
            "nulls_not_distinct",
            "keys",
            "including",
            "exclusions",
            "options",
            "indexname",
            "indexspace",
            "reset_default_tblspc",
            "access_method",
            "where_clause",
            "pktable",
            "fk_attrs",
            "pk_attrs",
            "fk_matchtype",
            "fk_upd_action",
            "fk_del_action",
            "fk_del_set_cols",
            "old_conpfeqop",
            "old_pktable_oid",
            "skip_validation",
            "initially_valid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Contype,
            Conname,
            Deferrable,
            Initdeferred,
            Location,
            IsNoInherit,
            RawExpr,
            CookedExpr,
            GeneratedWhen,
            NullsNotDistinct,
            Keys,
            Including,
            Exclusions,
            Options,
            Indexname,
            Indexspace,
            ResetDefaultTblspc,
            AccessMethod,
            WhereClause,
            Pktable,
            FkAttrs,
            PkAttrs,
            FkMatchtype,
            FkUpdAction,
            FkDelAction,
            FkDelSetCols,
            OldConpfeqop,
            OldPktableOid,
            SkipValidation,
            InitiallyValid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "contype" => Ok(GeneratedField::Contype),
                            "conname" => Ok(GeneratedField::Conname),
                            "deferrable" => Ok(GeneratedField::Deferrable),
                            "initdeferred" => Ok(GeneratedField::Initdeferred),
                            "location" => Ok(GeneratedField::Location),
                            "is_no_inherit" => Ok(GeneratedField::IsNoInherit),
                            "raw_expr" => Ok(GeneratedField::RawExpr),
                            "cooked_expr" => Ok(GeneratedField::CookedExpr),
                            "generated_when" => Ok(GeneratedField::GeneratedWhen),
                            "nulls_not_distinct" => Ok(GeneratedField::NullsNotDistinct),
                            "keys" => Ok(GeneratedField::Keys),
                            "including" => Ok(GeneratedField::Including),
                            "exclusions" => Ok(GeneratedField::Exclusions),
                            "options" => Ok(GeneratedField::Options),
                            "indexname" => Ok(GeneratedField::Indexname),
                            "indexspace" => Ok(GeneratedField::Indexspace),
                            "reset_default_tblspc" => Ok(GeneratedField::ResetDefaultTblspc),
                            "access_method" => Ok(GeneratedField::AccessMethod),
                            "where_clause" => Ok(GeneratedField::WhereClause),
                            "pktable" => Ok(GeneratedField::Pktable),
                            "fk_attrs" => Ok(GeneratedField::FkAttrs),
                            "pk_attrs" => Ok(GeneratedField::PkAttrs),
                            "fk_matchtype" => Ok(GeneratedField::FkMatchtype),
                            "fk_upd_action" => Ok(GeneratedField::FkUpdAction),
                            "fk_del_action" => Ok(GeneratedField::FkDelAction),
                            "fk_del_set_cols" => Ok(GeneratedField::FkDelSetCols),
                            "old_conpfeqop" => Ok(GeneratedField::OldConpfeqop),
                            "old_pktable_oid" => Ok(GeneratedField::OldPktableOid),
                            "skip_validation" => Ok(GeneratedField::SkipValidation),
                            "initially_valid" => Ok(GeneratedField::InitiallyValid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Constraint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Constraint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Constraint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut contype__ = None;
                let mut conname__ = None;
                let mut deferrable__ = None;
                let mut initdeferred__ = None;
                let mut location__ = None;
                let mut is_no_inherit__ = None;
                let mut raw_expr__ = None;
                let mut cooked_expr__ = None;
                let mut generated_when__ = None;
                let mut nulls_not_distinct__ = None;
                let mut keys__ = None;
                let mut including__ = None;
                let mut exclusions__ = None;
                let mut options__ = None;
                let mut indexname__ = None;
                let mut indexspace__ = None;
                let mut reset_default_tblspc__ = None;
                let mut access_method__ = None;
                let mut where_clause__ = None;
                let mut pktable__ = None;
                let mut fk_attrs__ = None;
                let mut pk_attrs__ = None;
                let mut fk_matchtype__ = None;
                let mut fk_upd_action__ = None;
                let mut fk_del_action__ = None;
                let mut fk_del_set_cols__ = None;
                let mut old_conpfeqop__ = None;
                let mut old_pktable_oid__ = None;
                let mut skip_validation__ = None;
                let mut initially_valid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Contype => {
                            if contype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contype"));
                            }
                            contype__ = Some(map_.next_value::<ConstrType>()? as i32);
                        }
                        GeneratedField::Conname => {
                            if conname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conname"));
                            }
                            conname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deferrable => {
                            if deferrable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deferrable"));
                            }
                            deferrable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Initdeferred => {
                            if initdeferred__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initdeferred"));
                            }
                            initdeferred__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::IsNoInherit => {
                            if is_no_inherit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_no_inherit"));
                            }
                            is_no_inherit__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RawExpr => {
                            if raw_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("raw_expr"));
                            }
                            raw_expr__ = map_.next_value()?;
                        }
                        GeneratedField::CookedExpr => {
                            if cooked_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cooked_expr"));
                            }
                            cooked_expr__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GeneratedWhen => {
                            if generated_when__.is_some() {
                                return Err(serde::de::Error::duplicate_field("generated_when"));
                            }
                            generated_when__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NullsNotDistinct => {
                            if nulls_not_distinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nulls_not_distinct"));
                            }
                            nulls_not_distinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Keys => {
                            if keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keys"));
                            }
                            keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Including => {
                            if including__.is_some() {
                                return Err(serde::de::Error::duplicate_field("including"));
                            }
                            including__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Exclusions => {
                            if exclusions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exclusions"));
                            }
                            exclusions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Indexname => {
                            if indexname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexname"));
                            }
                            indexname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Indexspace => {
                            if indexspace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexspace"));
                            }
                            indexspace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ResetDefaultTblspc => {
                            if reset_default_tblspc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reset_default_tblspc"));
                            }
                            reset_default_tblspc__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AccessMethod => {
                            if access_method__.is_some() {
                                return Err(serde::de::Error::duplicate_field("access_method"));
                            }
                            access_method__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("where_clause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Pktable => {
                            if pktable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pktable"));
                            }
                            pktable__ = map_.next_value()?;
                        }
                        GeneratedField::FkAttrs => {
                            if fk_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fk_attrs"));
                            }
                            fk_attrs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PkAttrs => {
                            if pk_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pk_attrs"));
                            }
                            pk_attrs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FkMatchtype => {
                            if fk_matchtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fk_matchtype"));
                            }
                            fk_matchtype__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FkUpdAction => {
                            if fk_upd_action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fk_upd_action"));
                            }
                            fk_upd_action__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FkDelAction => {
                            if fk_del_action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fk_del_action"));
                            }
                            fk_del_action__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FkDelSetCols => {
                            if fk_del_set_cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fk_del_set_cols"));
                            }
                            fk_del_set_cols__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OldConpfeqop => {
                            if old_conpfeqop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("old_conpfeqop"));
                            }
                            old_conpfeqop__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OldPktableOid => {
                            if old_pktable_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("old_pktable_oid"));
                            }
                            old_pktable_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SkipValidation => {
                            if skip_validation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skip_validation"));
                            }
                            skip_validation__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InitiallyValid => {
                            if initially_valid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initially_valid"));
                            }
                            initially_valid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Constraint {
                    contype: contype__.unwrap_or_default(),
                    conname: conname__.unwrap_or_default(),
                    deferrable: deferrable__.unwrap_or_default(),
                    initdeferred: initdeferred__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                    is_no_inherit: is_no_inherit__.unwrap_or_default(),
                    raw_expr: raw_expr__,
                    cooked_expr: cooked_expr__.unwrap_or_default(),
                    generated_when: generated_when__.unwrap_or_default(),
                    nulls_not_distinct: nulls_not_distinct__.unwrap_or_default(),
                    keys: keys__.unwrap_or_default(),
                    including: including__.unwrap_or_default(),
                    exclusions: exclusions__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    indexname: indexname__.unwrap_or_default(),
                    indexspace: indexspace__.unwrap_or_default(),
                    reset_default_tblspc: reset_default_tblspc__.unwrap_or_default(),
                    access_method: access_method__.unwrap_or_default(),
                    where_clause: where_clause__,
                    pktable: pktable__,
                    fk_attrs: fk_attrs__.unwrap_or_default(),
                    pk_attrs: pk_attrs__.unwrap_or_default(),
                    fk_matchtype: fk_matchtype__.unwrap_or_default(),
                    fk_upd_action: fk_upd_action__.unwrap_or_default(),
                    fk_del_action: fk_del_action__.unwrap_or_default(),
                    fk_del_set_cols: fk_del_set_cols__.unwrap_or_default(),
                    old_conpfeqop: old_conpfeqop__.unwrap_or_default(),
                    old_pktable_oid: old_pktable_oid__.unwrap_or_default(),
                    skip_validation: skip_validation__.unwrap_or_default(),
                    initially_valid: initially_valid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Constraint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConstraintsSetStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.constraints.is_empty() {
            len += 1;
        }
        if self.deferred {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ConstraintsSetStmt", len)?;
        if !self.constraints.is_empty() {
            struct_ser.serialize_field("constraints", &self.constraints)?;
        }
        if self.deferred {
            struct_ser.serialize_field("deferred", &self.deferred)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConstraintsSetStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "constraints",
            "deferred",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Constraints,
            Deferred,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "constraints" => Ok(GeneratedField::Constraints),
                            "deferred" => Ok(GeneratedField::Deferred),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConstraintsSetStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ConstraintsSetStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConstraintsSetStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut constraints__ = None;
                let mut deferred__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Constraints => {
                            if constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraints"));
                            }
                            constraints__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deferred => {
                            if deferred__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deferred"));
                            }
                            deferred__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ConstraintsSetStmt {
                    constraints: constraints__.unwrap_or_default(),
                    deferred: deferred__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ConstraintsSetStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConvertRowtypeExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.convertformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ConvertRowtypeExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.convertformat != 0 {
            let v = CoercionForm::try_from(self.convertformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.convertformat)))?;
            struct_ser.serialize_field("convertformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConvertRowtypeExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "resulttype",
            "convertformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Resulttype,
            Convertformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "convertformat" => Ok(GeneratedField::Convertformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConvertRowtypeExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ConvertRowtypeExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConvertRowtypeExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut resulttype__ = None;
                let mut convertformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Convertformat => {
                            if convertformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("convertformat"));
                            }
                            convertformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ConvertRowtypeExpr {
                    xpr: xpr__,
                    arg: arg__,
                    resulttype: resulttype__.unwrap_or_default(),
                    convertformat: convertformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ConvertRowtypeExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CopyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if self.query.is_some() {
            len += 1;
        }
        if !self.attlist.is_empty() {
            len += 1;
        }
        if self.is_from {
            len += 1;
        }
        if self.is_program {
            len += 1;
        }
        if !self.filename.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CopyStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        if !self.attlist.is_empty() {
            struct_ser.serialize_field("attlist", &self.attlist)?;
        }
        if self.is_from {
            struct_ser.serialize_field("is_from", &self.is_from)?;
        }
        if self.is_program {
            struct_ser.serialize_field("is_program", &self.is_program)?;
        }
        if !self.filename.is_empty() {
            struct_ser.serialize_field("filename", &self.filename)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CopyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "query",
            "attlist",
            "is_from",
            "is_program",
            "filename",
            "options",
            "where_clause",
            "whereClause",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Query,
            Attlist,
            IsFrom,
            IsProgram,
            Filename,
            Options,
            WhereClause,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "query" => Ok(GeneratedField::Query),
                            "attlist" => Ok(GeneratedField::Attlist),
                            "is_from" => Ok(GeneratedField::IsFrom),
                            "is_program" => Ok(GeneratedField::IsProgram),
                            "filename" => Ok(GeneratedField::Filename),
                            "options" => Ok(GeneratedField::Options),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CopyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CopyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CopyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut query__ = None;
                let mut attlist__ = None;
                let mut is_from__ = None;
                let mut is_program__ = None;
                let mut filename__ = None;
                let mut options__ = None;
                let mut where_clause__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                        GeneratedField::Attlist => {
                            if attlist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("attlist"));
                            }
                            attlist__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsFrom => {
                            if is_from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_from"));
                            }
                            is_from__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsProgram => {
                            if is_program__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_program"));
                            }
                            is_program__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Filename => {
                            if filename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filename"));
                            }
                            filename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CopyStmt {
                    relation: relation__,
                    query: query__,
                    attlist: attlist__.unwrap_or_default(),
                    is_from: is_from__.unwrap_or_default(),
                    is_program: is_program__.unwrap_or_default(),
                    filename: filename__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    where_clause: where_clause__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CopyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateAmStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.amname.is_empty() {
            len += 1;
        }
        if !self.handler_name.is_empty() {
            len += 1;
        }
        if !self.amtype.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateAmStmt", len)?;
        if !self.amname.is_empty() {
            struct_ser.serialize_field("amname", &self.amname)?;
        }
        if !self.handler_name.is_empty() {
            struct_ser.serialize_field("handler_name", &self.handler_name)?;
        }
        if !self.amtype.is_empty() {
            struct_ser.serialize_field("amtype", &self.amtype)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateAmStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "amname",
            "handler_name",
            "amtype",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Amname,
            HandlerName,
            Amtype,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "amname" => Ok(GeneratedField::Amname),
                            "handler_name" => Ok(GeneratedField::HandlerName),
                            "amtype" => Ok(GeneratedField::Amtype),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateAmStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateAmStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateAmStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut amname__ = None;
                let mut handler_name__ = None;
                let mut amtype__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Amname => {
                            if amname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amname"));
                            }
                            amname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HandlerName => {
                            if handler_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("handler_name"));
                            }
                            handler_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amtype => {
                            if amtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amtype"));
                            }
                            amtype__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateAmStmt {
                    amname: amname__.unwrap_or_default(),
                    handler_name: handler_name__.unwrap_or_default(),
                    amtype: amtype__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateAmStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateCastStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.sourcetype.is_some() {
            len += 1;
        }
        if self.targettype.is_some() {
            len += 1;
        }
        if self.func.is_some() {
            len += 1;
        }
        if self.context != 0 {
            len += 1;
        }
        if self.inout {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateCastStmt", len)?;
        if let Some(v) = self.sourcetype.as_ref() {
            struct_ser.serialize_field("sourcetype", v)?;
        }
        if let Some(v) = self.targettype.as_ref() {
            struct_ser.serialize_field("targettype", v)?;
        }
        if let Some(v) = self.func.as_ref() {
            struct_ser.serialize_field("func", v)?;
        }
        if self.context != 0 {
            let v = CoercionContext::try_from(self.context)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.context)))?;
            struct_ser.serialize_field("context", &v)?;
        }
        if self.inout {
            struct_ser.serialize_field("inout", &self.inout)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateCastStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sourcetype",
            "targettype",
            "func",
            "context",
            "inout",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sourcetype,
            Targettype,
            Func,
            Context,
            Inout,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sourcetype" => Ok(GeneratedField::Sourcetype),
                            "targettype" => Ok(GeneratedField::Targettype),
                            "func" => Ok(GeneratedField::Func),
                            "context" => Ok(GeneratedField::Context),
                            "inout" => Ok(GeneratedField::Inout),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateCastStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateCastStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateCastStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sourcetype__ = None;
                let mut targettype__ = None;
                let mut func__ = None;
                let mut context__ = None;
                let mut inout__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sourcetype => {
                            if sourcetype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sourcetype"));
                            }
                            sourcetype__ = map_.next_value()?;
                        }
                        GeneratedField::Targettype => {
                            if targettype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targettype"));
                            }
                            targettype__ = map_.next_value()?;
                        }
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = map_.next_value()?;
                        }
                        GeneratedField::Context => {
                            if context__.is_some() {
                                return Err(serde::de::Error::duplicate_field("context"));
                            }
                            context__ = Some(map_.next_value::<CoercionContext>()? as i32);
                        }
                        GeneratedField::Inout => {
                            if inout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inout"));
                            }
                            inout__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateCastStmt {
                    sourcetype: sourcetype__,
                    targettype: targettype__,
                    func: func__,
                    context: context__.unwrap_or_default(),
                    inout: inout__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateCastStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateConversionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.conversion_name.is_empty() {
            len += 1;
        }
        if !self.for_encoding_name.is_empty() {
            len += 1;
        }
        if !self.to_encoding_name.is_empty() {
            len += 1;
        }
        if !self.func_name.is_empty() {
            len += 1;
        }
        if self.def {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateConversionStmt", len)?;
        if !self.conversion_name.is_empty() {
            struct_ser.serialize_field("conversion_name", &self.conversion_name)?;
        }
        if !self.for_encoding_name.is_empty() {
            struct_ser.serialize_field("for_encoding_name", &self.for_encoding_name)?;
        }
        if !self.to_encoding_name.is_empty() {
            struct_ser.serialize_field("to_encoding_name", &self.to_encoding_name)?;
        }
        if !self.func_name.is_empty() {
            struct_ser.serialize_field("func_name", &self.func_name)?;
        }
        if self.def {
            struct_ser.serialize_field("def", &self.def)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateConversionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "conversion_name",
            "for_encoding_name",
            "to_encoding_name",
            "func_name",
            "def",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConversionName,
            ForEncodingName,
            ToEncodingName,
            FuncName,
            Def,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "conversion_name" => Ok(GeneratedField::ConversionName),
                            "for_encoding_name" => Ok(GeneratedField::ForEncodingName),
                            "to_encoding_name" => Ok(GeneratedField::ToEncodingName),
                            "func_name" => Ok(GeneratedField::FuncName),
                            "def" => Ok(GeneratedField::Def),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateConversionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateConversionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateConversionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut conversion_name__ = None;
                let mut for_encoding_name__ = None;
                let mut to_encoding_name__ = None;
                let mut func_name__ = None;
                let mut def__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConversionName => {
                            if conversion_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conversion_name"));
                            }
                            conversion_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForEncodingName => {
                            if for_encoding_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_encoding_name"));
                            }
                            for_encoding_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ToEncodingName => {
                            if to_encoding_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("to_encoding_name"));
                            }
                            to_encoding_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FuncName => {
                            if func_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func_name"));
                            }
                            func_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Def => {
                            if def__.is_some() {
                                return Err(serde::de::Error::duplicate_field("def"));
                            }
                            def__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateConversionStmt {
                    conversion_name: conversion_name__.unwrap_or_default(),
                    for_encoding_name: for_encoding_name__.unwrap_or_default(),
                    to_encoding_name: to_encoding_name__.unwrap_or_default(),
                    func_name: func_name__.unwrap_or_default(),
                    def: def__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateConversionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateDomainStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.domainname.is_empty() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if self.coll_clause.is_some() {
            len += 1;
        }
        if !self.constraints.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateDomainStmt", len)?;
        if !self.domainname.is_empty() {
            struct_ser.serialize_field("domainname", &self.domainname)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if let Some(v) = self.coll_clause.as_ref() {
            struct_ser.serialize_field("collClause", v)?;
        }
        if !self.constraints.is_empty() {
            struct_ser.serialize_field("constraints", &self.constraints)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateDomainStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "domainname",
            "type_name",
            "typeName",
            "coll_clause",
            "collClause",
            "constraints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Domainname,
            TypeName,
            CollClause,
            Constraints,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "domainname" => Ok(GeneratedField::Domainname),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "collClause" | "coll_clause" => Ok(GeneratedField::CollClause),
                            "constraints" => Ok(GeneratedField::Constraints),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateDomainStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateDomainStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateDomainStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut domainname__ = None;
                let mut type_name__ = None;
                let mut coll_clause__ = None;
                let mut constraints__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Domainname => {
                            if domainname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("domainname"));
                            }
                            domainname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::CollClause => {
                            if coll_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collClause"));
                            }
                            coll_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Constraints => {
                            if constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraints"));
                            }
                            constraints__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateDomainStmt {
                    domainname: domainname__.unwrap_or_default(),
                    type_name: type_name__,
                    coll_clause: coll_clause__,
                    constraints: constraints__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateDomainStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateEnumStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.type_name.is_empty() {
            len += 1;
        }
        if !self.vals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateEnumStmt", len)?;
        if !self.type_name.is_empty() {
            struct_ser.serialize_field("typeName", &self.type_name)?;
        }
        if !self.vals.is_empty() {
            struct_ser.serialize_field("vals", &self.vals)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateEnumStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "vals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            Vals,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "vals" => Ok(GeneratedField::Vals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateEnumStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateEnumStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateEnumStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut vals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Vals => {
                            if vals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vals"));
                            }
                            vals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateEnumStmt {
                    type_name: type_name__.unwrap_or_default(),
                    vals: vals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateEnumStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateEventTrigStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.trigname.is_empty() {
            len += 1;
        }
        if !self.eventname.is_empty() {
            len += 1;
        }
        if !self.whenclause.is_empty() {
            len += 1;
        }
        if !self.funcname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateEventTrigStmt", len)?;
        if !self.trigname.is_empty() {
            struct_ser.serialize_field("trigname", &self.trigname)?;
        }
        if !self.eventname.is_empty() {
            struct_ser.serialize_field("eventname", &self.eventname)?;
        }
        if !self.whenclause.is_empty() {
            struct_ser.serialize_field("whenclause", &self.whenclause)?;
        }
        if !self.funcname.is_empty() {
            struct_ser.serialize_field("funcname", &self.funcname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateEventTrigStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "trigname",
            "eventname",
            "whenclause",
            "funcname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Trigname,
            Eventname,
            Whenclause,
            Funcname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "trigname" => Ok(GeneratedField::Trigname),
                            "eventname" => Ok(GeneratedField::Eventname),
                            "whenclause" => Ok(GeneratedField::Whenclause),
                            "funcname" => Ok(GeneratedField::Funcname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateEventTrigStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateEventTrigStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateEventTrigStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut trigname__ = None;
                let mut eventname__ = None;
                let mut whenclause__ = None;
                let mut funcname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Trigname => {
                            if trigname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trigname"));
                            }
                            trigname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Eventname => {
                            if eventname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eventname"));
                            }
                            eventname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Whenclause => {
                            if whenclause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whenclause"));
                            }
                            whenclause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcname => {
                            if funcname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcname"));
                            }
                            funcname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateEventTrigStmt {
                    trigname: trigname__.unwrap_or_default(),
                    eventname: eventname__.unwrap_or_default(),
                    whenclause: whenclause__.unwrap_or_default(),
                    funcname: funcname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateEventTrigStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateExtensionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.extname.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateExtensionStmt", len)?;
        if !self.extname.is_empty() {
            struct_ser.serialize_field("extname", &self.extname)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateExtensionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "extname",
            "if_not_exists",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Extname,
            IfNotExists,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "extname" => Ok(GeneratedField::Extname),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateExtensionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateExtensionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateExtensionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut extname__ = None;
                let mut if_not_exists__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Extname => {
                            if extname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extname"));
                            }
                            extname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateExtensionStmt {
                    extname: extname__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateExtensionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateFdwStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fdwname.is_empty() {
            len += 1;
        }
        if !self.func_options.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateFdwStmt", len)?;
        if !self.fdwname.is_empty() {
            struct_ser.serialize_field("fdwname", &self.fdwname)?;
        }
        if !self.func_options.is_empty() {
            struct_ser.serialize_field("func_options", &self.func_options)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateFdwStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fdwname",
            "func_options",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fdwname,
            FuncOptions,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fdwname" => Ok(GeneratedField::Fdwname),
                            "func_options" => Ok(GeneratedField::FuncOptions),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateFdwStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateFdwStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateFdwStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fdwname__ = None;
                let mut func_options__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fdwname => {
                            if fdwname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fdwname"));
                            }
                            fdwname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FuncOptions => {
                            if func_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func_options"));
                            }
                            func_options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateFdwStmt {
                    fdwname: fdwname__.unwrap_or_default(),
                    func_options: func_options__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateFdwStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateForeignServerStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.servername.is_empty() {
            len += 1;
        }
        if !self.servertype.is_empty() {
            len += 1;
        }
        if !self.version.is_empty() {
            len += 1;
        }
        if !self.fdwname.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateForeignServerStmt", len)?;
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if !self.servertype.is_empty() {
            struct_ser.serialize_field("servertype", &self.servertype)?;
        }
        if !self.version.is_empty() {
            struct_ser.serialize_field("version", &self.version)?;
        }
        if !self.fdwname.is_empty() {
            struct_ser.serialize_field("fdwname", &self.fdwname)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateForeignServerStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "servername",
            "servertype",
            "version",
            "fdwname",
            "if_not_exists",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Servername,
            Servertype,
            Version,
            Fdwname,
            IfNotExists,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "servername" => Ok(GeneratedField::Servername),
                            "servertype" => Ok(GeneratedField::Servertype),
                            "version" => Ok(GeneratedField::Version),
                            "fdwname" => Ok(GeneratedField::Fdwname),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateForeignServerStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateForeignServerStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateForeignServerStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut servername__ = None;
                let mut servertype__ = None;
                let mut version__ = None;
                let mut fdwname__ = None;
                let mut if_not_exists__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Servertype => {
                            if servertype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servertype"));
                            }
                            servertype__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fdwname => {
                            if fdwname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fdwname"));
                            }
                            fdwname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateForeignServerStmt {
                    servername: servername__.unwrap_or_default(),
                    servertype: servertype__.unwrap_or_default(),
                    version: version__.unwrap_or_default(),
                    fdwname: fdwname__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateForeignServerStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateForeignTableStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.base_stmt.is_some() {
            len += 1;
        }
        if !self.servername.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateForeignTableStmt", len)?;
        if let Some(v) = self.base_stmt.as_ref() {
            struct_ser.serialize_field("base", v)?;
        }
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateForeignTableStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "base_stmt",
            "base",
            "servername",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BaseStmt,
            Servername,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "base" | "base_stmt" => Ok(GeneratedField::BaseStmt),
                            "servername" => Ok(GeneratedField::Servername),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateForeignTableStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateForeignTableStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateForeignTableStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut base_stmt__ = None;
                let mut servername__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BaseStmt => {
                            if base_stmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("base"));
                            }
                            base_stmt__ = map_.next_value()?;
                        }
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateForeignTableStmt {
                    base_stmt: base_stmt__,
                    servername: servername__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateForeignTableStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateFunctionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_procedure {
            len += 1;
        }
        if self.replace {
            len += 1;
        }
        if !self.funcname.is_empty() {
            len += 1;
        }
        if !self.parameters.is_empty() {
            len += 1;
        }
        if self.return_type.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.sql_body.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateFunctionStmt", len)?;
        if self.is_procedure {
            struct_ser.serialize_field("is_procedure", &self.is_procedure)?;
        }
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if !self.funcname.is_empty() {
            struct_ser.serialize_field("funcname", &self.funcname)?;
        }
        if !self.parameters.is_empty() {
            struct_ser.serialize_field("parameters", &self.parameters)?;
        }
        if let Some(v) = self.return_type.as_ref() {
            struct_ser.serialize_field("returnType", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.sql_body.as_ref() {
            struct_ser.serialize_field("sql_body", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateFunctionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_procedure",
            "replace",
            "funcname",
            "parameters",
            "return_type",
            "returnType",
            "options",
            "sql_body",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsProcedure,
            Replace,
            Funcname,
            Parameters,
            ReturnType,
            Options,
            SqlBody,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "is_procedure" => Ok(GeneratedField::IsProcedure),
                            "replace" => Ok(GeneratedField::Replace),
                            "funcname" => Ok(GeneratedField::Funcname),
                            "parameters" => Ok(GeneratedField::Parameters),
                            "returnType" | "return_type" => Ok(GeneratedField::ReturnType),
                            "options" => Ok(GeneratedField::Options),
                            "sql_body" => Ok(GeneratedField::SqlBody),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateFunctionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateFunctionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateFunctionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_procedure__ = None;
                let mut replace__ = None;
                let mut funcname__ = None;
                let mut parameters__ = None;
                let mut return_type__ = None;
                let mut options__ = None;
                let mut sql_body__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsProcedure => {
                            if is_procedure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_procedure"));
                            }
                            is_procedure__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcname => {
                            if funcname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcname"));
                            }
                            funcname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Parameters => {
                            if parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameters"));
                            }
                            parameters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReturnType => {
                            if return_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returnType"));
                            }
                            return_type__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SqlBody => {
                            if sql_body__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sql_body"));
                            }
                            sql_body__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CreateFunctionStmt {
                    is_procedure: is_procedure__.unwrap_or_default(),
                    replace: replace__.unwrap_or_default(),
                    funcname: funcname__.unwrap_or_default(),
                    parameters: parameters__.unwrap_or_default(),
                    return_type: return_type__,
                    options: options__.unwrap_or_default(),
                    sql_body: sql_body__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateFunctionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateOpClassItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.itemtype != 0 {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.number != 0 {
            len += 1;
        }
        if !self.order_family.is_empty() {
            len += 1;
        }
        if !self.class_args.is_empty() {
            len += 1;
        }
        if self.storedtype.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateOpClassItem", len)?;
        if self.itemtype != 0 {
            struct_ser.serialize_field("itemtype", &self.itemtype)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if self.number != 0 {
            struct_ser.serialize_field("number", &self.number)?;
        }
        if !self.order_family.is_empty() {
            struct_ser.serialize_field("order_family", &self.order_family)?;
        }
        if !self.class_args.is_empty() {
            struct_ser.serialize_field("class_args", &self.class_args)?;
        }
        if let Some(v) = self.storedtype.as_ref() {
            struct_ser.serialize_field("storedtype", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateOpClassItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "itemtype",
            "name",
            "number",
            "order_family",
            "class_args",
            "storedtype",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Itemtype,
            Name,
            Number,
            OrderFamily,
            ClassArgs,
            Storedtype,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "itemtype" => Ok(GeneratedField::Itemtype),
                            "name" => Ok(GeneratedField::Name),
                            "number" => Ok(GeneratedField::Number),
                            "order_family" => Ok(GeneratedField::OrderFamily),
                            "class_args" => Ok(GeneratedField::ClassArgs),
                            "storedtype" => Ok(GeneratedField::Storedtype),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateOpClassItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateOpClassItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateOpClassItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut itemtype__ = None;
                let mut name__ = None;
                let mut number__ = None;
                let mut order_family__ = None;
                let mut class_args__ = None;
                let mut storedtype__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Itemtype => {
                            if itemtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("itemtype"));
                            }
                            itemtype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Number => {
                            if number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::OrderFamily => {
                            if order_family__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order_family"));
                            }
                            order_family__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ClassArgs => {
                            if class_args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("class_args"));
                            }
                            class_args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Storedtype => {
                            if storedtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storedtype"));
                            }
                            storedtype__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CreateOpClassItem {
                    itemtype: itemtype__.unwrap_or_default(),
                    name: name__,
                    number: number__.unwrap_or_default(),
                    order_family: order_family__.unwrap_or_default(),
                    class_args: class_args__.unwrap_or_default(),
                    storedtype: storedtype__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateOpClassItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateOpClassStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.opclassname.is_empty() {
            len += 1;
        }
        if !self.opfamilyname.is_empty() {
            len += 1;
        }
        if !self.amname.is_empty() {
            len += 1;
        }
        if self.datatype.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.is_default {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateOpClassStmt", len)?;
        if !self.opclassname.is_empty() {
            struct_ser.serialize_field("opclassname", &self.opclassname)?;
        }
        if !self.opfamilyname.is_empty() {
            struct_ser.serialize_field("opfamilyname", &self.opfamilyname)?;
        }
        if !self.amname.is_empty() {
            struct_ser.serialize_field("amname", &self.amname)?;
        }
        if let Some(v) = self.datatype.as_ref() {
            struct_ser.serialize_field("datatype", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if self.is_default {
            struct_ser.serialize_field("isDefault", &self.is_default)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateOpClassStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "opclassname",
            "opfamilyname",
            "amname",
            "datatype",
            "items",
            "is_default",
            "isDefault",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Opclassname,
            Opfamilyname,
            Amname,
            Datatype,
            Items,
            IsDefault,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opclassname" => Ok(GeneratedField::Opclassname),
                            "opfamilyname" => Ok(GeneratedField::Opfamilyname),
                            "amname" => Ok(GeneratedField::Amname),
                            "datatype" => Ok(GeneratedField::Datatype),
                            "items" => Ok(GeneratedField::Items),
                            "isDefault" | "is_default" => Ok(GeneratedField::IsDefault),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateOpClassStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateOpClassStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateOpClassStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut opclassname__ = None;
                let mut opfamilyname__ = None;
                let mut amname__ = None;
                let mut datatype__ = None;
                let mut items__ = None;
                let mut is_default__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Opclassname => {
                            if opclassname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opclassname"));
                            }
                            opclassname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opfamilyname => {
                            if opfamilyname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opfamilyname"));
                            }
                            opfamilyname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amname => {
                            if amname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amname"));
                            }
                            amname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Datatype => {
                            if datatype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datatype"));
                            }
                            datatype__ = map_.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsDefault => {
                            if is_default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isDefault"));
                            }
                            is_default__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateOpClassStmt {
                    opclassname: opclassname__.unwrap_or_default(),
                    opfamilyname: opfamilyname__.unwrap_or_default(),
                    amname: amname__.unwrap_or_default(),
                    datatype: datatype__,
                    items: items__.unwrap_or_default(),
                    is_default: is_default__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateOpClassStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateOpFamilyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.opfamilyname.is_empty() {
            len += 1;
        }
        if !self.amname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateOpFamilyStmt", len)?;
        if !self.opfamilyname.is_empty() {
            struct_ser.serialize_field("opfamilyname", &self.opfamilyname)?;
        }
        if !self.amname.is_empty() {
            struct_ser.serialize_field("amname", &self.amname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateOpFamilyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "opfamilyname",
            "amname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Opfamilyname,
            Amname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opfamilyname" => Ok(GeneratedField::Opfamilyname),
                            "amname" => Ok(GeneratedField::Amname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateOpFamilyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateOpFamilyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateOpFamilyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut opfamilyname__ = None;
                let mut amname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Opfamilyname => {
                            if opfamilyname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opfamilyname"));
                            }
                            opfamilyname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amname => {
                            if amname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amname"));
                            }
                            amname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateOpFamilyStmt {
                    opfamilyname: opfamilyname__.unwrap_or_default(),
                    amname: amname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateOpFamilyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreatePLangStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.replace {
            len += 1;
        }
        if !self.plname.is_empty() {
            len += 1;
        }
        if !self.plhandler.is_empty() {
            len += 1;
        }
        if !self.plinline.is_empty() {
            len += 1;
        }
        if !self.plvalidator.is_empty() {
            len += 1;
        }
        if self.pltrusted {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreatePLangStmt", len)?;
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if !self.plname.is_empty() {
            struct_ser.serialize_field("plname", &self.plname)?;
        }
        if !self.plhandler.is_empty() {
            struct_ser.serialize_field("plhandler", &self.plhandler)?;
        }
        if !self.plinline.is_empty() {
            struct_ser.serialize_field("plinline", &self.plinline)?;
        }
        if !self.plvalidator.is_empty() {
            struct_ser.serialize_field("plvalidator", &self.plvalidator)?;
        }
        if self.pltrusted {
            struct_ser.serialize_field("pltrusted", &self.pltrusted)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreatePLangStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "replace",
            "plname",
            "plhandler",
            "plinline",
            "plvalidator",
            "pltrusted",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Replace,
            Plname,
            Plhandler,
            Plinline,
            Plvalidator,
            Pltrusted,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "replace" => Ok(GeneratedField::Replace),
                            "plname" => Ok(GeneratedField::Plname),
                            "plhandler" => Ok(GeneratedField::Plhandler),
                            "plinline" => Ok(GeneratedField::Plinline),
                            "plvalidator" => Ok(GeneratedField::Plvalidator),
                            "pltrusted" => Ok(GeneratedField::Pltrusted),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreatePLangStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreatePLangStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreatePLangStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut replace__ = None;
                let mut plname__ = None;
                let mut plhandler__ = None;
                let mut plinline__ = None;
                let mut plvalidator__ = None;
                let mut pltrusted__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Plname => {
                            if plname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plname"));
                            }
                            plname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Plhandler => {
                            if plhandler__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plhandler"));
                            }
                            plhandler__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Plinline => {
                            if plinline__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plinline"));
                            }
                            plinline__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Plvalidator => {
                            if plvalidator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plvalidator"));
                            }
                            plvalidator__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pltrusted => {
                            if pltrusted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pltrusted"));
                            }
                            pltrusted__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreatePLangStmt {
                    replace: replace__.unwrap_or_default(),
                    plname: plname__.unwrap_or_default(),
                    plhandler: plhandler__.unwrap_or_default(),
                    plinline: plinline__.unwrap_or_default(),
                    plvalidator: plvalidator__.unwrap_or_default(),
                    pltrusted: pltrusted__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreatePLangStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreatePolicyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.policy_name.is_empty() {
            len += 1;
        }
        if self.table.is_some() {
            len += 1;
        }
        if !self.cmd_name.is_empty() {
            len += 1;
        }
        if self.permissive {
            len += 1;
        }
        if !self.roles.is_empty() {
            len += 1;
        }
        if self.qual.is_some() {
            len += 1;
        }
        if self.with_check.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreatePolicyStmt", len)?;
        if !self.policy_name.is_empty() {
            struct_ser.serialize_field("policy_name", &self.policy_name)?;
        }
        if let Some(v) = self.table.as_ref() {
            struct_ser.serialize_field("table", v)?;
        }
        if !self.cmd_name.is_empty() {
            struct_ser.serialize_field("cmd_name", &self.cmd_name)?;
        }
        if self.permissive {
            struct_ser.serialize_field("permissive", &self.permissive)?;
        }
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if let Some(v) = self.qual.as_ref() {
            struct_ser.serialize_field("qual", v)?;
        }
        if let Some(v) = self.with_check.as_ref() {
            struct_ser.serialize_field("with_check", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreatePolicyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "policy_name",
            "table",
            "cmd_name",
            "permissive",
            "roles",
            "qual",
            "with_check",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PolicyName,
            Table,
            CmdName,
            Permissive,
            Roles,
            Qual,
            WithCheck,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "policy_name" => Ok(GeneratedField::PolicyName),
                            "table" => Ok(GeneratedField::Table),
                            "cmd_name" => Ok(GeneratedField::CmdName),
                            "permissive" => Ok(GeneratedField::Permissive),
                            "roles" => Ok(GeneratedField::Roles),
                            "qual" => Ok(GeneratedField::Qual),
                            "with_check" => Ok(GeneratedField::WithCheck),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreatePolicyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreatePolicyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreatePolicyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut policy_name__ = None;
                let mut table__ = None;
                let mut cmd_name__ = None;
                let mut permissive__ = None;
                let mut roles__ = None;
                let mut qual__ = None;
                let mut with_check__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PolicyName => {
                            if policy_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("policy_name"));
                            }
                            policy_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Table => {
                            if table__.is_some() {
                                return Err(serde::de::Error::duplicate_field("table"));
                            }
                            table__ = map_.next_value()?;
                        }
                        GeneratedField::CmdName => {
                            if cmd_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd_name"));
                            }
                            cmd_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Permissive => {
                            if permissive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("permissive"));
                            }
                            permissive__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Qual => {
                            if qual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("qual"));
                            }
                            qual__ = map_.next_value()?;
                        }
                        GeneratedField::WithCheck => {
                            if with_check__.is_some() {
                                return Err(serde::de::Error::duplicate_field("with_check"));
                            }
                            with_check__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CreatePolicyStmt {
                    policy_name: policy_name__.unwrap_or_default(),
                    table: table__,
                    cmd_name: cmd_name__.unwrap_or_default(),
                    permissive: permissive__.unwrap_or_default(),
                    roles: roles__.unwrap_or_default(),
                    qual: qual__,
                    with_check: with_check__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreatePolicyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreatePublicationStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pubname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if !self.pubobjects.is_empty() {
            len += 1;
        }
        if self.for_all_tables {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreatePublicationStmt", len)?;
        if !self.pubname.is_empty() {
            struct_ser.serialize_field("pubname", &self.pubname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if !self.pubobjects.is_empty() {
            struct_ser.serialize_field("pubobjects", &self.pubobjects)?;
        }
        if self.for_all_tables {
            struct_ser.serialize_field("for_all_tables", &self.for_all_tables)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreatePublicationStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pubname",
            "options",
            "pubobjects",
            "for_all_tables",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Pubname,
            Options,
            Pubobjects,
            ForAllTables,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pubname" => Ok(GeneratedField::Pubname),
                            "options" => Ok(GeneratedField::Options),
                            "pubobjects" => Ok(GeneratedField::Pubobjects),
                            "for_all_tables" => Ok(GeneratedField::ForAllTables),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreatePublicationStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreatePublicationStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreatePublicationStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pubname__ = None;
                let mut options__ = None;
                let mut pubobjects__ = None;
                let mut for_all_tables__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Pubname => {
                            if pubname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubname"));
                            }
                            pubname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pubobjects => {
                            if pubobjects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubobjects"));
                            }
                            pubobjects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForAllTables => {
                            if for_all_tables__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_all_tables"));
                            }
                            for_all_tables__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreatePublicationStmt {
                    pubname: pubname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    pubobjects: pubobjects__.unwrap_or_default(),
                    for_all_tables: for_all_tables__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreatePublicationStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateRangeStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.type_name.is_empty() {
            len += 1;
        }
        if !self.params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateRangeStmt", len)?;
        if !self.type_name.is_empty() {
            struct_ser.serialize_field("typeName", &self.type_name)?;
        }
        if !self.params.is_empty() {
            struct_ser.serialize_field("params", &self.params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateRangeStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "params",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            Params,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateRangeStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateRangeStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateRangeStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateRangeStmt {
                    type_name: type_name__.unwrap_or_default(),
                    params: params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateRangeStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateRoleStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stmt_type != 0 {
            len += 1;
        }
        if !self.role.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateRoleStmt", len)?;
        if self.stmt_type != 0 {
            let v = RoleStmtType::try_from(self.stmt_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.stmt_type)))?;
            struct_ser.serialize_field("stmt_type", &v)?;
        }
        if !self.role.is_empty() {
            struct_ser.serialize_field("role", &self.role)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateRoleStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stmt_type",
            "role",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StmtType,
            Role,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stmt_type" => Ok(GeneratedField::StmtType),
                            "role" => Ok(GeneratedField::Role),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateRoleStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateRoleStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateRoleStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stmt_type__ = None;
                let mut role__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StmtType => {
                            if stmt_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt_type"));
                            }
                            stmt_type__ = Some(map_.next_value::<RoleStmtType>()? as i32);
                        }
                        GeneratedField::Role => {
                            if role__.is_some() {
                                return Err(serde::de::Error::duplicate_field("role"));
                            }
                            role__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateRoleStmt {
                    stmt_type: stmt_type__.unwrap_or_default(),
                    role: role__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateRoleStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateSchemaStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.schemaname.is_empty() {
            len += 1;
        }
        if self.authrole.is_some() {
            len += 1;
        }
        if !self.schema_elts.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateSchemaStmt", len)?;
        if !self.schemaname.is_empty() {
            struct_ser.serialize_field("schemaname", &self.schemaname)?;
        }
        if let Some(v) = self.authrole.as_ref() {
            struct_ser.serialize_field("authrole", v)?;
        }
        if !self.schema_elts.is_empty() {
            struct_ser.serialize_field("schemaElts", &self.schema_elts)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateSchemaStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "schemaname",
            "authrole",
            "schema_elts",
            "schemaElts",
            "if_not_exists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Schemaname,
            Authrole,
            SchemaElts,
            IfNotExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "schemaname" => Ok(GeneratedField::Schemaname),
                            "authrole" => Ok(GeneratedField::Authrole),
                            "schemaElts" | "schema_elts" => Ok(GeneratedField::SchemaElts),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateSchemaStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateSchemaStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateSchemaStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut schemaname__ = None;
                let mut authrole__ = None;
                let mut schema_elts__ = None;
                let mut if_not_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Schemaname => {
                            if schemaname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schemaname"));
                            }
                            schemaname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Authrole => {
                            if authrole__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authrole"));
                            }
                            authrole__ = map_.next_value()?;
                        }
                        GeneratedField::SchemaElts => {
                            if schema_elts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schemaElts"));
                            }
                            schema_elts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateSchemaStmt {
                    schemaname: schemaname__.unwrap_or_default(),
                    authrole: authrole__,
                    schema_elts: schema_elts__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateSchemaStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateSeqStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.sequence.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.owner_id != 0 {
            len += 1;
        }
        if self.for_identity {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateSeqStmt", len)?;
        if let Some(v) = self.sequence.as_ref() {
            struct_ser.serialize_field("sequence", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.owner_id != 0 {
            struct_ser.serialize_field("ownerId", &self.owner_id)?;
        }
        if self.for_identity {
            struct_ser.serialize_field("for_identity", &self.for_identity)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateSeqStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sequence",
            "options",
            "owner_id",
            "ownerId",
            "for_identity",
            "if_not_exists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sequence,
            Options,
            OwnerId,
            ForIdentity,
            IfNotExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sequence" => Ok(GeneratedField::Sequence),
                            "options" => Ok(GeneratedField::Options),
                            "ownerId" | "owner_id" => Ok(GeneratedField::OwnerId),
                            "for_identity" => Ok(GeneratedField::ForIdentity),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateSeqStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateSeqStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateSeqStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sequence__ = None;
                let mut options__ = None;
                let mut owner_id__ = None;
                let mut for_identity__ = None;
                let mut if_not_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sequence => {
                            if sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequence"));
                            }
                            sequence__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OwnerId => {
                            if owner_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ownerId"));
                            }
                            owner_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ForIdentity => {
                            if for_identity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_identity"));
                            }
                            for_identity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateSeqStmt {
                    sequence: sequence__,
                    options: options__.unwrap_or_default(),
                    owner_id: owner_id__.unwrap_or_default(),
                    for_identity: for_identity__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateSeqStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateStatsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.defnames.is_empty() {
            len += 1;
        }
        if !self.stat_types.is_empty() {
            len += 1;
        }
        if !self.exprs.is_empty() {
            len += 1;
        }
        if !self.relations.is_empty() {
            len += 1;
        }
        if !self.stxcomment.is_empty() {
            len += 1;
        }
        if self.transformed {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateStatsStmt", len)?;
        if !self.defnames.is_empty() {
            struct_ser.serialize_field("defnames", &self.defnames)?;
        }
        if !self.stat_types.is_empty() {
            struct_ser.serialize_field("stat_types", &self.stat_types)?;
        }
        if !self.exprs.is_empty() {
            struct_ser.serialize_field("exprs", &self.exprs)?;
        }
        if !self.relations.is_empty() {
            struct_ser.serialize_field("relations", &self.relations)?;
        }
        if !self.stxcomment.is_empty() {
            struct_ser.serialize_field("stxcomment", &self.stxcomment)?;
        }
        if self.transformed {
            struct_ser.serialize_field("transformed", &self.transformed)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateStatsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "defnames",
            "stat_types",
            "exprs",
            "relations",
            "stxcomment",
            "transformed",
            "if_not_exists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Defnames,
            StatTypes,
            Exprs,
            Relations,
            Stxcomment,
            Transformed,
            IfNotExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "defnames" => Ok(GeneratedField::Defnames),
                            "stat_types" => Ok(GeneratedField::StatTypes),
                            "exprs" => Ok(GeneratedField::Exprs),
                            "relations" => Ok(GeneratedField::Relations),
                            "stxcomment" => Ok(GeneratedField::Stxcomment),
                            "transformed" => Ok(GeneratedField::Transformed),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateStatsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateStatsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateStatsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut defnames__ = None;
                let mut stat_types__ = None;
                let mut exprs__ = None;
                let mut relations__ = None;
                let mut stxcomment__ = None;
                let mut transformed__ = None;
                let mut if_not_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Defnames => {
                            if defnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defnames"));
                            }
                            defnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StatTypes => {
                            if stat_types__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stat_types"));
                            }
                            stat_types__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Exprs => {
                            if exprs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exprs"));
                            }
                            exprs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relations => {
                            if relations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relations"));
                            }
                            relations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Stxcomment => {
                            if stxcomment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stxcomment"));
                            }
                            stxcomment__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Transformed => {
                            if transformed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transformed"));
                            }
                            transformed__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateStatsStmt {
                    defnames: defnames__.unwrap_or_default(),
                    stat_types: stat_types__.unwrap_or_default(),
                    exprs: exprs__.unwrap_or_default(),
                    relations: relations__.unwrap_or_default(),
                    stxcomment: stxcomment__.unwrap_or_default(),
                    transformed: transformed__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateStatsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.table_elts.is_empty() {
            len += 1;
        }
        if !self.inh_relations.is_empty() {
            len += 1;
        }
        if self.partbound.is_some() {
            len += 1;
        }
        if self.partspec.is_some() {
            len += 1;
        }
        if self.of_typename.is_some() {
            len += 1;
        }
        if !self.constraints.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.oncommit != 0 {
            len += 1;
        }
        if !self.tablespacename.is_empty() {
            len += 1;
        }
        if !self.access_method.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.table_elts.is_empty() {
            struct_ser.serialize_field("tableElts", &self.table_elts)?;
        }
        if !self.inh_relations.is_empty() {
            struct_ser.serialize_field("inhRelations", &self.inh_relations)?;
        }
        if let Some(v) = self.partbound.as_ref() {
            struct_ser.serialize_field("partbound", v)?;
        }
        if let Some(v) = self.partspec.as_ref() {
            struct_ser.serialize_field("partspec", v)?;
        }
        if let Some(v) = self.of_typename.as_ref() {
            struct_ser.serialize_field("ofTypename", v)?;
        }
        if !self.constraints.is_empty() {
            struct_ser.serialize_field("constraints", &self.constraints)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.oncommit != 0 {
            let v = OnCommitAction::try_from(self.oncommit)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.oncommit)))?;
            struct_ser.serialize_field("oncommit", &v)?;
        }
        if !self.tablespacename.is_empty() {
            struct_ser.serialize_field("tablespacename", &self.tablespacename)?;
        }
        if !self.access_method.is_empty() {
            struct_ser.serialize_field("accessMethod", &self.access_method)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "table_elts",
            "tableElts",
            "inh_relations",
            "inhRelations",
            "partbound",
            "partspec",
            "of_typename",
            "ofTypename",
            "constraints",
            "options",
            "oncommit",
            "tablespacename",
            "access_method",
            "accessMethod",
            "if_not_exists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            TableElts,
            InhRelations,
            Partbound,
            Partspec,
            OfTypename,
            Constraints,
            Options,
            Oncommit,
            Tablespacename,
            AccessMethod,
            IfNotExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "tableElts" | "table_elts" => Ok(GeneratedField::TableElts),
                            "inhRelations" | "inh_relations" => Ok(GeneratedField::InhRelations),
                            "partbound" => Ok(GeneratedField::Partbound),
                            "partspec" => Ok(GeneratedField::Partspec),
                            "ofTypename" | "of_typename" => Ok(GeneratedField::OfTypename),
                            "constraints" => Ok(GeneratedField::Constraints),
                            "options" => Ok(GeneratedField::Options),
                            "oncommit" => Ok(GeneratedField::Oncommit),
                            "tablespacename" => Ok(GeneratedField::Tablespacename),
                            "accessMethod" | "access_method" => Ok(GeneratedField::AccessMethod),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut table_elts__ = None;
                let mut inh_relations__ = None;
                let mut partbound__ = None;
                let mut partspec__ = None;
                let mut of_typename__ = None;
                let mut constraints__ = None;
                let mut options__ = None;
                let mut oncommit__ = None;
                let mut tablespacename__ = None;
                let mut access_method__ = None;
                let mut if_not_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::TableElts => {
                            if table_elts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableElts"));
                            }
                            table_elts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InhRelations => {
                            if inh_relations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inhRelations"));
                            }
                            inh_relations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Partbound => {
                            if partbound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partbound"));
                            }
                            partbound__ = map_.next_value()?;
                        }
                        GeneratedField::Partspec => {
                            if partspec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partspec"));
                            }
                            partspec__ = map_.next_value()?;
                        }
                        GeneratedField::OfTypename => {
                            if of_typename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ofTypename"));
                            }
                            of_typename__ = map_.next_value()?;
                        }
                        GeneratedField::Constraints => {
                            if constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraints"));
                            }
                            constraints__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Oncommit => {
                            if oncommit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oncommit"));
                            }
                            oncommit__ = Some(map_.next_value::<OnCommitAction>()? as i32);
                        }
                        GeneratedField::Tablespacename => {
                            if tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablespacename"));
                            }
                            tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AccessMethod => {
                            if access_method__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessMethod"));
                            }
                            access_method__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateStmt {
                    relation: relation__,
                    table_elts: table_elts__.unwrap_or_default(),
                    inh_relations: inh_relations__.unwrap_or_default(),
                    partbound: partbound__,
                    partspec: partspec__,
                    of_typename: of_typename__,
                    constraints: constraints__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    oncommit: oncommit__.unwrap_or_default(),
                    tablespacename: tablespacename__.unwrap_or_default(),
                    access_method: access_method__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateSubscriptionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subname.is_empty() {
            len += 1;
        }
        if !self.conninfo.is_empty() {
            len += 1;
        }
        if !self.publication.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateSubscriptionStmt", len)?;
        if !self.subname.is_empty() {
            struct_ser.serialize_field("subname", &self.subname)?;
        }
        if !self.conninfo.is_empty() {
            struct_ser.serialize_field("conninfo", &self.conninfo)?;
        }
        if !self.publication.is_empty() {
            struct_ser.serialize_field("publication", &self.publication)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateSubscriptionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subname",
            "conninfo",
            "publication",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Subname,
            Conninfo,
            Publication,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subname" => Ok(GeneratedField::Subname),
                            "conninfo" => Ok(GeneratedField::Conninfo),
                            "publication" => Ok(GeneratedField::Publication),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateSubscriptionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateSubscriptionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateSubscriptionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subname__ = None;
                let mut conninfo__ = None;
                let mut publication__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Subname => {
                            if subname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subname"));
                            }
                            subname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Conninfo => {
                            if conninfo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conninfo"));
                            }
                            conninfo__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Publication => {
                            if publication__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publication"));
                            }
                            publication__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateSubscriptionStmt {
                    subname: subname__.unwrap_or_default(),
                    conninfo: conninfo__.unwrap_or_default(),
                    publication: publication__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateSubscriptionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateTableAsStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.query.is_some() {
            len += 1;
        }
        if self.into.is_some() {
            len += 1;
        }
        if self.objtype != 0 {
            len += 1;
        }
        if self.is_select_into {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateTableAsStmt", len)?;
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        if let Some(v) = self.into.as_ref() {
            struct_ser.serialize_field("into", v)?;
        }
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if self.is_select_into {
            struct_ser.serialize_field("is_select_into", &self.is_select_into)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateTableAsStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "query",
            "into",
            "objtype",
            "is_select_into",
            "if_not_exists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Query,
            Into,
            Objtype,
            IsSelectInto,
            IfNotExists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "query" => Ok(GeneratedField::Query),
                            "into" => Ok(GeneratedField::Into),
                            "objtype" => Ok(GeneratedField::Objtype),
                            "is_select_into" => Ok(GeneratedField::IsSelectInto),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateTableAsStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateTableAsStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateTableAsStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut query__ = None;
                let mut into__ = None;
                let mut objtype__ = None;
                let mut is_select_into__ = None;
                let mut if_not_exists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                        GeneratedField::Into => {
                            if into__.is_some() {
                                return Err(serde::de::Error::duplicate_field("into"));
                            }
                            into__ = map_.next_value()?;
                        }
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::IsSelectInto => {
                            if is_select_into__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_select_into"));
                            }
                            is_select_into__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateTableAsStmt {
                    query: query__,
                    into: into__,
                    objtype: objtype__.unwrap_or_default(),
                    is_select_into: is_select_into__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateTableAsStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateTableSpaceStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.tablespacename.is_empty() {
            len += 1;
        }
        if self.owner.is_some() {
            len += 1;
        }
        if !self.location.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateTableSpaceStmt", len)?;
        if !self.tablespacename.is_empty() {
            struct_ser.serialize_field("tablespacename", &self.tablespacename)?;
        }
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if !self.location.is_empty() {
            struct_ser.serialize_field("location", &self.location)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateTableSpaceStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tablespacename",
            "owner",
            "location",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tablespacename,
            Owner,
            Location,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tablespacename" => Ok(GeneratedField::Tablespacename),
                            "owner" => Ok(GeneratedField::Owner),
                            "location" => Ok(GeneratedField::Location),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateTableSpaceStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateTableSpaceStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateTableSpaceStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tablespacename__ = None;
                let mut owner__ = None;
                let mut location__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tablespacename => {
                            if tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablespacename"));
                            }
                            tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateTableSpaceStmt {
                    tablespacename: tablespacename__.unwrap_or_default(),
                    owner: owner__,
                    location: location__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateTableSpaceStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateTransformStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.replace {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if !self.lang.is_empty() {
            len += 1;
        }
        if self.fromsql.is_some() {
            len += 1;
        }
        if self.tosql.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateTransformStmt", len)?;
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("type_name", v)?;
        }
        if !self.lang.is_empty() {
            struct_ser.serialize_field("lang", &self.lang)?;
        }
        if let Some(v) = self.fromsql.as_ref() {
            struct_ser.serialize_field("fromsql", v)?;
        }
        if let Some(v) = self.tosql.as_ref() {
            struct_ser.serialize_field("tosql", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateTransformStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "replace",
            "type_name",
            "lang",
            "fromsql",
            "tosql",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Replace,
            TypeName,
            Lang,
            Fromsql,
            Tosql,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "replace" => Ok(GeneratedField::Replace),
                            "type_name" => Ok(GeneratedField::TypeName),
                            "lang" => Ok(GeneratedField::Lang),
                            "fromsql" => Ok(GeneratedField::Fromsql),
                            "tosql" => Ok(GeneratedField::Tosql),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateTransformStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateTransformStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateTransformStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut replace__ = None;
                let mut type_name__ = None;
                let mut lang__ = None;
                let mut fromsql__ = None;
                let mut tosql__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type_name"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::Lang => {
                            if lang__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lang"));
                            }
                            lang__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fromsql => {
                            if fromsql__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fromsql"));
                            }
                            fromsql__ = map_.next_value()?;
                        }
                        GeneratedField::Tosql => {
                            if tosql__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tosql"));
                            }
                            tosql__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CreateTransformStmt {
                    replace: replace__.unwrap_or_default(),
                    type_name: type_name__,
                    lang: lang__.unwrap_or_default(),
                    fromsql: fromsql__,
                    tosql: tosql__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateTransformStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateTrigStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.replace {
            len += 1;
        }
        if self.isconstraint {
            len += 1;
        }
        if !self.trigname.is_empty() {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if !self.funcname.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.row {
            len += 1;
        }
        if self.timing != 0 {
            len += 1;
        }
        if self.events != 0 {
            len += 1;
        }
        if !self.columns.is_empty() {
            len += 1;
        }
        if self.when_clause.is_some() {
            len += 1;
        }
        if !self.transition_rels.is_empty() {
            len += 1;
        }
        if self.deferrable {
            len += 1;
        }
        if self.initdeferred {
            len += 1;
        }
        if self.constrrel.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateTrigStmt", len)?;
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if self.isconstraint {
            struct_ser.serialize_field("isconstraint", &self.isconstraint)?;
        }
        if !self.trigname.is_empty() {
            struct_ser.serialize_field("trigname", &self.trigname)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.funcname.is_empty() {
            struct_ser.serialize_field("funcname", &self.funcname)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.row {
            struct_ser.serialize_field("row", &self.row)?;
        }
        if self.timing != 0 {
            struct_ser.serialize_field("timing", &self.timing)?;
        }
        if self.events != 0 {
            struct_ser.serialize_field("events", &self.events)?;
        }
        if !self.columns.is_empty() {
            struct_ser.serialize_field("columns", &self.columns)?;
        }
        if let Some(v) = self.when_clause.as_ref() {
            struct_ser.serialize_field("whenClause", v)?;
        }
        if !self.transition_rels.is_empty() {
            struct_ser.serialize_field("transitionRels", &self.transition_rels)?;
        }
        if self.deferrable {
            struct_ser.serialize_field("deferrable", &self.deferrable)?;
        }
        if self.initdeferred {
            struct_ser.serialize_field("initdeferred", &self.initdeferred)?;
        }
        if let Some(v) = self.constrrel.as_ref() {
            struct_ser.serialize_field("constrrel", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateTrigStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "replace",
            "isconstraint",
            "trigname",
            "relation",
            "funcname",
            "args",
            "row",
            "timing",
            "events",
            "columns",
            "when_clause",
            "whenClause",
            "transition_rels",
            "transitionRels",
            "deferrable",
            "initdeferred",
            "constrrel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Replace,
            Isconstraint,
            Trigname,
            Relation,
            Funcname,
            Args,
            Row,
            Timing,
            Events,
            Columns,
            WhenClause,
            TransitionRels,
            Deferrable,
            Initdeferred,
            Constrrel,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "replace" => Ok(GeneratedField::Replace),
                            "isconstraint" => Ok(GeneratedField::Isconstraint),
                            "trigname" => Ok(GeneratedField::Trigname),
                            "relation" => Ok(GeneratedField::Relation),
                            "funcname" => Ok(GeneratedField::Funcname),
                            "args" => Ok(GeneratedField::Args),
                            "row" => Ok(GeneratedField::Row),
                            "timing" => Ok(GeneratedField::Timing),
                            "events" => Ok(GeneratedField::Events),
                            "columns" => Ok(GeneratedField::Columns),
                            "whenClause" | "when_clause" => Ok(GeneratedField::WhenClause),
                            "transitionRels" | "transition_rels" => Ok(GeneratedField::TransitionRels),
                            "deferrable" => Ok(GeneratedField::Deferrable),
                            "initdeferred" => Ok(GeneratedField::Initdeferred),
                            "constrrel" => Ok(GeneratedField::Constrrel),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateTrigStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateTrigStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateTrigStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut replace__ = None;
                let mut isconstraint__ = None;
                let mut trigname__ = None;
                let mut relation__ = None;
                let mut funcname__ = None;
                let mut args__ = None;
                let mut row__ = None;
                let mut timing__ = None;
                let mut events__ = None;
                let mut columns__ = None;
                let mut when_clause__ = None;
                let mut transition_rels__ = None;
                let mut deferrable__ = None;
                let mut initdeferred__ = None;
                let mut constrrel__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Isconstraint => {
                            if isconstraint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isconstraint"));
                            }
                            isconstraint__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Trigname => {
                            if trigname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trigname"));
                            }
                            trigname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Funcname => {
                            if funcname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcname"));
                            }
                            funcname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Row => {
                            if row__.is_some() {
                                return Err(serde::de::Error::duplicate_field("row"));
                            }
                            row__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Timing => {
                            if timing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timing"));
                            }
                            timing__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Events => {
                            if events__.is_some() {
                                return Err(serde::de::Error::duplicate_field("events"));
                            }
                            events__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Columns => {
                            if columns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("columns"));
                            }
                            columns__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhenClause => {
                            if when_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whenClause"));
                            }
                            when_clause__ = map_.next_value()?;
                        }
                        GeneratedField::TransitionRels => {
                            if transition_rels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transitionRels"));
                            }
                            transition_rels__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deferrable => {
                            if deferrable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deferrable"));
                            }
                            deferrable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Initdeferred => {
                            if initdeferred__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initdeferred"));
                            }
                            initdeferred__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Constrrel => {
                            if constrrel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constrrel"));
                            }
                            constrrel__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CreateTrigStmt {
                    replace: replace__.unwrap_or_default(),
                    isconstraint: isconstraint__.unwrap_or_default(),
                    trigname: trigname__.unwrap_or_default(),
                    relation: relation__,
                    funcname: funcname__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    row: row__.unwrap_or_default(),
                    timing: timing__.unwrap_or_default(),
                    events: events__.unwrap_or_default(),
                    columns: columns__.unwrap_or_default(),
                    when_clause: when_clause__,
                    transition_rels: transition_rels__.unwrap_or_default(),
                    deferrable: deferrable__.unwrap_or_default(),
                    initdeferred: initdeferred__.unwrap_or_default(),
                    constrrel: constrrel__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateTrigStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreateUserMappingStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.user.is_some() {
            len += 1;
        }
        if !self.servername.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreateUserMappingStmt", len)?;
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreateUserMappingStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user",
            "servername",
            "if_not_exists",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            User,
            Servername,
            IfNotExists,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "user" => Ok(GeneratedField::User),
                            "servername" => Ok(GeneratedField::Servername),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateUserMappingStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreateUserMappingStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreateUserMappingStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user__ = None;
                let mut servername__ = None;
                let mut if_not_exists__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map_.next_value()?;
                        }
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateUserMappingStmt {
                    user: user__,
                    servername: servername__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreateUserMappingStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CreatedbStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dbname.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CreatedbStmt", len)?;
        if !self.dbname.is_empty() {
            struct_ser.serialize_field("dbname", &self.dbname)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CreatedbStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dbname",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dbname,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dbname" => Ok(GeneratedField::Dbname),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreatedbStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CreatedbStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CreatedbStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dbname__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dbname => {
                            if dbname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dbname"));
                            }
                            dbname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreatedbStmt {
                    dbname: dbname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CreatedbStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CurrentOfExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.cvarno != 0 {
            len += 1;
        }
        if !self.cursor_name.is_empty() {
            len += 1;
        }
        if self.cursor_param != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.CurrentOfExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.cvarno != 0 {
            struct_ser.serialize_field("cvarno", &self.cvarno)?;
        }
        if !self.cursor_name.is_empty() {
            struct_ser.serialize_field("cursor_name", &self.cursor_name)?;
        }
        if self.cursor_param != 0 {
            struct_ser.serialize_field("cursor_param", &self.cursor_param)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CurrentOfExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "cvarno",
            "cursor_name",
            "cursor_param",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Cvarno,
            CursorName,
            CursorParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "cvarno" => Ok(GeneratedField::Cvarno),
                            "cursor_name" => Ok(GeneratedField::CursorName),
                            "cursor_param" => Ok(GeneratedField::CursorParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CurrentOfExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.CurrentOfExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CurrentOfExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut cvarno__ = None;
                let mut cursor_name__ = None;
                let mut cursor_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Cvarno => {
                            if cvarno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cvarno"));
                            }
                            cvarno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CursorName => {
                            if cursor_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cursor_name"));
                            }
                            cursor_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CursorParam => {
                            if cursor_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cursor_param"));
                            }
                            cursor_param__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CurrentOfExpr {
                    xpr: xpr__,
                    cvarno: cvarno__.unwrap_or_default(),
                    cursor_name: cursor_name__.unwrap_or_default(),
                    cursor_param: cursor_param__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.CurrentOfExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeallocateStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DeallocateStmt", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeallocateStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeallocateStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DeallocateStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeallocateStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DeallocateStmt {
                    name: name__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DeallocateStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeclareCursorStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.portalname.is_empty() {
            len += 1;
        }
        if self.options != 0 {
            len += 1;
        }
        if self.query.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DeclareCursorStmt", len)?;
        if !self.portalname.is_empty() {
            struct_ser.serialize_field("portalname", &self.portalname)?;
        }
        if self.options != 0 {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeclareCursorStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "portalname",
            "options",
            "query",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Portalname,
            Options,
            Query,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "portalname" => Ok(GeneratedField::Portalname),
                            "options" => Ok(GeneratedField::Options),
                            "query" => Ok(GeneratedField::Query),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeclareCursorStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DeclareCursorStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeclareCursorStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut portalname__ = None;
                let mut options__ = None;
                let mut query__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Portalname => {
                            if portalname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portalname"));
                            }
                            portalname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DeclareCursorStmt {
                    portalname: portalname__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    query: query__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DeclareCursorStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DefElem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.defnamespace.is_empty() {
            len += 1;
        }
        if !self.defname.is_empty() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.defaction != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DefElem", len)?;
        if !self.defnamespace.is_empty() {
            struct_ser.serialize_field("defnamespace", &self.defnamespace)?;
        }
        if !self.defname.is_empty() {
            struct_ser.serialize_field("defname", &self.defname)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.defaction != 0 {
            let v = DefElemAction::try_from(self.defaction)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.defaction)))?;
            struct_ser.serialize_field("defaction", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DefElem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "defnamespace",
            "defname",
            "arg",
            "defaction",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Defnamespace,
            Defname,
            Arg,
            Defaction,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "defnamespace" => Ok(GeneratedField::Defnamespace),
                            "defname" => Ok(GeneratedField::Defname),
                            "arg" => Ok(GeneratedField::Arg),
                            "defaction" => Ok(GeneratedField::Defaction),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DefElem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DefElem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DefElem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut defnamespace__ = None;
                let mut defname__ = None;
                let mut arg__ = None;
                let mut defaction__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Defnamespace => {
                            if defnamespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defnamespace"));
                            }
                            defnamespace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Defname => {
                            if defname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defname"));
                            }
                            defname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Defaction => {
                            if defaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaction"));
                            }
                            defaction__ = Some(map_.next_value::<DefElemAction>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(DefElem {
                    defnamespace: defnamespace__.unwrap_or_default(),
                    defname: defname__.unwrap_or_default(),
                    arg: arg__,
                    defaction: defaction__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DefElem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DefElemAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "DEF_ELEM_ACTION_UNDEFINED",
            Self::DefelemUnspec => "DEFELEM_UNSPEC",
            Self::DefelemSet => "DEFELEM_SET",
            Self::DefelemAdd => "DEFELEM_ADD",
            Self::DefelemDrop => "DEFELEM_DROP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DefElemAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DEF_ELEM_ACTION_UNDEFINED",
            "DEFELEM_UNSPEC",
            "DEFELEM_SET",
            "DEFELEM_ADD",
            "DEFELEM_DROP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DefElemAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DEF_ELEM_ACTION_UNDEFINED" => Ok(DefElemAction::Undefined),
                    "DEFELEM_UNSPEC" => Ok(DefElemAction::DefelemUnspec),
                    "DEFELEM_SET" => Ok(DefElemAction::DefelemSet),
                    "DEFELEM_ADD" => Ok(DefElemAction::DefelemAdd),
                    "DEFELEM_DROP" => Ok(DefElemAction::DefelemDrop),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DefineStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if self.oldstyle {
            len += 1;
        }
        if !self.defnames.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if !self.definition.is_empty() {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        if self.replace {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DefineStmt", len)?;
        if self.kind != 0 {
            let v = ObjectType::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if self.oldstyle {
            struct_ser.serialize_field("oldstyle", &self.oldstyle)?;
        }
        if !self.defnames.is_empty() {
            struct_ser.serialize_field("defnames", &self.defnames)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if !self.definition.is_empty() {
            struct_ser.serialize_field("definition", &self.definition)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DefineStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "oldstyle",
            "defnames",
            "args",
            "definition",
            "if_not_exists",
            "replace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Oldstyle,
            Defnames,
            Args,
            Definition,
            IfNotExists,
            Replace,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "oldstyle" => Ok(GeneratedField::Oldstyle),
                            "defnames" => Ok(GeneratedField::Defnames),
                            "args" => Ok(GeneratedField::Args),
                            "definition" => Ok(GeneratedField::Definition),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            "replace" => Ok(GeneratedField::Replace),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DefineStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DefineStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DefineStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut oldstyle__ = None;
                let mut defnames__ = None;
                let mut args__ = None;
                let mut definition__ = None;
                let mut if_not_exists__ = None;
                let mut replace__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Oldstyle => {
                            if oldstyle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oldstyle"));
                            }
                            oldstyle__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Defnames => {
                            if defnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defnames"));
                            }
                            defnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Definition => {
                            if definition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("definition"));
                            }
                            definition__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DefineStmt {
                    kind: kind__.unwrap_or_default(),
                    oldstyle: oldstyle__.unwrap_or_default(),
                    defnames: defnames__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    definition: definition__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                    replace: replace__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DefineStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeleteStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.using_clause.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.returning_list.is_empty() {
            len += 1;
        }
        if self.with_clause.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DeleteStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.using_clause.is_empty() {
            struct_ser.serialize_field("usingClause", &self.using_clause)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.returning_list.is_empty() {
            struct_ser.serialize_field("returningList", &self.returning_list)?;
        }
        if let Some(v) = self.with_clause.as_ref() {
            struct_ser.serialize_field("withClause", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeleteStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "using_clause",
            "usingClause",
            "where_clause",
            "whereClause",
            "returning_list",
            "returningList",
            "with_clause",
            "withClause",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            UsingClause,
            WhereClause,
            ReturningList,
            WithClause,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "usingClause" | "using_clause" => Ok(GeneratedField::UsingClause),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "returningList" | "returning_list" => Ok(GeneratedField::ReturningList),
                            "withClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeleteStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DeleteStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeleteStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut using_clause__ = None;
                let mut where_clause__ = None;
                let mut returning_list__ = None;
                let mut with_clause__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::UsingClause => {
                            if using_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("usingClause"));
                            }
                            using_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::ReturningList => {
                            if returning_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returningList"));
                            }
                            returning_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithClause => {
                            if with_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withClause"));
                            }
                            with_clause__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DeleteStmt {
                    relation: relation__,
                    using_clause: using_clause__.unwrap_or_default(),
                    where_clause: where_clause__,
                    returning_list: returning_list__.unwrap_or_default(),
                    with_clause: with_clause__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DeleteStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DiscardMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "DISCARD_MODE_UNDEFINED",
            Self::DiscardAll => "DISCARD_ALL",
            Self::DiscardPlans => "DISCARD_PLANS",
            Self::DiscardSequences => "DISCARD_SEQUENCES",
            Self::DiscardTemp => "DISCARD_TEMP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DiscardMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DISCARD_MODE_UNDEFINED",
            "DISCARD_ALL",
            "DISCARD_PLANS",
            "DISCARD_SEQUENCES",
            "DISCARD_TEMP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DiscardMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DISCARD_MODE_UNDEFINED" => Ok(DiscardMode::Undefined),
                    "DISCARD_ALL" => Ok(DiscardMode::DiscardAll),
                    "DISCARD_PLANS" => Ok(DiscardMode::DiscardPlans),
                    "DISCARD_SEQUENCES" => Ok(DiscardMode::DiscardSequences),
                    "DISCARD_TEMP" => Ok(DiscardMode::DiscardTemp),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DiscardStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DiscardStmt", len)?;
        if self.target != 0 {
            let v = DiscardMode::try_from(self.target)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.target)))?;
            struct_ser.serialize_field("target", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DiscardStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "target",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Target,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "target" => Ok(GeneratedField::Target),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DiscardStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DiscardStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DiscardStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = Some(map_.next_value::<DiscardMode>()? as i32);
                        }
                    }
                }
                Ok(DiscardStmt {
                    target: target__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DiscardStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DistinctExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.opno != 0 {
            len += 1;
        }
        if self.opresulttype != 0 {
            len += 1;
        }
        if self.opretset {
            len += 1;
        }
        if self.opcollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DistinctExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.opno != 0 {
            struct_ser.serialize_field("opno", &self.opno)?;
        }
        if self.opresulttype != 0 {
            struct_ser.serialize_field("opresulttype", &self.opresulttype)?;
        }
        if self.opretset {
            struct_ser.serialize_field("opretset", &self.opretset)?;
        }
        if self.opcollid != 0 {
            struct_ser.serialize_field("opcollid", &self.opcollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DistinctExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "opno",
            "opresulttype",
            "opretset",
            "opcollid",
            "inputcollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Opno,
            Opresulttype,
            Opretset,
            Opcollid,
            Inputcollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "opno" => Ok(GeneratedField::Opno),
                            "opresulttype" => Ok(GeneratedField::Opresulttype),
                            "opretset" => Ok(GeneratedField::Opretset),
                            "opcollid" => Ok(GeneratedField::Opcollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DistinctExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DistinctExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DistinctExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut opno__ = None;
                let mut opresulttype__ = None;
                let mut opretset__ = None;
                let mut opcollid__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Opno => {
                            if opno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opno"));
                            }
                            opno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opresulttype => {
                            if opresulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opresulttype"));
                            }
                            opresulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opretset => {
                            if opretset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opretset"));
                            }
                            opretset__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opcollid => {
                            if opcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opcollid"));
                            }
                            opcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(DistinctExpr {
                    xpr: xpr__,
                    opno: opno__.unwrap_or_default(),
                    opresulttype: opresulttype__.unwrap_or_default(),
                    opretset: opretset__.unwrap_or_default(),
                    opcollid: opcollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DistinctExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DoStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.args.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DoStmt", len)?;
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DoStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "args",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Args,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "args" => Ok(GeneratedField::Args),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DoStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DoStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DoStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut args__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DoStmt {
                    args: args__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DoStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropBehavior {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "DROP_BEHAVIOR_UNDEFINED",
            Self::DropRestrict => "DROP_RESTRICT",
            Self::DropCascade => "DROP_CASCADE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DropBehavior {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DROP_BEHAVIOR_UNDEFINED",
            "DROP_RESTRICT",
            "DROP_CASCADE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropBehavior;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DROP_BEHAVIOR_UNDEFINED" => Ok(DropBehavior::Undefined),
                    "DROP_RESTRICT" => Ok(DropBehavior::DropRestrict),
                    "DROP_CASCADE" => Ok(DropBehavior::DropCascade),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DropOwnedStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.roles.is_empty() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropOwnedStmt", len)?;
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropOwnedStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "roles",
            "behavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Roles,
            Behavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "roles" => Ok(GeneratedField::Roles),
                            "behavior" => Ok(GeneratedField::Behavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropOwnedStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropOwnedStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropOwnedStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut roles__ = None;
                let mut behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                    }
                }
                Ok(DropOwnedStmt {
                    roles: roles__.unwrap_or_default(),
                    behavior: behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropOwnedStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropRoleStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.roles.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropRoleStmt", len)?;
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropRoleStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "roles",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Roles,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "roles" => Ok(GeneratedField::Roles),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropRoleStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropRoleStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropRoleStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut roles__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DropRoleStmt {
                    roles: roles__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropRoleStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        if self.remove_type != 0 {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        if self.concurrent {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropStmt", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        if self.remove_type != 0 {
            let v = ObjectType::try_from(self.remove_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.remove_type)))?;
            struct_ser.serialize_field("removeType", &v)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        if self.concurrent {
            struct_ser.serialize_field("concurrent", &self.concurrent)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
            "remove_type",
            "removeType",
            "behavior",
            "missing_ok",
            "concurrent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            RemoveType,
            Behavior,
            MissingOk,
            Concurrent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            "removeType" | "remove_type" => Ok(GeneratedField::RemoveType),
                            "behavior" => Ok(GeneratedField::Behavior),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            "concurrent" => Ok(GeneratedField::Concurrent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                let mut remove_type__ = None;
                let mut behavior__ = None;
                let mut missing_ok__ = None;
                let mut concurrent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RemoveType => {
                            if remove_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("removeType"));
                            }
                            remove_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Concurrent => {
                            if concurrent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("concurrent"));
                            }
                            concurrent__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DropStmt {
                    objects: objects__.unwrap_or_default(),
                    remove_type: remove_type__.unwrap_or_default(),
                    behavior: behavior__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                    concurrent: concurrent__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropSubscriptionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subname.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropSubscriptionStmt", len)?;
        if !self.subname.is_empty() {
            struct_ser.serialize_field("subname", &self.subname)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropSubscriptionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subname",
            "missing_ok",
            "behavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Subname,
            MissingOk,
            Behavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subname" => Ok(GeneratedField::Subname),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            "behavior" => Ok(GeneratedField::Behavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropSubscriptionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropSubscriptionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropSubscriptionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subname__ = None;
                let mut missing_ok__ = None;
                let mut behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Subname => {
                            if subname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subname"));
                            }
                            subname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                    }
                }
                Ok(DropSubscriptionStmt {
                    subname: subname__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                    behavior: behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropSubscriptionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropTableSpaceStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.tablespacename.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropTableSpaceStmt", len)?;
        if !self.tablespacename.is_empty() {
            struct_ser.serialize_field("tablespacename", &self.tablespacename)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropTableSpaceStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tablespacename",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tablespacename,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tablespacename" => Ok(GeneratedField::Tablespacename),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropTableSpaceStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropTableSpaceStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropTableSpaceStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tablespacename__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tablespacename => {
                            if tablespacename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablespacename"));
                            }
                            tablespacename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DropTableSpaceStmt {
                    tablespacename: tablespacename__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropTableSpaceStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropUserMappingStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.user.is_some() {
            len += 1;
        }
        if !self.servername.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropUserMappingStmt", len)?;
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if !self.servername.is_empty() {
            struct_ser.serialize_field("servername", &self.servername)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropUserMappingStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user",
            "servername",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            User,
            Servername,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "user" => Ok(GeneratedField::User),
                            "servername" => Ok(GeneratedField::Servername),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropUserMappingStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropUserMappingStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropUserMappingStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user__ = None;
                let mut servername__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map_.next_value()?;
                        }
                        GeneratedField::Servername => {
                            if servername__.is_some() {
                                return Err(serde::de::Error::duplicate_field("servername"));
                            }
                            servername__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DropUserMappingStmt {
                    user: user__,
                    servername: servername__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropUserMappingStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropdbStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dbname.is_empty() {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.DropdbStmt", len)?;
        if !self.dbname.is_empty() {
            struct_ser.serialize_field("dbname", &self.dbname)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropdbStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dbname",
            "missing_ok",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dbname,
            MissingOk,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dbname" => Ok(GeneratedField::Dbname),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropdbStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.DropdbStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropdbStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dbname__ = None;
                let mut missing_ok__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dbname => {
                            if dbname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dbname"));
                            }
                            dbname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DropdbStmt {
                    dbname: dbname__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.DropdbStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecuteStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ExecuteStmt", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.params.is_empty() {
            struct_ser.serialize_field("params", &self.params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecuteStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "params",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Params,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecuteStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ExecuteStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecuteStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ExecuteStmt {
                    name: name__.unwrap_or_default(),
                    params: params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ExecuteStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExplainStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.query.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ExplainStmt", len)?;
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExplainStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "query",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Query,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "query" => Ok(GeneratedField::Query),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExplainStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ExplainStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExplainStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut query__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ExplainStmt {
                    query: query__,
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ExplainStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FetchDirection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "FETCH_DIRECTION_UNDEFINED",
            Self::FetchForward => "FETCH_FORWARD",
            Self::FetchBackward => "FETCH_BACKWARD",
            Self::FetchAbsolute => "FETCH_ABSOLUTE",
            Self::FetchRelative => "FETCH_RELATIVE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for FetchDirection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FETCH_DIRECTION_UNDEFINED",
            "FETCH_FORWARD",
            "FETCH_BACKWARD",
            "FETCH_ABSOLUTE",
            "FETCH_RELATIVE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FetchDirection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FETCH_DIRECTION_UNDEFINED" => Ok(FetchDirection::Undefined),
                    "FETCH_FORWARD" => Ok(FetchDirection::FetchForward),
                    "FETCH_BACKWARD" => Ok(FetchDirection::FetchBackward),
                    "FETCH_ABSOLUTE" => Ok(FetchDirection::FetchAbsolute),
                    "FETCH_RELATIVE" => Ok(FetchDirection::FetchRelative),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for FetchStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.direction != 0 {
            len += 1;
        }
        if self.how_many != 0 {
            len += 1;
        }
        if !self.portalname.is_empty() {
            len += 1;
        }
        if self.ismove {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FetchStmt", len)?;
        if self.direction != 0 {
            let v = FetchDirection::try_from(self.direction)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.direction)))?;
            struct_ser.serialize_field("direction", &v)?;
        }
        if self.how_many != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("howMany", ToString::to_string(&self.how_many).as_str())?;
        }
        if !self.portalname.is_empty() {
            struct_ser.serialize_field("portalname", &self.portalname)?;
        }
        if self.ismove {
            struct_ser.serialize_field("ismove", &self.ismove)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FetchStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "direction",
            "how_many",
            "howMany",
            "portalname",
            "ismove",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Direction,
            HowMany,
            Portalname,
            Ismove,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "direction" => Ok(GeneratedField::Direction),
                            "howMany" | "how_many" => Ok(GeneratedField::HowMany),
                            "portalname" => Ok(GeneratedField::Portalname),
                            "ismove" => Ok(GeneratedField::Ismove),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FetchStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FetchStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FetchStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut direction__ = None;
                let mut how_many__ = None;
                let mut portalname__ = None;
                let mut ismove__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Direction => {
                            if direction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("direction"));
                            }
                            direction__ = Some(map_.next_value::<FetchDirection>()? as i32);
                        }
                        GeneratedField::HowMany => {
                            if how_many__.is_some() {
                                return Err(serde::de::Error::duplicate_field("howMany"));
                            }
                            how_many__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Portalname => {
                            if portalname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portalname"));
                            }
                            portalname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ismove => {
                            if ismove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ismove"));
                            }
                            ismove__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FetchStmt {
                    direction: direction__.unwrap_or_default(),
                    how_many: how_many__.unwrap_or_default(),
                    portalname: portalname__.unwrap_or_default(),
                    ismove: ismove__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FetchStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FieldSelect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.fieldnum != 0 {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.resulttypmod != 0 {
            len += 1;
        }
        if self.resultcollid != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FieldSelect", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.fieldnum != 0 {
            struct_ser.serialize_field("fieldnum", &self.fieldnum)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.resulttypmod != 0 {
            struct_ser.serialize_field("resulttypmod", &self.resulttypmod)?;
        }
        if self.resultcollid != 0 {
            struct_ser.serialize_field("resultcollid", &self.resultcollid)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FieldSelect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "fieldnum",
            "resulttype",
            "resulttypmod",
            "resultcollid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Fieldnum,
            Resulttype,
            Resulttypmod,
            Resultcollid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "fieldnum" => Ok(GeneratedField::Fieldnum),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "resulttypmod" => Ok(GeneratedField::Resulttypmod),
                            "resultcollid" => Ok(GeneratedField::Resultcollid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FieldSelect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FieldSelect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FieldSelect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut fieldnum__ = None;
                let mut resulttype__ = None;
                let mut resulttypmod__ = None;
                let mut resultcollid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Fieldnum => {
                            if fieldnum__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldnum"));
                            }
                            fieldnum__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resulttypmod => {
                            if resulttypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttypmod"));
                            }
                            resulttypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resultcollid => {
                            if resultcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultcollid"));
                            }
                            resultcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(FieldSelect {
                    xpr: xpr__,
                    arg: arg__,
                    fieldnum: fieldnum__.unwrap_or_default(),
                    resulttype: resulttype__.unwrap_or_default(),
                    resulttypmod: resulttypmod__.unwrap_or_default(),
                    resultcollid: resultcollid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FieldSelect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FieldStore {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if !self.newvals.is_empty() {
            len += 1;
        }
        if !self.fieldnums.is_empty() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FieldStore", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if !self.newvals.is_empty() {
            struct_ser.serialize_field("newvals", &self.newvals)?;
        }
        if !self.fieldnums.is_empty() {
            struct_ser.serialize_field("fieldnums", &self.fieldnums)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FieldStore {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "newvals",
            "fieldnums",
            "resulttype",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Newvals,
            Fieldnums,
            Resulttype,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "newvals" => Ok(GeneratedField::Newvals),
                            "fieldnums" => Ok(GeneratedField::Fieldnums),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FieldStore;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FieldStore")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FieldStore, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut newvals__ = None;
                let mut fieldnums__ = None;
                let mut resulttype__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Newvals => {
                            if newvals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newvals"));
                            }
                            newvals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fieldnums => {
                            if fieldnums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldnums"));
                            }
                            fieldnums__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(FieldStore {
                    xpr: xpr__,
                    arg: arg__,
                    newvals: newvals__.unwrap_or_default(),
                    fieldnums: fieldnums__.unwrap_or_default(),
                    resulttype: resulttype__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FieldStore", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Float {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fval.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Float", len)?;
        if !self.fval.is_empty() {
            struct_ser.serialize_field("fval", &self.fval)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Float {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fval" => Ok(GeneratedField::Fval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Float;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Float")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Float, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fval => {
                            if fval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fval"));
                            }
                            fval__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Float {
                    fval: fval__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Float", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FromExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fromlist.is_empty() {
            len += 1;
        }
        if self.quals.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FromExpr", len)?;
        if !self.fromlist.is_empty() {
            struct_ser.serialize_field("fromlist", &self.fromlist)?;
        }
        if let Some(v) = self.quals.as_ref() {
            struct_ser.serialize_field("quals", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FromExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fromlist",
            "quals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fromlist,
            Quals,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fromlist" => Ok(GeneratedField::Fromlist),
                            "quals" => Ok(GeneratedField::Quals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FromExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FromExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FromExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fromlist__ = None;
                let mut quals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fromlist => {
                            if fromlist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fromlist"));
                            }
                            fromlist__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quals => {
                            if quals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quals"));
                            }
                            quals__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FromExpr {
                    fromlist: fromlist__.unwrap_or_default(),
                    quals: quals__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FromExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FuncCall {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.funcname.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if !self.agg_order.is_empty() {
            len += 1;
        }
        if self.agg_filter.is_some() {
            len += 1;
        }
        if self.over.is_some() {
            len += 1;
        }
        if self.agg_within_group {
            len += 1;
        }
        if self.agg_star {
            len += 1;
        }
        if self.agg_distinct {
            len += 1;
        }
        if self.func_variadic {
            len += 1;
        }
        if self.funcformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FuncCall", len)?;
        if !self.funcname.is_empty() {
            struct_ser.serialize_field("funcname", &self.funcname)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if !self.agg_order.is_empty() {
            struct_ser.serialize_field("agg_order", &self.agg_order)?;
        }
        if let Some(v) = self.agg_filter.as_ref() {
            struct_ser.serialize_field("agg_filter", v)?;
        }
        if let Some(v) = self.over.as_ref() {
            struct_ser.serialize_field("over", v)?;
        }
        if self.agg_within_group {
            struct_ser.serialize_field("agg_within_group", &self.agg_within_group)?;
        }
        if self.agg_star {
            struct_ser.serialize_field("agg_star", &self.agg_star)?;
        }
        if self.agg_distinct {
            struct_ser.serialize_field("agg_distinct", &self.agg_distinct)?;
        }
        if self.func_variadic {
            struct_ser.serialize_field("func_variadic", &self.func_variadic)?;
        }
        if self.funcformat != 0 {
            let v = CoercionForm::try_from(self.funcformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.funcformat)))?;
            struct_ser.serialize_field("funcformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FuncCall {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "funcname",
            "args",
            "agg_order",
            "agg_filter",
            "over",
            "agg_within_group",
            "agg_star",
            "agg_distinct",
            "func_variadic",
            "funcformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Funcname,
            Args,
            AggOrder,
            AggFilter,
            Over,
            AggWithinGroup,
            AggStar,
            AggDistinct,
            FuncVariadic,
            Funcformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "funcname" => Ok(GeneratedField::Funcname),
                            "args" => Ok(GeneratedField::Args),
                            "agg_order" => Ok(GeneratedField::AggOrder),
                            "agg_filter" => Ok(GeneratedField::AggFilter),
                            "over" => Ok(GeneratedField::Over),
                            "agg_within_group" => Ok(GeneratedField::AggWithinGroup),
                            "agg_star" => Ok(GeneratedField::AggStar),
                            "agg_distinct" => Ok(GeneratedField::AggDistinct),
                            "func_variadic" => Ok(GeneratedField::FuncVariadic),
                            "funcformat" => Ok(GeneratedField::Funcformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FuncCall;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FuncCall")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FuncCall, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut funcname__ = None;
                let mut args__ = None;
                let mut agg_order__ = None;
                let mut agg_filter__ = None;
                let mut over__ = None;
                let mut agg_within_group__ = None;
                let mut agg_star__ = None;
                let mut agg_distinct__ = None;
                let mut func_variadic__ = None;
                let mut funcformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Funcname => {
                            if funcname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcname"));
                            }
                            funcname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggOrder => {
                            if agg_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_order"));
                            }
                            agg_order__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggFilter => {
                            if agg_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_filter"));
                            }
                            agg_filter__ = map_.next_value()?;
                        }
                        GeneratedField::Over => {
                            if over__.is_some() {
                                return Err(serde::de::Error::duplicate_field("over"));
                            }
                            over__ = map_.next_value()?;
                        }
                        GeneratedField::AggWithinGroup => {
                            if agg_within_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_within_group"));
                            }
                            agg_within_group__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggStar => {
                            if agg_star__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_star"));
                            }
                            agg_star__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggDistinct => {
                            if agg_distinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_distinct"));
                            }
                            agg_distinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FuncVariadic => {
                            if func_variadic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func_variadic"));
                            }
                            func_variadic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcformat => {
                            if funcformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcformat"));
                            }
                            funcformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(FuncCall {
                    funcname: funcname__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    agg_order: agg_order__.unwrap_or_default(),
                    agg_filter: agg_filter__,
                    over: over__,
                    agg_within_group: agg_within_group__.unwrap_or_default(),
                    agg_star: agg_star__.unwrap_or_default(),
                    agg_distinct: agg_distinct__.unwrap_or_default(),
                    func_variadic: func_variadic__.unwrap_or_default(),
                    funcformat: funcformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FuncCall", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FuncExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.funcid != 0 {
            len += 1;
        }
        if self.funcresulttype != 0 {
            len += 1;
        }
        if self.funcretset {
            len += 1;
        }
        if self.funcvariadic {
            len += 1;
        }
        if self.funcformat != 0 {
            len += 1;
        }
        if self.funccollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FuncExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.funcid != 0 {
            struct_ser.serialize_field("funcid", &self.funcid)?;
        }
        if self.funcresulttype != 0 {
            struct_ser.serialize_field("funcresulttype", &self.funcresulttype)?;
        }
        if self.funcretset {
            struct_ser.serialize_field("funcretset", &self.funcretset)?;
        }
        if self.funcvariadic {
            struct_ser.serialize_field("funcvariadic", &self.funcvariadic)?;
        }
        if self.funcformat != 0 {
            let v = CoercionForm::try_from(self.funcformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.funcformat)))?;
            struct_ser.serialize_field("funcformat", &v)?;
        }
        if self.funccollid != 0 {
            struct_ser.serialize_field("funccollid", &self.funccollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FuncExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "funcid",
            "funcresulttype",
            "funcretset",
            "funcvariadic",
            "funcformat",
            "funccollid",
            "inputcollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Funcid,
            Funcresulttype,
            Funcretset,
            Funcvariadic,
            Funcformat,
            Funccollid,
            Inputcollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "funcid" => Ok(GeneratedField::Funcid),
                            "funcresulttype" => Ok(GeneratedField::Funcresulttype),
                            "funcretset" => Ok(GeneratedField::Funcretset),
                            "funcvariadic" => Ok(GeneratedField::Funcvariadic),
                            "funcformat" => Ok(GeneratedField::Funcformat),
                            "funccollid" => Ok(GeneratedField::Funccollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FuncExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FuncExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FuncExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut funcid__ = None;
                let mut funcresulttype__ = None;
                let mut funcretset__ = None;
                let mut funcvariadic__ = None;
                let mut funcformat__ = None;
                let mut funccollid__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Funcid => {
                            if funcid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcid"));
                            }
                            funcid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Funcresulttype => {
                            if funcresulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcresulttype"));
                            }
                            funcresulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Funcretset => {
                            if funcretset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcretset"));
                            }
                            funcretset__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcvariadic => {
                            if funcvariadic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcvariadic"));
                            }
                            funcvariadic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcformat => {
                            if funcformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcformat"));
                            }
                            funcformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Funccollid => {
                            if funccollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccollid"));
                            }
                            funccollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(FuncExpr {
                    xpr: xpr__,
                    funcid: funcid__.unwrap_or_default(),
                    funcresulttype: funcresulttype__.unwrap_or_default(),
                    funcretset: funcretset__.unwrap_or_default(),
                    funcvariadic: funcvariadic__.unwrap_or_default(),
                    funcformat: funcformat__.unwrap_or_default(),
                    funccollid: funccollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FuncExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionParameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.arg_type.is_some() {
            len += 1;
        }
        if self.mode != 0 {
            len += 1;
        }
        if self.defexpr.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.FunctionParameter", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.arg_type.as_ref() {
            struct_ser.serialize_field("argType", v)?;
        }
        if self.mode != 0 {
            let v = FunctionParameterMode::try_from(self.mode)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.mode)))?;
            struct_ser.serialize_field("mode", &v)?;
        }
        if let Some(v) = self.defexpr.as_ref() {
            struct_ser.serialize_field("defexpr", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionParameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "arg_type",
            "argType",
            "mode",
            "defexpr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            ArgType,
            Mode,
            Defexpr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "argType" | "arg_type" => Ok(GeneratedField::ArgType),
                            "mode" => Ok(GeneratedField::Mode),
                            "defexpr" => Ok(GeneratedField::Defexpr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionParameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.FunctionParameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionParameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut arg_type__ = None;
                let mut mode__ = None;
                let mut defexpr__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ArgType => {
                            if arg_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argType"));
                            }
                            arg_type__ = map_.next_value()?;
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = Some(map_.next_value::<FunctionParameterMode>()? as i32);
                        }
                        GeneratedField::Defexpr => {
                            if defexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defexpr"));
                            }
                            defexpr__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FunctionParameter {
                    name: name__.unwrap_or_default(),
                    arg_type: arg_type__,
                    mode: mode__.unwrap_or_default(),
                    defexpr: defexpr__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.FunctionParameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionParameterMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "FUNCTION_PARAMETER_MODE_UNDEFINED",
            Self::FuncParamIn => "FUNC_PARAM_IN",
            Self::FuncParamOut => "FUNC_PARAM_OUT",
            Self::FuncParamInout => "FUNC_PARAM_INOUT",
            Self::FuncParamVariadic => "FUNC_PARAM_VARIADIC",
            Self::FuncParamTable => "FUNC_PARAM_TABLE",
            Self::FuncParamDefault => "FUNC_PARAM_DEFAULT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for FunctionParameterMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FUNCTION_PARAMETER_MODE_UNDEFINED",
            "FUNC_PARAM_IN",
            "FUNC_PARAM_OUT",
            "FUNC_PARAM_INOUT",
            "FUNC_PARAM_VARIADIC",
            "FUNC_PARAM_TABLE",
            "FUNC_PARAM_DEFAULT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionParameterMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FUNCTION_PARAMETER_MODE_UNDEFINED" => Ok(FunctionParameterMode::Undefined),
                    "FUNC_PARAM_IN" => Ok(FunctionParameterMode::FuncParamIn),
                    "FUNC_PARAM_OUT" => Ok(FunctionParameterMode::FuncParamOut),
                    "FUNC_PARAM_INOUT" => Ok(FunctionParameterMode::FuncParamInout),
                    "FUNC_PARAM_VARIADIC" => Ok(FunctionParameterMode::FuncParamVariadic),
                    "FUNC_PARAM_TABLE" => Ok(FunctionParameterMode::FuncParamTable),
                    "FUNC_PARAM_DEFAULT" => Ok(FunctionParameterMode::FuncParamDefault),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GrantRoleStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granted_roles.is_empty() {
            len += 1;
        }
        if !self.grantee_roles.is_empty() {
            len += 1;
        }
        if self.is_grant {
            len += 1;
        }
        if !self.opt.is_empty() {
            len += 1;
        }
        if self.grantor.is_some() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.GrantRoleStmt", len)?;
        if !self.granted_roles.is_empty() {
            struct_ser.serialize_field("granted_roles", &self.granted_roles)?;
        }
        if !self.grantee_roles.is_empty() {
            struct_ser.serialize_field("grantee_roles", &self.grantee_roles)?;
        }
        if self.is_grant {
            struct_ser.serialize_field("is_grant", &self.is_grant)?;
        }
        if !self.opt.is_empty() {
            struct_ser.serialize_field("opt", &self.opt)?;
        }
        if let Some(v) = self.grantor.as_ref() {
            struct_ser.serialize_field("grantor", v)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GrantRoleStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "granted_roles",
            "grantee_roles",
            "is_grant",
            "opt",
            "grantor",
            "behavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GrantedRoles,
            GranteeRoles,
            IsGrant,
            Opt,
            Grantor,
            Behavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granted_roles" => Ok(GeneratedField::GrantedRoles),
                            "grantee_roles" => Ok(GeneratedField::GranteeRoles),
                            "is_grant" => Ok(GeneratedField::IsGrant),
                            "opt" => Ok(GeneratedField::Opt),
                            "grantor" => Ok(GeneratedField::Grantor),
                            "behavior" => Ok(GeneratedField::Behavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GrantRoleStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.GrantRoleStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GrantRoleStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut granted_roles__ = None;
                let mut grantee_roles__ = None;
                let mut is_grant__ = None;
                let mut opt__ = None;
                let mut grantor__ = None;
                let mut behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GrantedRoles => {
                            if granted_roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granted_roles"));
                            }
                            granted_roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GranteeRoles => {
                            if grantee_roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee_roles"));
                            }
                            grantee_roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsGrant => {
                            if is_grant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_grant"));
                            }
                            is_grant__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opt => {
                            if opt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opt"));
                            }
                            opt__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grantor => {
                            if grantor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantor"));
                            }
                            grantor__ = map_.next_value()?;
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                    }
                }
                Ok(GrantRoleStmt {
                    granted_roles: granted_roles__.unwrap_or_default(),
                    grantee_roles: grantee_roles__.unwrap_or_default(),
                    is_grant: is_grant__.unwrap_or_default(),
                    opt: opt__.unwrap_or_default(),
                    grantor: grantor__,
                    behavior: behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.GrantRoleStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GrantStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_grant {
            len += 1;
        }
        if self.targtype != 0 {
            len += 1;
        }
        if self.objtype != 0 {
            len += 1;
        }
        if !self.objects.is_empty() {
            len += 1;
        }
        if !self.privileges.is_empty() {
            len += 1;
        }
        if !self.grantees.is_empty() {
            len += 1;
        }
        if self.grant_option {
            len += 1;
        }
        if self.grantor.is_some() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.GrantStmt", len)?;
        if self.is_grant {
            struct_ser.serialize_field("is_grant", &self.is_grant)?;
        }
        if self.targtype != 0 {
            let v = GrantTargetType::try_from(self.targtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.targtype)))?;
            struct_ser.serialize_field("targtype", &v)?;
        }
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        if !self.privileges.is_empty() {
            struct_ser.serialize_field("privileges", &self.privileges)?;
        }
        if !self.grantees.is_empty() {
            struct_ser.serialize_field("grantees", &self.grantees)?;
        }
        if self.grant_option {
            struct_ser.serialize_field("grant_option", &self.grant_option)?;
        }
        if let Some(v) = self.grantor.as_ref() {
            struct_ser.serialize_field("grantor", v)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GrantStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_grant",
            "targtype",
            "objtype",
            "objects",
            "privileges",
            "grantees",
            "grant_option",
            "grantor",
            "behavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsGrant,
            Targtype,
            Objtype,
            Objects,
            Privileges,
            Grantees,
            GrantOption,
            Grantor,
            Behavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "is_grant" => Ok(GeneratedField::IsGrant),
                            "targtype" => Ok(GeneratedField::Targtype),
                            "objtype" => Ok(GeneratedField::Objtype),
                            "objects" => Ok(GeneratedField::Objects),
                            "privileges" => Ok(GeneratedField::Privileges),
                            "grantees" => Ok(GeneratedField::Grantees),
                            "grant_option" => Ok(GeneratedField::GrantOption),
                            "grantor" => Ok(GeneratedField::Grantor),
                            "behavior" => Ok(GeneratedField::Behavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GrantStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.GrantStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GrantStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_grant__ = None;
                let mut targtype__ = None;
                let mut objtype__ = None;
                let mut objects__ = None;
                let mut privileges__ = None;
                let mut grantees__ = None;
                let mut grant_option__ = None;
                let mut grantor__ = None;
                let mut behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsGrant => {
                            if is_grant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_grant"));
                            }
                            is_grant__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Targtype => {
                            if targtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targtype"));
                            }
                            targtype__ = Some(map_.next_value::<GrantTargetType>()? as i32);
                        }
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Privileges => {
                            if privileges__.is_some() {
                                return Err(serde::de::Error::duplicate_field("privileges"));
                            }
                            privileges__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grantees => {
                            if grantees__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantees"));
                            }
                            grantees__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GrantOption => {
                            if grant_option__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grant_option"));
                            }
                            grant_option__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grantor => {
                            if grantor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantor"));
                            }
                            grantor__ = map_.next_value()?;
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                    }
                }
                Ok(GrantStmt {
                    is_grant: is_grant__.unwrap_or_default(),
                    targtype: targtype__.unwrap_or_default(),
                    objtype: objtype__.unwrap_or_default(),
                    objects: objects__.unwrap_or_default(),
                    privileges: privileges__.unwrap_or_default(),
                    grantees: grantees__.unwrap_or_default(),
                    grant_option: grant_option__.unwrap_or_default(),
                    grantor: grantor__,
                    behavior: behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.GrantStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GrantTargetType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "GRANT_TARGET_TYPE_UNDEFINED",
            Self::AclTargetObject => "ACL_TARGET_OBJECT",
            Self::AclTargetAllInSchema => "ACL_TARGET_ALL_IN_SCHEMA",
            Self::AclTargetDefaults => "ACL_TARGET_DEFAULTS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for GrantTargetType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GRANT_TARGET_TYPE_UNDEFINED",
            "ACL_TARGET_OBJECT",
            "ACL_TARGET_ALL_IN_SCHEMA",
            "ACL_TARGET_DEFAULTS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GrantTargetType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GRANT_TARGET_TYPE_UNDEFINED" => Ok(GrantTargetType::Undefined),
                    "ACL_TARGET_OBJECT" => Ok(GrantTargetType::AclTargetObject),
                    "ACL_TARGET_ALL_IN_SCHEMA" => Ok(GrantTargetType::AclTargetAllInSchema),
                    "ACL_TARGET_DEFAULTS" => Ok(GrantTargetType::AclTargetDefaults),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GroupingFunc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if !self.refs.is_empty() {
            len += 1;
        }
        if self.agglevelsup != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.GroupingFunc", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if !self.refs.is_empty() {
            struct_ser.serialize_field("refs", &self.refs)?;
        }
        if self.agglevelsup != 0 {
            struct_ser.serialize_field("agglevelsup", &self.agglevelsup)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GroupingFunc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "args",
            "refs",
            "agglevelsup",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Args,
            Refs,
            Agglevelsup,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "args" => Ok(GeneratedField::Args),
                            "refs" => Ok(GeneratedField::Refs),
                            "agglevelsup" => Ok(GeneratedField::Agglevelsup),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GroupingFunc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.GroupingFunc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GroupingFunc, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut args__ = None;
                let mut refs__ = None;
                let mut agglevelsup__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Refs => {
                            if refs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refs"));
                            }
                            refs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Agglevelsup => {
                            if agglevelsup__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agglevelsup"));
                            }
                            agglevelsup__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(GroupingFunc {
                    xpr: xpr__,
                    args: args__.unwrap_or_default(),
                    refs: refs__.unwrap_or_default(),
                    agglevelsup: agglevelsup__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.GroupingFunc", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GroupingSet {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.content.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.GroupingSet", len)?;
        if self.kind != 0 {
            let v = GroupingSetKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.content.is_empty() {
            struct_ser.serialize_field("content", &self.content)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GroupingSet {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "content",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Content,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "content" => Ok(GeneratedField::Content),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GroupingSet;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.GroupingSet")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GroupingSet, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut content__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<GroupingSetKind>()? as i32);
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(GroupingSet {
                    kind: kind__.unwrap_or_default(),
                    content: content__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.GroupingSet", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GroupingSetKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "GROUPING_SET_KIND_UNDEFINED",
            Self::GroupingSetEmpty => "GROUPING_SET_EMPTY",
            Self::GroupingSetSimple => "GROUPING_SET_SIMPLE",
            Self::GroupingSetRollup => "GROUPING_SET_ROLLUP",
            Self::GroupingSetCube => "GROUPING_SET_CUBE",
            Self::GroupingSetSets => "GROUPING_SET_SETS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for GroupingSetKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GROUPING_SET_KIND_UNDEFINED",
            "GROUPING_SET_EMPTY",
            "GROUPING_SET_SIMPLE",
            "GROUPING_SET_ROLLUP",
            "GROUPING_SET_CUBE",
            "GROUPING_SET_SETS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GroupingSetKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GROUPING_SET_KIND_UNDEFINED" => Ok(GroupingSetKind::Undefined),
                    "GROUPING_SET_EMPTY" => Ok(GroupingSetKind::GroupingSetEmpty),
                    "GROUPING_SET_SIMPLE" => Ok(GroupingSetKind::GroupingSetSimple),
                    "GROUPING_SET_ROLLUP" => Ok(GroupingSetKind::GroupingSetRollup),
                    "GROUPING_SET_CUBE" => Ok(GroupingSetKind::GroupingSetCube),
                    "GROUPING_SET_SETS" => Ok(GroupingSetKind::GroupingSetSets),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ImportForeignSchemaStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.server_name.is_empty() {
            len += 1;
        }
        if !self.remote_schema.is_empty() {
            len += 1;
        }
        if !self.local_schema.is_empty() {
            len += 1;
        }
        if self.list_type != 0 {
            len += 1;
        }
        if !self.table_list.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ImportForeignSchemaStmt", len)?;
        if !self.server_name.is_empty() {
            struct_ser.serialize_field("server_name", &self.server_name)?;
        }
        if !self.remote_schema.is_empty() {
            struct_ser.serialize_field("remote_schema", &self.remote_schema)?;
        }
        if !self.local_schema.is_empty() {
            struct_ser.serialize_field("local_schema", &self.local_schema)?;
        }
        if self.list_type != 0 {
            let v = ImportForeignSchemaType::try_from(self.list_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.list_type)))?;
            struct_ser.serialize_field("list_type", &v)?;
        }
        if !self.table_list.is_empty() {
            struct_ser.serialize_field("table_list", &self.table_list)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ImportForeignSchemaStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "server_name",
            "remote_schema",
            "local_schema",
            "list_type",
            "table_list",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ServerName,
            RemoteSchema,
            LocalSchema,
            ListType,
            TableList,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "server_name" => Ok(GeneratedField::ServerName),
                            "remote_schema" => Ok(GeneratedField::RemoteSchema),
                            "local_schema" => Ok(GeneratedField::LocalSchema),
                            "list_type" => Ok(GeneratedField::ListType),
                            "table_list" => Ok(GeneratedField::TableList),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ImportForeignSchemaStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ImportForeignSchemaStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ImportForeignSchemaStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut server_name__ = None;
                let mut remote_schema__ = None;
                let mut local_schema__ = None;
                let mut list_type__ = None;
                let mut table_list__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ServerName => {
                            if server_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("server_name"));
                            }
                            server_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RemoteSchema => {
                            if remote_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remote_schema"));
                            }
                            remote_schema__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LocalSchema => {
                            if local_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("local_schema"));
                            }
                            local_schema__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ListType => {
                            if list_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list_type"));
                            }
                            list_type__ = Some(map_.next_value::<ImportForeignSchemaType>()? as i32);
                        }
                        GeneratedField::TableList => {
                            if table_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("table_list"));
                            }
                            table_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ImportForeignSchemaStmt {
                    server_name: server_name__.unwrap_or_default(),
                    remote_schema: remote_schema__.unwrap_or_default(),
                    local_schema: local_schema__.unwrap_or_default(),
                    list_type: list_type__.unwrap_or_default(),
                    table_list: table_list__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ImportForeignSchemaStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ImportForeignSchemaType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED",
            Self::FdwImportSchemaAll => "FDW_IMPORT_SCHEMA_ALL",
            Self::FdwImportSchemaLimitTo => "FDW_IMPORT_SCHEMA_LIMIT_TO",
            Self::FdwImportSchemaExcept => "FDW_IMPORT_SCHEMA_EXCEPT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ImportForeignSchemaType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED",
            "FDW_IMPORT_SCHEMA_ALL",
            "FDW_IMPORT_SCHEMA_LIMIT_TO",
            "FDW_IMPORT_SCHEMA_EXCEPT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ImportForeignSchemaType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED" => Ok(ImportForeignSchemaType::Undefined),
                    "FDW_IMPORT_SCHEMA_ALL" => Ok(ImportForeignSchemaType::FdwImportSchemaAll),
                    "FDW_IMPORT_SCHEMA_LIMIT_TO" => Ok(ImportForeignSchemaType::FdwImportSchemaLimitTo),
                    "FDW_IMPORT_SCHEMA_EXCEPT" => Ok(ImportForeignSchemaType::FdwImportSchemaExcept),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for IndexElem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if !self.indexcolname.is_empty() {
            len += 1;
        }
        if !self.collation.is_empty() {
            len += 1;
        }
        if !self.opclass.is_empty() {
            len += 1;
        }
        if !self.opclassopts.is_empty() {
            len += 1;
        }
        if self.ordering != 0 {
            len += 1;
        }
        if self.nulls_ordering != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.IndexElem", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if !self.indexcolname.is_empty() {
            struct_ser.serialize_field("indexcolname", &self.indexcolname)?;
        }
        if !self.collation.is_empty() {
            struct_ser.serialize_field("collation", &self.collation)?;
        }
        if !self.opclass.is_empty() {
            struct_ser.serialize_field("opclass", &self.opclass)?;
        }
        if !self.opclassopts.is_empty() {
            struct_ser.serialize_field("opclassopts", &self.opclassopts)?;
        }
        if self.ordering != 0 {
            let v = SortByDir::try_from(self.ordering)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.ordering)))?;
            struct_ser.serialize_field("ordering", &v)?;
        }
        if self.nulls_ordering != 0 {
            let v = SortByNulls::try_from(self.nulls_ordering)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nulls_ordering)))?;
            struct_ser.serialize_field("nulls_ordering", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IndexElem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "expr",
            "indexcolname",
            "collation",
            "opclass",
            "opclassopts",
            "ordering",
            "nulls_ordering",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Expr,
            Indexcolname,
            Collation,
            Opclass,
            Opclassopts,
            Ordering,
            NullsOrdering,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "expr" => Ok(GeneratedField::Expr),
                            "indexcolname" => Ok(GeneratedField::Indexcolname),
                            "collation" => Ok(GeneratedField::Collation),
                            "opclass" => Ok(GeneratedField::Opclass),
                            "opclassopts" => Ok(GeneratedField::Opclassopts),
                            "ordering" => Ok(GeneratedField::Ordering),
                            "nulls_ordering" => Ok(GeneratedField::NullsOrdering),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IndexElem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.IndexElem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IndexElem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut expr__ = None;
                let mut indexcolname__ = None;
                let mut collation__ = None;
                let mut opclass__ = None;
                let mut opclassopts__ = None;
                let mut ordering__ = None;
                let mut nulls_ordering__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Indexcolname => {
                            if indexcolname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexcolname"));
                            }
                            indexcolname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Collation => {
                            if collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collation"));
                            }
                            collation__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opclass => {
                            if opclass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opclass"));
                            }
                            opclass__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opclassopts => {
                            if opclassopts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opclassopts"));
                            }
                            opclassopts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ordering => {
                            if ordering__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ordering"));
                            }
                            ordering__ = Some(map_.next_value::<SortByDir>()? as i32);
                        }
                        GeneratedField::NullsOrdering => {
                            if nulls_ordering__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nulls_ordering"));
                            }
                            nulls_ordering__ = Some(map_.next_value::<SortByNulls>()? as i32);
                        }
                    }
                }
                Ok(IndexElem {
                    name: name__.unwrap_or_default(),
                    expr: expr__,
                    indexcolname: indexcolname__.unwrap_or_default(),
                    collation: collation__.unwrap_or_default(),
                    opclass: opclass__.unwrap_or_default(),
                    opclassopts: opclassopts__.unwrap_or_default(),
                    ordering: ordering__.unwrap_or_default(),
                    nulls_ordering: nulls_ordering__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.IndexElem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IndexStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.idxname.is_empty() {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if !self.access_method.is_empty() {
            len += 1;
        }
        if !self.table_space.is_empty() {
            len += 1;
        }
        if !self.index_params.is_empty() {
            len += 1;
        }
        if !self.index_including_params.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.exclude_op_names.is_empty() {
            len += 1;
        }
        if !self.idxcomment.is_empty() {
            len += 1;
        }
        if self.index_oid != 0 {
            len += 1;
        }
        if self.old_number != 0 {
            len += 1;
        }
        if self.old_create_subid != 0 {
            len += 1;
        }
        if self.old_first_relfilelocator_subid != 0 {
            len += 1;
        }
        if self.unique {
            len += 1;
        }
        if self.nulls_not_distinct {
            len += 1;
        }
        if self.primary {
            len += 1;
        }
        if self.isconstraint {
            len += 1;
        }
        if self.deferrable {
            len += 1;
        }
        if self.initdeferred {
            len += 1;
        }
        if self.transformed {
            len += 1;
        }
        if self.concurrent {
            len += 1;
        }
        if self.if_not_exists {
            len += 1;
        }
        if self.reset_default_tblspc {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.IndexStmt", len)?;
        if !self.idxname.is_empty() {
            struct_ser.serialize_field("idxname", &self.idxname)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.access_method.is_empty() {
            struct_ser.serialize_field("accessMethod", &self.access_method)?;
        }
        if !self.table_space.is_empty() {
            struct_ser.serialize_field("tableSpace", &self.table_space)?;
        }
        if !self.index_params.is_empty() {
            struct_ser.serialize_field("indexParams", &self.index_params)?;
        }
        if !self.index_including_params.is_empty() {
            struct_ser.serialize_field("indexIncludingParams", &self.index_including_params)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.exclude_op_names.is_empty() {
            struct_ser.serialize_field("excludeOpNames", &self.exclude_op_names)?;
        }
        if !self.idxcomment.is_empty() {
            struct_ser.serialize_field("idxcomment", &self.idxcomment)?;
        }
        if self.index_oid != 0 {
            struct_ser.serialize_field("indexOid", &self.index_oid)?;
        }
        if self.old_number != 0 {
            struct_ser.serialize_field("oldNumber", &self.old_number)?;
        }
        if self.old_create_subid != 0 {
            struct_ser.serialize_field("oldCreateSubid", &self.old_create_subid)?;
        }
        if self.old_first_relfilelocator_subid != 0 {
            struct_ser.serialize_field("oldFirstRelfilelocatorSubid", &self.old_first_relfilelocator_subid)?;
        }
        if self.unique {
            struct_ser.serialize_field("unique", &self.unique)?;
        }
        if self.nulls_not_distinct {
            struct_ser.serialize_field("nulls_not_distinct", &self.nulls_not_distinct)?;
        }
        if self.primary {
            struct_ser.serialize_field("primary", &self.primary)?;
        }
        if self.isconstraint {
            struct_ser.serialize_field("isconstraint", &self.isconstraint)?;
        }
        if self.deferrable {
            struct_ser.serialize_field("deferrable", &self.deferrable)?;
        }
        if self.initdeferred {
            struct_ser.serialize_field("initdeferred", &self.initdeferred)?;
        }
        if self.transformed {
            struct_ser.serialize_field("transformed", &self.transformed)?;
        }
        if self.concurrent {
            struct_ser.serialize_field("concurrent", &self.concurrent)?;
        }
        if self.if_not_exists {
            struct_ser.serialize_field("if_not_exists", &self.if_not_exists)?;
        }
        if self.reset_default_tblspc {
            struct_ser.serialize_field("reset_default_tblspc", &self.reset_default_tblspc)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IndexStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "idxname",
            "relation",
            "access_method",
            "accessMethod",
            "table_space",
            "tableSpace",
            "index_params",
            "indexParams",
            "index_including_params",
            "indexIncludingParams",
            "options",
            "where_clause",
            "whereClause",
            "exclude_op_names",
            "excludeOpNames",
            "idxcomment",
            "index_oid",
            "indexOid",
            "old_number",
            "oldNumber",
            "old_create_subid",
            "oldCreateSubid",
            "old_first_relfilelocator_subid",
            "oldFirstRelfilelocatorSubid",
            "unique",
            "nulls_not_distinct",
            "primary",
            "isconstraint",
            "deferrable",
            "initdeferred",
            "transformed",
            "concurrent",
            "if_not_exists",
            "reset_default_tblspc",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Idxname,
            Relation,
            AccessMethod,
            TableSpace,
            IndexParams,
            IndexIncludingParams,
            Options,
            WhereClause,
            ExcludeOpNames,
            Idxcomment,
            IndexOid,
            OldNumber,
            OldCreateSubid,
            OldFirstRelfilelocatorSubid,
            Unique,
            NullsNotDistinct,
            Primary,
            Isconstraint,
            Deferrable,
            Initdeferred,
            Transformed,
            Concurrent,
            IfNotExists,
            ResetDefaultTblspc,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "idxname" => Ok(GeneratedField::Idxname),
                            "relation" => Ok(GeneratedField::Relation),
                            "accessMethod" | "access_method" => Ok(GeneratedField::AccessMethod),
                            "tableSpace" | "table_space" => Ok(GeneratedField::TableSpace),
                            "indexParams" | "index_params" => Ok(GeneratedField::IndexParams),
                            "indexIncludingParams" | "index_including_params" => Ok(GeneratedField::IndexIncludingParams),
                            "options" => Ok(GeneratedField::Options),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "excludeOpNames" | "exclude_op_names" => Ok(GeneratedField::ExcludeOpNames),
                            "idxcomment" => Ok(GeneratedField::Idxcomment),
                            "indexOid" | "index_oid" => Ok(GeneratedField::IndexOid),
                            "oldNumber" | "old_number" => Ok(GeneratedField::OldNumber),
                            "oldCreateSubid" | "old_create_subid" => Ok(GeneratedField::OldCreateSubid),
                            "oldFirstRelfilelocatorSubid" | "old_first_relfilelocator_subid" => Ok(GeneratedField::OldFirstRelfilelocatorSubid),
                            "unique" => Ok(GeneratedField::Unique),
                            "nulls_not_distinct" => Ok(GeneratedField::NullsNotDistinct),
                            "primary" => Ok(GeneratedField::Primary),
                            "isconstraint" => Ok(GeneratedField::Isconstraint),
                            "deferrable" => Ok(GeneratedField::Deferrable),
                            "initdeferred" => Ok(GeneratedField::Initdeferred),
                            "transformed" => Ok(GeneratedField::Transformed),
                            "concurrent" => Ok(GeneratedField::Concurrent),
                            "if_not_exists" => Ok(GeneratedField::IfNotExists),
                            "reset_default_tblspc" => Ok(GeneratedField::ResetDefaultTblspc),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IndexStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.IndexStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IndexStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut idxname__ = None;
                let mut relation__ = None;
                let mut access_method__ = None;
                let mut table_space__ = None;
                let mut index_params__ = None;
                let mut index_including_params__ = None;
                let mut options__ = None;
                let mut where_clause__ = None;
                let mut exclude_op_names__ = None;
                let mut idxcomment__ = None;
                let mut index_oid__ = None;
                let mut old_number__ = None;
                let mut old_create_subid__ = None;
                let mut old_first_relfilelocator_subid__ = None;
                let mut unique__ = None;
                let mut nulls_not_distinct__ = None;
                let mut primary__ = None;
                let mut isconstraint__ = None;
                let mut deferrable__ = None;
                let mut initdeferred__ = None;
                let mut transformed__ = None;
                let mut concurrent__ = None;
                let mut if_not_exists__ = None;
                let mut reset_default_tblspc__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Idxname => {
                            if idxname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("idxname"));
                            }
                            idxname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::AccessMethod => {
                            if access_method__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessMethod"));
                            }
                            access_method__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TableSpace => {
                            if table_space__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableSpace"));
                            }
                            table_space__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IndexParams => {
                            if index_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexParams"));
                            }
                            index_params__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IndexIncludingParams => {
                            if index_including_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexIncludingParams"));
                            }
                            index_including_params__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::ExcludeOpNames => {
                            if exclude_op_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("excludeOpNames"));
                            }
                            exclude_op_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Idxcomment => {
                            if idxcomment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("idxcomment"));
                            }
                            idxcomment__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IndexOid => {
                            if index_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexOid"));
                            }
                            index_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::OldNumber => {
                            if old_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oldNumber"));
                            }
                            old_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::OldCreateSubid => {
                            if old_create_subid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oldCreateSubid"));
                            }
                            old_create_subid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::OldFirstRelfilelocatorSubid => {
                            if old_first_relfilelocator_subid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oldFirstRelfilelocatorSubid"));
                            }
                            old_first_relfilelocator_subid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Unique => {
                            if unique__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unique"));
                            }
                            unique__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NullsNotDistinct => {
                            if nulls_not_distinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nulls_not_distinct"));
                            }
                            nulls_not_distinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Primary => {
                            if primary__.is_some() {
                                return Err(serde::de::Error::duplicate_field("primary"));
                            }
                            primary__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Isconstraint => {
                            if isconstraint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isconstraint"));
                            }
                            isconstraint__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deferrable => {
                            if deferrable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deferrable"));
                            }
                            deferrable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Initdeferred => {
                            if initdeferred__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initdeferred"));
                            }
                            initdeferred__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Transformed => {
                            if transformed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transformed"));
                            }
                            transformed__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Concurrent => {
                            if concurrent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("concurrent"));
                            }
                            concurrent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IfNotExists => {
                            if if_not_exists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if_not_exists"));
                            }
                            if_not_exists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ResetDefaultTblspc => {
                            if reset_default_tblspc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reset_default_tblspc"));
                            }
                            reset_default_tblspc__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(IndexStmt {
                    idxname: idxname__.unwrap_or_default(),
                    relation: relation__,
                    access_method: access_method__.unwrap_or_default(),
                    table_space: table_space__.unwrap_or_default(),
                    index_params: index_params__.unwrap_or_default(),
                    index_including_params: index_including_params__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    where_clause: where_clause__,
                    exclude_op_names: exclude_op_names__.unwrap_or_default(),
                    idxcomment: idxcomment__.unwrap_or_default(),
                    index_oid: index_oid__.unwrap_or_default(),
                    old_number: old_number__.unwrap_or_default(),
                    old_create_subid: old_create_subid__.unwrap_or_default(),
                    old_first_relfilelocator_subid: old_first_relfilelocator_subid__.unwrap_or_default(),
                    unique: unique__.unwrap_or_default(),
                    nulls_not_distinct: nulls_not_distinct__.unwrap_or_default(),
                    primary: primary__.unwrap_or_default(),
                    isconstraint: isconstraint__.unwrap_or_default(),
                    deferrable: deferrable__.unwrap_or_default(),
                    initdeferred: initdeferred__.unwrap_or_default(),
                    transformed: transformed__.unwrap_or_default(),
                    concurrent: concurrent__.unwrap_or_default(),
                    if_not_exists: if_not_exists__.unwrap_or_default(),
                    reset_default_tblspc: reset_default_tblspc__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.IndexStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InferClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.index_elems.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.conname.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.InferClause", len)?;
        if !self.index_elems.is_empty() {
            struct_ser.serialize_field("indexElems", &self.index_elems)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.conname.is_empty() {
            struct_ser.serialize_field("conname", &self.conname)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InferClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index_elems",
            "indexElems",
            "where_clause",
            "whereClause",
            "conname",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IndexElems,
            WhereClause,
            Conname,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "indexElems" | "index_elems" => Ok(GeneratedField::IndexElems),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "conname" => Ok(GeneratedField::Conname),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InferClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.InferClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InferClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index_elems__ = None;
                let mut where_clause__ = None;
                let mut conname__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IndexElems => {
                            if index_elems__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexElems"));
                            }
                            index_elems__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Conname => {
                            if conname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conname"));
                            }
                            conname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(InferClause {
                    index_elems: index_elems__.unwrap_or_default(),
                    where_clause: where_clause__,
                    conname: conname__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.InferClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InferenceElem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if self.infercollid != 0 {
            len += 1;
        }
        if self.inferopclass != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.InferenceElem", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if self.infercollid != 0 {
            struct_ser.serialize_field("infercollid", &self.infercollid)?;
        }
        if self.inferopclass != 0 {
            struct_ser.serialize_field("inferopclass", &self.inferopclass)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InferenceElem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "expr",
            "infercollid",
            "inferopclass",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Expr,
            Infercollid,
            Inferopclass,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "expr" => Ok(GeneratedField::Expr),
                            "infercollid" => Ok(GeneratedField::Infercollid),
                            "inferopclass" => Ok(GeneratedField::Inferopclass),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InferenceElem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.InferenceElem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InferenceElem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut expr__ = None;
                let mut infercollid__ = None;
                let mut inferopclass__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Infercollid => {
                            if infercollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("infercollid"));
                            }
                            infercollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inferopclass => {
                            if inferopclass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inferopclass"));
                            }
                            inferopclass__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(InferenceElem {
                    xpr: xpr__,
                    expr: expr__,
                    infercollid: infercollid__.unwrap_or_default(),
                    inferopclass: inferopclass__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.InferenceElem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InlineCodeBlock {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.source_text.is_empty() {
            len += 1;
        }
        if self.lang_oid != 0 {
            len += 1;
        }
        if self.lang_is_trusted {
            len += 1;
        }
        if self.atomic {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.InlineCodeBlock", len)?;
        if !self.source_text.is_empty() {
            struct_ser.serialize_field("source_text", &self.source_text)?;
        }
        if self.lang_oid != 0 {
            struct_ser.serialize_field("langOid", &self.lang_oid)?;
        }
        if self.lang_is_trusted {
            struct_ser.serialize_field("langIsTrusted", &self.lang_is_trusted)?;
        }
        if self.atomic {
            struct_ser.serialize_field("atomic", &self.atomic)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InlineCodeBlock {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "source_text",
            "lang_oid",
            "langOid",
            "lang_is_trusted",
            "langIsTrusted",
            "atomic",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SourceText,
            LangOid,
            LangIsTrusted,
            Atomic,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "source_text" => Ok(GeneratedField::SourceText),
                            "langOid" | "lang_oid" => Ok(GeneratedField::LangOid),
                            "langIsTrusted" | "lang_is_trusted" => Ok(GeneratedField::LangIsTrusted),
                            "atomic" => Ok(GeneratedField::Atomic),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InlineCodeBlock;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.InlineCodeBlock")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InlineCodeBlock, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut source_text__ = None;
                let mut lang_oid__ = None;
                let mut lang_is_trusted__ = None;
                let mut atomic__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SourceText => {
                            if source_text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source_text"));
                            }
                            source_text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LangOid => {
                            if lang_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("langOid"));
                            }
                            lang_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::LangIsTrusted => {
                            if lang_is_trusted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("langIsTrusted"));
                            }
                            lang_is_trusted__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Atomic => {
                            if atomic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("atomic"));
                            }
                            atomic__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(InlineCodeBlock {
                    source_text: source_text__.unwrap_or_default(),
                    lang_oid: lang_oid__.unwrap_or_default(),
                    lang_is_trusted: lang_is_trusted__.unwrap_or_default(),
                    atomic: atomic__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.InlineCodeBlock", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InsertStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.cols.is_empty() {
            len += 1;
        }
        if self.select_stmt.is_some() {
            len += 1;
        }
        if self.on_conflict_clause.is_some() {
            len += 1;
        }
        if !self.returning_list.is_empty() {
            len += 1;
        }
        if self.with_clause.is_some() {
            len += 1;
        }
        if self.r#override != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.InsertStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.cols.is_empty() {
            struct_ser.serialize_field("cols", &self.cols)?;
        }
        if let Some(v) = self.select_stmt.as_ref() {
            struct_ser.serialize_field("selectStmt", v)?;
        }
        if let Some(v) = self.on_conflict_clause.as_ref() {
            struct_ser.serialize_field("onConflictClause", v)?;
        }
        if !self.returning_list.is_empty() {
            struct_ser.serialize_field("returningList", &self.returning_list)?;
        }
        if let Some(v) = self.with_clause.as_ref() {
            struct_ser.serialize_field("withClause", v)?;
        }
        if self.r#override != 0 {
            let v = OverridingKind::try_from(self.r#override)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#override)))?;
            struct_ser.serialize_field("override", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InsertStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "cols",
            "select_stmt",
            "selectStmt",
            "on_conflict_clause",
            "onConflictClause",
            "returning_list",
            "returningList",
            "with_clause",
            "withClause",
            "override",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Cols,
            SelectStmt,
            OnConflictClause,
            ReturningList,
            WithClause,
            Override,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "cols" => Ok(GeneratedField::Cols),
                            "selectStmt" | "select_stmt" => Ok(GeneratedField::SelectStmt),
                            "onConflictClause" | "on_conflict_clause" => Ok(GeneratedField::OnConflictClause),
                            "returningList" | "returning_list" => Ok(GeneratedField::ReturningList),
                            "withClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            "override" => Ok(GeneratedField::Override),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InsertStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.InsertStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InsertStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut cols__ = None;
                let mut select_stmt__ = None;
                let mut on_conflict_clause__ = None;
                let mut returning_list__ = None;
                let mut with_clause__ = None;
                let mut r#override__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Cols => {
                            if cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cols"));
                            }
                            cols__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SelectStmt => {
                            if select_stmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectStmt"));
                            }
                            select_stmt__ = map_.next_value()?;
                        }
                        GeneratedField::OnConflictClause => {
                            if on_conflict_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onConflictClause"));
                            }
                            on_conflict_clause__ = map_.next_value()?;
                        }
                        GeneratedField::ReturningList => {
                            if returning_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returningList"));
                            }
                            returning_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithClause => {
                            if with_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withClause"));
                            }
                            with_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Override => {
                            if r#override__.is_some() {
                                return Err(serde::de::Error::duplicate_field("override"));
                            }
                            r#override__ = Some(map_.next_value::<OverridingKind>()? as i32);
                        }
                    }
                }
                Ok(InsertStmt {
                    relation: relation__,
                    cols: cols__.unwrap_or_default(),
                    select_stmt: select_stmt__,
                    on_conflict_clause: on_conflict_clause__,
                    returning_list: returning_list__.unwrap_or_default(),
                    with_clause: with_clause__,
                    r#override: r#override__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.InsertStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IntList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.IntList", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IntList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IntList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.IntList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IntList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(IntList {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.IntList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Integer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ival != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Integer", len)?;
        if self.ival != 0 {
            struct_ser.serialize_field("ival", &self.ival)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Integer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ival",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ival,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ival" => Ok(GeneratedField::Ival),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Integer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Integer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Integer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ival__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ival => {
                            if ival__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ival"));
                            }
                            ival__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Integer {
                    ival: ival__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Integer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IntoClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rel.is_some() {
            len += 1;
        }
        if !self.col_names.is_empty() {
            len += 1;
        }
        if !self.access_method.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.on_commit != 0 {
            len += 1;
        }
        if !self.table_space_name.is_empty() {
            len += 1;
        }
        if self.view_query.is_some() {
            len += 1;
        }
        if self.skip_data {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.IntoClause", len)?;
        if let Some(v) = self.rel.as_ref() {
            struct_ser.serialize_field("rel", v)?;
        }
        if !self.col_names.is_empty() {
            struct_ser.serialize_field("colNames", &self.col_names)?;
        }
        if !self.access_method.is_empty() {
            struct_ser.serialize_field("accessMethod", &self.access_method)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.on_commit != 0 {
            let v = OnCommitAction::try_from(self.on_commit)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.on_commit)))?;
            struct_ser.serialize_field("onCommit", &v)?;
        }
        if !self.table_space_name.is_empty() {
            struct_ser.serialize_field("tableSpaceName", &self.table_space_name)?;
        }
        if let Some(v) = self.view_query.as_ref() {
            struct_ser.serialize_field("viewQuery", v)?;
        }
        if self.skip_data {
            struct_ser.serialize_field("skipData", &self.skip_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IntoClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rel",
            "col_names",
            "colNames",
            "access_method",
            "accessMethod",
            "options",
            "on_commit",
            "onCommit",
            "table_space_name",
            "tableSpaceName",
            "view_query",
            "viewQuery",
            "skip_data",
            "skipData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rel,
            ColNames,
            AccessMethod,
            Options,
            OnCommit,
            TableSpaceName,
            ViewQuery,
            SkipData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rel" => Ok(GeneratedField::Rel),
                            "colNames" | "col_names" => Ok(GeneratedField::ColNames),
                            "accessMethod" | "access_method" => Ok(GeneratedField::AccessMethod),
                            "options" => Ok(GeneratedField::Options),
                            "onCommit" | "on_commit" => Ok(GeneratedField::OnCommit),
                            "tableSpaceName" | "table_space_name" => Ok(GeneratedField::TableSpaceName),
                            "viewQuery" | "view_query" => Ok(GeneratedField::ViewQuery),
                            "skipData" | "skip_data" => Ok(GeneratedField::SkipData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IntoClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.IntoClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IntoClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rel__ = None;
                let mut col_names__ = None;
                let mut access_method__ = None;
                let mut options__ = None;
                let mut on_commit__ = None;
                let mut table_space_name__ = None;
                let mut view_query__ = None;
                let mut skip_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rel => {
                            if rel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rel"));
                            }
                            rel__ = map_.next_value()?;
                        }
                        GeneratedField::ColNames => {
                            if col_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colNames"));
                            }
                            col_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AccessMethod => {
                            if access_method__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessMethod"));
                            }
                            access_method__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OnCommit => {
                            if on_commit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onCommit"));
                            }
                            on_commit__ = Some(map_.next_value::<OnCommitAction>()? as i32);
                        }
                        GeneratedField::TableSpaceName => {
                            if table_space_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableSpaceName"));
                            }
                            table_space_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ViewQuery => {
                            if view_query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("viewQuery"));
                            }
                            view_query__ = map_.next_value()?;
                        }
                        GeneratedField::SkipData => {
                            if skip_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skipData"));
                            }
                            skip_data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(IntoClause {
                    rel: rel__,
                    col_names: col_names__.unwrap_or_default(),
                    access_method: access_method__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    on_commit: on_commit__.unwrap_or_default(),
                    table_space_name: table_space_name__.unwrap_or_default(),
                    view_query: view_query__,
                    skip_data: skip_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.IntoClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JoinExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.jointype != 0 {
            len += 1;
        }
        if self.is_natural {
            len += 1;
        }
        if self.larg.is_some() {
            len += 1;
        }
        if self.rarg.is_some() {
            len += 1;
        }
        if !self.using_clause.is_empty() {
            len += 1;
        }
        if self.join_using_alias.is_some() {
            len += 1;
        }
        if self.quals.is_some() {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        if self.rtindex != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JoinExpr", len)?;
        if self.jointype != 0 {
            let v = JoinType::try_from(self.jointype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.jointype)))?;
            struct_ser.serialize_field("jointype", &v)?;
        }
        if self.is_natural {
            struct_ser.serialize_field("isNatural", &self.is_natural)?;
        }
        if let Some(v) = self.larg.as_ref() {
            struct_ser.serialize_field("larg", v)?;
        }
        if let Some(v) = self.rarg.as_ref() {
            struct_ser.serialize_field("rarg", v)?;
        }
        if !self.using_clause.is_empty() {
            struct_ser.serialize_field("usingClause", &self.using_clause)?;
        }
        if let Some(v) = self.join_using_alias.as_ref() {
            struct_ser.serialize_field("join_using_alias", v)?;
        }
        if let Some(v) = self.quals.as_ref() {
            struct_ser.serialize_field("quals", v)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        if self.rtindex != 0 {
            struct_ser.serialize_field("rtindex", &self.rtindex)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JoinExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "jointype",
            "is_natural",
            "isNatural",
            "larg",
            "rarg",
            "using_clause",
            "usingClause",
            "join_using_alias",
            "quals",
            "alias",
            "rtindex",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Jointype,
            IsNatural,
            Larg,
            Rarg,
            UsingClause,
            JoinUsingAlias,
            Quals,
            Alias,
            Rtindex,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "jointype" => Ok(GeneratedField::Jointype),
                            "isNatural" | "is_natural" => Ok(GeneratedField::IsNatural),
                            "larg" => Ok(GeneratedField::Larg),
                            "rarg" => Ok(GeneratedField::Rarg),
                            "usingClause" | "using_clause" => Ok(GeneratedField::UsingClause),
                            "join_using_alias" => Ok(GeneratedField::JoinUsingAlias),
                            "quals" => Ok(GeneratedField::Quals),
                            "alias" => Ok(GeneratedField::Alias),
                            "rtindex" => Ok(GeneratedField::Rtindex),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JoinExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JoinExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JoinExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut jointype__ = None;
                let mut is_natural__ = None;
                let mut larg__ = None;
                let mut rarg__ = None;
                let mut using_clause__ = None;
                let mut join_using_alias__ = None;
                let mut quals__ = None;
                let mut alias__ = None;
                let mut rtindex__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Jointype => {
                            if jointype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jointype"));
                            }
                            jointype__ = Some(map_.next_value::<JoinType>()? as i32);
                        }
                        GeneratedField::IsNatural => {
                            if is_natural__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isNatural"));
                            }
                            is_natural__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Larg => {
                            if larg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("larg"));
                            }
                            larg__ = map_.next_value()?;
                        }
                        GeneratedField::Rarg => {
                            if rarg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rarg"));
                            }
                            rarg__ = map_.next_value()?;
                        }
                        GeneratedField::UsingClause => {
                            if using_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("usingClause"));
                            }
                            using_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::JoinUsingAlias => {
                            if join_using_alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("join_using_alias"));
                            }
                            join_using_alias__ = map_.next_value()?;
                        }
                        GeneratedField::Quals => {
                            if quals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quals"));
                            }
                            quals__ = map_.next_value()?;
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                        GeneratedField::Rtindex => {
                            if rtindex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rtindex"));
                            }
                            rtindex__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JoinExpr {
                    jointype: jointype__.unwrap_or_default(),
                    is_natural: is_natural__.unwrap_or_default(),
                    larg: larg__,
                    rarg: rarg__,
                    using_clause: using_clause__.unwrap_or_default(),
                    join_using_alias: join_using_alias__,
                    quals: quals__,
                    alias: alias__,
                    rtindex: rtindex__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JoinExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JoinType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "JOIN_TYPE_UNDEFINED",
            Self::JoinInner => "JOIN_INNER",
            Self::JoinLeft => "JOIN_LEFT",
            Self::JoinFull => "JOIN_FULL",
            Self::JoinRight => "JOIN_RIGHT",
            Self::JoinSemi => "JOIN_SEMI",
            Self::JoinAnti => "JOIN_ANTI",
            Self::JoinRightAnti => "JOIN_RIGHT_ANTI",
            Self::JoinUniqueOuter => "JOIN_UNIQUE_OUTER",
            Self::JoinUniqueInner => "JOIN_UNIQUE_INNER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for JoinType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JOIN_TYPE_UNDEFINED",
            "JOIN_INNER",
            "JOIN_LEFT",
            "JOIN_FULL",
            "JOIN_RIGHT",
            "JOIN_SEMI",
            "JOIN_ANTI",
            "JOIN_RIGHT_ANTI",
            "JOIN_UNIQUE_OUTER",
            "JOIN_UNIQUE_INNER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JoinType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JOIN_TYPE_UNDEFINED" => Ok(JoinType::Undefined),
                    "JOIN_INNER" => Ok(JoinType::JoinInner),
                    "JOIN_LEFT" => Ok(JoinType::JoinLeft),
                    "JOIN_FULL" => Ok(JoinType::JoinFull),
                    "JOIN_RIGHT" => Ok(JoinType::JoinRight),
                    "JOIN_SEMI" => Ok(JoinType::JoinSemi),
                    "JOIN_ANTI" => Ok(JoinType::JoinAnti),
                    "JOIN_RIGHT_ANTI" => Ok(JoinType::JoinRightAnti),
                    "JOIN_UNIQUE_OUTER" => Ok(JoinType::JoinUniqueOuter),
                    "JOIN_UNIQUE_INNER" => Ok(JoinType::JoinUniqueInner),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for JsonAggConstructor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.output.is_some() {
            len += 1;
        }
        if self.agg_filter.is_some() {
            len += 1;
        }
        if !self.agg_order.is_empty() {
            len += 1;
        }
        if self.over.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonAggConstructor", len)?;
        if let Some(v) = self.output.as_ref() {
            struct_ser.serialize_field("output", v)?;
        }
        if let Some(v) = self.agg_filter.as_ref() {
            struct_ser.serialize_field("agg_filter", v)?;
        }
        if !self.agg_order.is_empty() {
            struct_ser.serialize_field("agg_order", &self.agg_order)?;
        }
        if let Some(v) = self.over.as_ref() {
            struct_ser.serialize_field("over", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonAggConstructor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "output",
            "agg_filter",
            "agg_order",
            "over",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Output,
            AggFilter,
            AggOrder,
            Over,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "output" => Ok(GeneratedField::Output),
                            "agg_filter" => Ok(GeneratedField::AggFilter),
                            "agg_order" => Ok(GeneratedField::AggOrder),
                            "over" => Ok(GeneratedField::Over),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonAggConstructor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonAggConstructor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonAggConstructor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut output__ = None;
                let mut agg_filter__ = None;
                let mut agg_order__ = None;
                let mut over__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Output => {
                            if output__.is_some() {
                                return Err(serde::de::Error::duplicate_field("output"));
                            }
                            output__ = map_.next_value()?;
                        }
                        GeneratedField::AggFilter => {
                            if agg_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_filter"));
                            }
                            agg_filter__ = map_.next_value()?;
                        }
                        GeneratedField::AggOrder => {
                            if agg_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("agg_order"));
                            }
                            agg_order__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Over => {
                            if over__.is_some() {
                                return Err(serde::de::Error::duplicate_field("over"));
                            }
                            over__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonAggConstructor {
                    output: output__,
                    agg_filter: agg_filter__,
                    agg_order: agg_order__.unwrap_or_default(),
                    over: over__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonAggConstructor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonArrayAgg {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.constructor.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonArrayAgg", len)?;
        if let Some(v) = self.constructor.as_ref() {
            struct_ser.serialize_field("constructor", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonArrayAgg {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "constructor",
            "arg",
            "absent_on_null",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Constructor,
            Arg,
            AbsentOnNull,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "constructor" => Ok(GeneratedField::Constructor),
                            "arg" => Ok(GeneratedField::Arg),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonArrayAgg;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonArrayAgg")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonArrayAgg, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut constructor__ = None;
                let mut arg__ = None;
                let mut absent_on_null__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Constructor => {
                            if constructor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constructor"));
                            }
                            constructor__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(JsonArrayAgg {
                    constructor: constructor__,
                    arg: arg__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonArrayAgg", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonArrayConstructor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.exprs.is_empty() {
            len += 1;
        }
        if self.output.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonArrayConstructor", len)?;
        if !self.exprs.is_empty() {
            struct_ser.serialize_field("exprs", &self.exprs)?;
        }
        if let Some(v) = self.output.as_ref() {
            struct_ser.serialize_field("output", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonArrayConstructor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exprs",
            "output",
            "absent_on_null",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Exprs,
            Output,
            AbsentOnNull,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exprs" => Ok(GeneratedField::Exprs),
                            "output" => Ok(GeneratedField::Output),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonArrayConstructor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonArrayConstructor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonArrayConstructor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exprs__ = None;
                let mut output__ = None;
                let mut absent_on_null__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Exprs => {
                            if exprs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exprs"));
                            }
                            exprs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Output => {
                            if output__.is_some() {
                                return Err(serde::de::Error::duplicate_field("output"));
                            }
                            output__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonArrayConstructor {
                    exprs: exprs__.unwrap_or_default(),
                    output: output__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonArrayConstructor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonArrayQueryConstructor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.query.is_some() {
            len += 1;
        }
        if self.output.is_some() {
            len += 1;
        }
        if self.format.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonArrayQueryConstructor", len)?;
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        if let Some(v) = self.output.as_ref() {
            struct_ser.serialize_field("output", v)?;
        }
        if let Some(v) = self.format.as_ref() {
            struct_ser.serialize_field("format", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonArrayQueryConstructor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "query",
            "output",
            "format",
            "absent_on_null",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Query,
            Output,
            Format,
            AbsentOnNull,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "query" => Ok(GeneratedField::Query),
                            "output" => Ok(GeneratedField::Output),
                            "format" => Ok(GeneratedField::Format),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonArrayQueryConstructor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonArrayQueryConstructor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonArrayQueryConstructor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut query__ = None;
                let mut output__ = None;
                let mut format__ = None;
                let mut absent_on_null__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                        GeneratedField::Output => {
                            if output__.is_some() {
                                return Err(serde::de::Error::duplicate_field("output"));
                            }
                            output__ = map_.next_value()?;
                        }
                        GeneratedField::Format => {
                            if format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("format"));
                            }
                            format__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonArrayQueryConstructor {
                    query: query__,
                    output: output__,
                    format: format__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonArrayQueryConstructor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonConstructorExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.func.is_some() {
            len += 1;
        }
        if self.coercion.is_some() {
            len += 1;
        }
        if self.returning.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        if self.unique {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonConstructorExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.r#type != 0 {
            let v = JsonConstructorType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.func.as_ref() {
            struct_ser.serialize_field("func", v)?;
        }
        if let Some(v) = self.coercion.as_ref() {
            struct_ser.serialize_field("coercion", v)?;
        }
        if let Some(v) = self.returning.as_ref() {
            struct_ser.serialize_field("returning", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        if self.unique {
            struct_ser.serialize_field("unique", &self.unique)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonConstructorExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "type",
            "args",
            "func",
            "coercion",
            "returning",
            "absent_on_null",
            "unique",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Type,
            Args,
            Func,
            Coercion,
            Returning,
            AbsentOnNull,
            Unique,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "type" => Ok(GeneratedField::Type),
                            "args" => Ok(GeneratedField::Args),
                            "func" => Ok(GeneratedField::Func),
                            "coercion" => Ok(GeneratedField::Coercion),
                            "returning" => Ok(GeneratedField::Returning),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            "unique" => Ok(GeneratedField::Unique),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonConstructorExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonConstructorExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonConstructorExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut r#type__ = None;
                let mut args__ = None;
                let mut func__ = None;
                let mut coercion__ = None;
                let mut returning__ = None;
                let mut absent_on_null__ = None;
                let mut unique__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<JsonConstructorType>()? as i32);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = map_.next_value()?;
                        }
                        GeneratedField::Coercion => {
                            if coercion__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coercion"));
                            }
                            coercion__ = map_.next_value()?;
                        }
                        GeneratedField::Returning => {
                            if returning__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returning"));
                            }
                            returning__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Unique => {
                            if unique__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unique"));
                            }
                            unique__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonConstructorExpr {
                    xpr: xpr__,
                    r#type: r#type__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    func: func__,
                    coercion: coercion__,
                    returning: returning__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                    unique: unique__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonConstructorExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonConstructorType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "JSON_CONSTRUCTOR_TYPE_UNDEFINED",
            Self::JsctorJsonObject => "JSCTOR_JSON_OBJECT",
            Self::JsctorJsonArray => "JSCTOR_JSON_ARRAY",
            Self::JsctorJsonObjectagg => "JSCTOR_JSON_OBJECTAGG",
            Self::JsctorJsonArrayagg => "JSCTOR_JSON_ARRAYAGG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for JsonConstructorType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JSON_CONSTRUCTOR_TYPE_UNDEFINED",
            "JSCTOR_JSON_OBJECT",
            "JSCTOR_JSON_ARRAY",
            "JSCTOR_JSON_OBJECTAGG",
            "JSCTOR_JSON_ARRAYAGG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonConstructorType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JSON_CONSTRUCTOR_TYPE_UNDEFINED" => Ok(JsonConstructorType::Undefined),
                    "JSCTOR_JSON_OBJECT" => Ok(JsonConstructorType::JsctorJsonObject),
                    "JSCTOR_JSON_ARRAY" => Ok(JsonConstructorType::JsctorJsonArray),
                    "JSCTOR_JSON_OBJECTAGG" => Ok(JsonConstructorType::JsctorJsonObjectagg),
                    "JSCTOR_JSON_ARRAYAGG" => Ok(JsonConstructorType::JsctorJsonArrayagg),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for JsonEncoding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "JSON_ENCODING_UNDEFINED",
            Self::JsEncDefault => "JS_ENC_DEFAULT",
            Self::JsEncUtf8 => "JS_ENC_UTF8",
            Self::JsEncUtf16 => "JS_ENC_UTF16",
            Self::JsEncUtf32 => "JS_ENC_UTF32",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for JsonEncoding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JSON_ENCODING_UNDEFINED",
            "JS_ENC_DEFAULT",
            "JS_ENC_UTF8",
            "JS_ENC_UTF16",
            "JS_ENC_UTF32",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonEncoding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JSON_ENCODING_UNDEFINED" => Ok(JsonEncoding::Undefined),
                    "JS_ENC_DEFAULT" => Ok(JsonEncoding::JsEncDefault),
                    "JS_ENC_UTF8" => Ok(JsonEncoding::JsEncUtf8),
                    "JS_ENC_UTF16" => Ok(JsonEncoding::JsEncUtf16),
                    "JS_ENC_UTF32" => Ok(JsonEncoding::JsEncUtf32),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for JsonFormat {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.format_type != 0 {
            len += 1;
        }
        if self.encoding != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonFormat", len)?;
        if self.format_type != 0 {
            let v = JsonFormatType::try_from(self.format_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.format_type)))?;
            struct_ser.serialize_field("format_type", &v)?;
        }
        if self.encoding != 0 {
            let v = JsonEncoding::try_from(self.encoding)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.encoding)))?;
            struct_ser.serialize_field("encoding", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonFormat {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "format_type",
            "encoding",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FormatType,
            Encoding,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "format_type" => Ok(GeneratedField::FormatType),
                            "encoding" => Ok(GeneratedField::Encoding),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonFormat;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonFormat")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonFormat, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut format_type__ = None;
                let mut encoding__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FormatType => {
                            if format_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("format_type"));
                            }
                            format_type__ = Some(map_.next_value::<JsonFormatType>()? as i32);
                        }
                        GeneratedField::Encoding => {
                            if encoding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("encoding"));
                            }
                            encoding__ = Some(map_.next_value::<JsonEncoding>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonFormat {
                    format_type: format_type__.unwrap_or_default(),
                    encoding: encoding__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonFormat", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonFormatType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "JSON_FORMAT_TYPE_UNDEFINED",
            Self::JsFormatDefault => "JS_FORMAT_DEFAULT",
            Self::JsFormatJson => "JS_FORMAT_JSON",
            Self::JsFormatJsonb => "JS_FORMAT_JSONB",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for JsonFormatType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JSON_FORMAT_TYPE_UNDEFINED",
            "JS_FORMAT_DEFAULT",
            "JS_FORMAT_JSON",
            "JS_FORMAT_JSONB",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonFormatType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JSON_FORMAT_TYPE_UNDEFINED" => Ok(JsonFormatType::Undefined),
                    "JS_FORMAT_DEFAULT" => Ok(JsonFormatType::JsFormatDefault),
                    "JS_FORMAT_JSON" => Ok(JsonFormatType::JsFormatJson),
                    "JS_FORMAT_JSONB" => Ok(JsonFormatType::JsFormatJsonb),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for JsonIsPredicate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expr.is_some() {
            len += 1;
        }
        if self.format.is_some() {
            len += 1;
        }
        if self.item_type != 0 {
            len += 1;
        }
        if self.unique_keys {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonIsPredicate", len)?;
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if let Some(v) = self.format.as_ref() {
            struct_ser.serialize_field("format", v)?;
        }
        if self.item_type != 0 {
            let v = JsonValueType::try_from(self.item_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.item_type)))?;
            struct_ser.serialize_field("item_type", &v)?;
        }
        if self.unique_keys {
            struct_ser.serialize_field("unique_keys", &self.unique_keys)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonIsPredicate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "expr",
            "format",
            "item_type",
            "unique_keys",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Expr,
            Format,
            ItemType,
            UniqueKeys,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "expr" => Ok(GeneratedField::Expr),
                            "format" => Ok(GeneratedField::Format),
                            "item_type" => Ok(GeneratedField::ItemType),
                            "unique_keys" => Ok(GeneratedField::UniqueKeys),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonIsPredicate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonIsPredicate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonIsPredicate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expr__ = None;
                let mut format__ = None;
                let mut item_type__ = None;
                let mut unique_keys__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Format => {
                            if format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("format"));
                            }
                            format__ = map_.next_value()?;
                        }
                        GeneratedField::ItemType => {
                            if item_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("item_type"));
                            }
                            item_type__ = Some(map_.next_value::<JsonValueType>()? as i32);
                        }
                        GeneratedField::UniqueKeys => {
                            if unique_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unique_keys"));
                            }
                            unique_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonIsPredicate {
                    expr: expr__,
                    format: format__,
                    item_type: item_type__.unwrap_or_default(),
                    unique_keys: unique_keys__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonIsPredicate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonKeyValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonKeyValue", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonKeyValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonKeyValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonKeyValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonKeyValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(JsonKeyValue {
                    key: key__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonKeyValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonObjectAgg {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.constructor.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        if self.unique {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonObjectAgg", len)?;
        if let Some(v) = self.constructor.as_ref() {
            struct_ser.serialize_field("constructor", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        if self.unique {
            struct_ser.serialize_field("unique", &self.unique)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonObjectAgg {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "constructor",
            "arg",
            "absent_on_null",
            "unique",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Constructor,
            Arg,
            AbsentOnNull,
            Unique,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "constructor" => Ok(GeneratedField::Constructor),
                            "arg" => Ok(GeneratedField::Arg),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            "unique" => Ok(GeneratedField::Unique),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonObjectAgg;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonObjectAgg")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonObjectAgg, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut constructor__ = None;
                let mut arg__ = None;
                let mut absent_on_null__ = None;
                let mut unique__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Constructor => {
                            if constructor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constructor"));
                            }
                            constructor__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Unique => {
                            if unique__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unique"));
                            }
                            unique__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(JsonObjectAgg {
                    constructor: constructor__,
                    arg: arg__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                    unique: unique__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonObjectAgg", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonObjectConstructor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.exprs.is_empty() {
            len += 1;
        }
        if self.output.is_some() {
            len += 1;
        }
        if self.absent_on_null {
            len += 1;
        }
        if self.unique {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonObjectConstructor", len)?;
        if !self.exprs.is_empty() {
            struct_ser.serialize_field("exprs", &self.exprs)?;
        }
        if let Some(v) = self.output.as_ref() {
            struct_ser.serialize_field("output", v)?;
        }
        if self.absent_on_null {
            struct_ser.serialize_field("absent_on_null", &self.absent_on_null)?;
        }
        if self.unique {
            struct_ser.serialize_field("unique", &self.unique)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonObjectConstructor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exprs",
            "output",
            "absent_on_null",
            "unique",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Exprs,
            Output,
            AbsentOnNull,
            Unique,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exprs" => Ok(GeneratedField::Exprs),
                            "output" => Ok(GeneratedField::Output),
                            "absent_on_null" => Ok(GeneratedField::AbsentOnNull),
                            "unique" => Ok(GeneratedField::Unique),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonObjectConstructor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonObjectConstructor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonObjectConstructor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exprs__ = None;
                let mut output__ = None;
                let mut absent_on_null__ = None;
                let mut unique__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Exprs => {
                            if exprs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exprs"));
                            }
                            exprs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Output => {
                            if output__.is_some() {
                                return Err(serde::de::Error::duplicate_field("output"));
                            }
                            output__ = map_.next_value()?;
                        }
                        GeneratedField::AbsentOnNull => {
                            if absent_on_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("absent_on_null"));
                            }
                            absent_on_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Unique => {
                            if unique__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unique"));
                            }
                            unique__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonObjectConstructor {
                    exprs: exprs__.unwrap_or_default(),
                    output: output__,
                    absent_on_null: absent_on_null__.unwrap_or_default(),
                    unique: unique__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonObjectConstructor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonOutput {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_name.is_some() {
            len += 1;
        }
        if self.returning.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonOutput", len)?;
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if let Some(v) = self.returning.as_ref() {
            struct_ser.serialize_field("returning", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonOutput {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "returning",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            Returning,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "returning" => Ok(GeneratedField::Returning),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonOutput;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonOutput")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonOutput, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut returning__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::Returning => {
                            if returning__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returning"));
                            }
                            returning__ = map_.next_value()?;
                        }
                    }
                }
                Ok(JsonOutput {
                    type_name: type_name__,
                    returning: returning__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonOutput", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonReturning {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.format.is_some() {
            len += 1;
        }
        if self.typid != 0 {
            len += 1;
        }
        if self.typmod != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonReturning", len)?;
        if let Some(v) = self.format.as_ref() {
            struct_ser.serialize_field("format", v)?;
        }
        if self.typid != 0 {
            struct_ser.serialize_field("typid", &self.typid)?;
        }
        if self.typmod != 0 {
            struct_ser.serialize_field("typmod", &self.typmod)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonReturning {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "format",
            "typid",
            "typmod",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Format,
            Typid,
            Typmod,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "format" => Ok(GeneratedField::Format),
                            "typid" => Ok(GeneratedField::Typid),
                            "typmod" => Ok(GeneratedField::Typmod),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonReturning;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonReturning")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonReturning, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut format__ = None;
                let mut typid__ = None;
                let mut typmod__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Format => {
                            if format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("format"));
                            }
                            format__ = map_.next_value()?;
                        }
                        GeneratedField::Typid => {
                            if typid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typid"));
                            }
                            typid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Typmod => {
                            if typmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typmod"));
                            }
                            typmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(JsonReturning {
                    format: format__,
                    typid: typid__.unwrap_or_default(),
                    typmod: typmod__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonReturning", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonValueExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.raw_expr.is_some() {
            len += 1;
        }
        if self.formatted_expr.is_some() {
            len += 1;
        }
        if self.format.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.JsonValueExpr", len)?;
        if let Some(v) = self.raw_expr.as_ref() {
            struct_ser.serialize_field("raw_expr", v)?;
        }
        if let Some(v) = self.formatted_expr.as_ref() {
            struct_ser.serialize_field("formatted_expr", v)?;
        }
        if let Some(v) = self.format.as_ref() {
            struct_ser.serialize_field("format", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JsonValueExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "raw_expr",
            "formatted_expr",
            "format",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RawExpr,
            FormattedExpr,
            Format,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "raw_expr" => Ok(GeneratedField::RawExpr),
                            "formatted_expr" => Ok(GeneratedField::FormattedExpr),
                            "format" => Ok(GeneratedField::Format),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonValueExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.JsonValueExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JsonValueExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut raw_expr__ = None;
                let mut formatted_expr__ = None;
                let mut format__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RawExpr => {
                            if raw_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("raw_expr"));
                            }
                            raw_expr__ = map_.next_value()?;
                        }
                        GeneratedField::FormattedExpr => {
                            if formatted_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("formatted_expr"));
                            }
                            formatted_expr__ = map_.next_value()?;
                        }
                        GeneratedField::Format => {
                            if format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("format"));
                            }
                            format__ = map_.next_value()?;
                        }
                    }
                }
                Ok(JsonValueExpr {
                    raw_expr: raw_expr__,
                    formatted_expr: formatted_expr__,
                    format: format__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.JsonValueExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JsonValueType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "JSON_VALUE_TYPE_UNDEFINED",
            Self::JsTypeAny => "JS_TYPE_ANY",
            Self::JsTypeObject => "JS_TYPE_OBJECT",
            Self::JsTypeArray => "JS_TYPE_ARRAY",
            Self::JsTypeScalar => "JS_TYPE_SCALAR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for JsonValueType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JSON_VALUE_TYPE_UNDEFINED",
            "JS_TYPE_ANY",
            "JS_TYPE_OBJECT",
            "JS_TYPE_ARRAY",
            "JS_TYPE_SCALAR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JsonValueType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JSON_VALUE_TYPE_UNDEFINED" => Ok(JsonValueType::Undefined),
                    "JS_TYPE_ANY" => Ok(JsonValueType::JsTypeAny),
                    "JS_TYPE_OBJECT" => Ok(JsonValueType::JsTypeObject),
                    "JS_TYPE_ARRAY" => Ok(JsonValueType::JsTypeArray),
                    "JS_TYPE_SCALAR" => Ok(JsonValueType::JsTypeScalar),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for KeywordKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoKeyword => "NO_KEYWORD",
            Self::UnreservedKeyword => "UNRESERVED_KEYWORD",
            Self::ColNameKeyword => "COL_NAME_KEYWORD",
            Self::TypeFuncNameKeyword => "TYPE_FUNC_NAME_KEYWORD",
            Self::ReservedKeyword => "RESERVED_KEYWORD",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for KeywordKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_KEYWORD",
            "UNRESERVED_KEYWORD",
            "COL_NAME_KEYWORD",
            "TYPE_FUNC_NAME_KEYWORD",
            "RESERVED_KEYWORD",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = KeywordKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_KEYWORD" => Ok(KeywordKind::NoKeyword),
                    "UNRESERVED_KEYWORD" => Ok(KeywordKind::UnreservedKeyword),
                    "COL_NAME_KEYWORD" => Ok(KeywordKind::ColNameKeyword),
                    "TYPE_FUNC_NAME_KEYWORD" => Ok(KeywordKind::TypeFuncNameKeyword),
                    "RESERVED_KEYWORD" => Ok(KeywordKind::ReservedKeyword),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for LimitOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "LIMIT_OPTION_UNDEFINED",
            Self::Default => "LIMIT_OPTION_DEFAULT",
            Self::Count => "LIMIT_OPTION_COUNT",
            Self::WithTies => "LIMIT_OPTION_WITH_TIES",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for LimitOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LIMIT_OPTION_UNDEFINED",
            "LIMIT_OPTION_DEFAULT",
            "LIMIT_OPTION_COUNT",
            "LIMIT_OPTION_WITH_TIES",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LIMIT_OPTION_UNDEFINED" => Ok(LimitOption::Undefined),
                    "LIMIT_OPTION_DEFAULT" => Ok(LimitOption::Default),
                    "LIMIT_OPTION_COUNT" => Ok(LimitOption::Count),
                    "LIMIT_OPTION_WITH_TIES" => Ok(LimitOption::WithTies),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.List", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(List {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListenStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.conditionname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ListenStmt", len)?;
        if !self.conditionname.is_empty() {
            struct_ser.serialize_field("conditionname", &self.conditionname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListenStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "conditionname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Conditionname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "conditionname" => Ok(GeneratedField::Conditionname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListenStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ListenStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListenStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut conditionname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Conditionname => {
                            if conditionname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditionname"));
                            }
                            conditionname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ListenStmt {
                    conditionname: conditionname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ListenStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LoadStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.filename.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.LoadStmt", len)?;
        if !self.filename.is_empty() {
            struct_ser.serialize_field("filename", &self.filename)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LoadStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "filename",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Filename,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "filename" => Ok(GeneratedField::Filename),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LoadStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.LoadStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LoadStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut filename__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Filename => {
                            if filename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filename"));
                            }
                            filename__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(LoadStmt {
                    filename: filename__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.LoadStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LockClauseStrength {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "LOCK_CLAUSE_STRENGTH_UNDEFINED",
            Self::LcsNone => "LCS_NONE",
            Self::LcsForkeyshare => "LCS_FORKEYSHARE",
            Self::LcsForshare => "LCS_FORSHARE",
            Self::LcsFornokeyupdate => "LCS_FORNOKEYUPDATE",
            Self::LcsForupdate => "LCS_FORUPDATE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for LockClauseStrength {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LOCK_CLAUSE_STRENGTH_UNDEFINED",
            "LCS_NONE",
            "LCS_FORKEYSHARE",
            "LCS_FORSHARE",
            "LCS_FORNOKEYUPDATE",
            "LCS_FORUPDATE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockClauseStrength;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LOCK_CLAUSE_STRENGTH_UNDEFINED" => Ok(LockClauseStrength::Undefined),
                    "LCS_NONE" => Ok(LockClauseStrength::LcsNone),
                    "LCS_FORKEYSHARE" => Ok(LockClauseStrength::LcsForkeyshare),
                    "LCS_FORSHARE" => Ok(LockClauseStrength::LcsForshare),
                    "LCS_FORNOKEYUPDATE" => Ok(LockClauseStrength::LcsFornokeyupdate),
                    "LCS_FORUPDATE" => Ok(LockClauseStrength::LcsForupdate),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for LockStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.relations.is_empty() {
            len += 1;
        }
        if self.mode != 0 {
            len += 1;
        }
        if self.nowait {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.LockStmt", len)?;
        if !self.relations.is_empty() {
            struct_ser.serialize_field("relations", &self.relations)?;
        }
        if self.mode != 0 {
            struct_ser.serialize_field("mode", &self.mode)?;
        }
        if self.nowait {
            struct_ser.serialize_field("nowait", &self.nowait)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LockStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relations",
            "mode",
            "nowait",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relations,
            Mode,
            Nowait,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relations" => Ok(GeneratedField::Relations),
                            "mode" => Ok(GeneratedField::Mode),
                            "nowait" => Ok(GeneratedField::Nowait),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.LockStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LockStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relations__ = None;
                let mut mode__ = None;
                let mut nowait__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relations => {
                            if relations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relations"));
                            }
                            relations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nowait => {
                            if nowait__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nowait"));
                            }
                            nowait__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(LockStmt {
                    relations: relations__.unwrap_or_default(),
                    mode: mode__.unwrap_or_default(),
                    nowait: nowait__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.LockStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LockTupleMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "LOCK_TUPLE_MODE_UNDEFINED",
            Self::LockTupleKeyShare => "LockTupleKeyShare",
            Self::LockTupleShare => "LockTupleShare",
            Self::LockTupleNoKeyExclusive => "LockTupleNoKeyExclusive",
            Self::LockTupleExclusive => "LockTupleExclusive",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for LockTupleMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LOCK_TUPLE_MODE_UNDEFINED",
            "LockTupleKeyShare",
            "LockTupleShare",
            "LockTupleNoKeyExclusive",
            "LockTupleExclusive",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockTupleMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LOCK_TUPLE_MODE_UNDEFINED" => Ok(LockTupleMode::Undefined),
                    "LockTupleKeyShare" => Ok(LockTupleMode::LockTupleKeyShare),
                    "LockTupleShare" => Ok(LockTupleMode::LockTupleShare),
                    "LockTupleNoKeyExclusive" => Ok(LockTupleMode::LockTupleNoKeyExclusive),
                    "LockTupleExclusive" => Ok(LockTupleMode::LockTupleExclusive),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for LockWaitPolicy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "LOCK_WAIT_POLICY_UNDEFINED",
            Self::LockWaitBlock => "LockWaitBlock",
            Self::LockWaitSkip => "LockWaitSkip",
            Self::LockWaitError => "LockWaitError",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for LockWaitPolicy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LOCK_WAIT_POLICY_UNDEFINED",
            "LockWaitBlock",
            "LockWaitSkip",
            "LockWaitError",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockWaitPolicy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LOCK_WAIT_POLICY_UNDEFINED" => Ok(LockWaitPolicy::Undefined),
                    "LockWaitBlock" => Ok(LockWaitPolicy::LockWaitBlock),
                    "LockWaitSkip" => Ok(LockWaitPolicy::LockWaitSkip),
                    "LockWaitError" => Ok(LockWaitPolicy::LockWaitError),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for LockingClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.locked_rels.is_empty() {
            len += 1;
        }
        if self.strength != 0 {
            len += 1;
        }
        if self.wait_policy != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.LockingClause", len)?;
        if !self.locked_rels.is_empty() {
            struct_ser.serialize_field("lockedRels", &self.locked_rels)?;
        }
        if self.strength != 0 {
            let v = LockClauseStrength::try_from(self.strength)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.strength)))?;
            struct_ser.serialize_field("strength", &v)?;
        }
        if self.wait_policy != 0 {
            let v = LockWaitPolicy::try_from(self.wait_policy)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.wait_policy)))?;
            struct_ser.serialize_field("waitPolicy", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LockingClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "locked_rels",
            "lockedRels",
            "strength",
            "wait_policy",
            "waitPolicy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LockedRels,
            Strength,
            WaitPolicy,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "lockedRels" | "locked_rels" => Ok(GeneratedField::LockedRels),
                            "strength" => Ok(GeneratedField::Strength),
                            "waitPolicy" | "wait_policy" => Ok(GeneratedField::WaitPolicy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockingClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.LockingClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LockingClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut locked_rels__ = None;
                let mut strength__ = None;
                let mut wait_policy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LockedRels => {
                            if locked_rels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lockedRels"));
                            }
                            locked_rels__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Strength => {
                            if strength__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strength"));
                            }
                            strength__ = Some(map_.next_value::<LockClauseStrength>()? as i32);
                        }
                        GeneratedField::WaitPolicy => {
                            if wait_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("waitPolicy"));
                            }
                            wait_policy__ = Some(map_.next_value::<LockWaitPolicy>()? as i32);
                        }
                    }
                }
                Ok(LockingClause {
                    locked_rels: locked_rels__.unwrap_or_default(),
                    strength: strength__.unwrap_or_default(),
                    wait_policy: wait_policy__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.LockingClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MergeAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.matched {
            len += 1;
        }
        if self.command_type != 0 {
            len += 1;
        }
        if self.r#override != 0 {
            len += 1;
        }
        if self.qual.is_some() {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if !self.update_colnos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.MergeAction", len)?;
        if self.matched {
            struct_ser.serialize_field("matched", &self.matched)?;
        }
        if self.command_type != 0 {
            let v = CmdType::try_from(self.command_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.command_type)))?;
            struct_ser.serialize_field("commandType", &v)?;
        }
        if self.r#override != 0 {
            let v = OverridingKind::try_from(self.r#override)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#override)))?;
            struct_ser.serialize_field("override", &v)?;
        }
        if let Some(v) = self.qual.as_ref() {
            struct_ser.serialize_field("qual", v)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if !self.update_colnos.is_empty() {
            struct_ser.serialize_field("updateColnos", &self.update_colnos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MergeAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "matched",
            "command_type",
            "commandType",
            "override",
            "qual",
            "target_list",
            "targetList",
            "update_colnos",
            "updateColnos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Matched,
            CommandType,
            Override,
            Qual,
            TargetList,
            UpdateColnos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "matched" => Ok(GeneratedField::Matched),
                            "commandType" | "command_type" => Ok(GeneratedField::CommandType),
                            "override" => Ok(GeneratedField::Override),
                            "qual" => Ok(GeneratedField::Qual),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "updateColnos" | "update_colnos" => Ok(GeneratedField::UpdateColnos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MergeAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.MergeAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MergeAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut matched__ = None;
                let mut command_type__ = None;
                let mut r#override__ = None;
                let mut qual__ = None;
                let mut target_list__ = None;
                let mut update_colnos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Matched => {
                            if matched__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matched"));
                            }
                            matched__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CommandType => {
                            if command_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commandType"));
                            }
                            command_type__ = Some(map_.next_value::<CmdType>()? as i32);
                        }
                        GeneratedField::Override => {
                            if r#override__.is_some() {
                                return Err(serde::de::Error::duplicate_field("override"));
                            }
                            r#override__ = Some(map_.next_value::<OverridingKind>()? as i32);
                        }
                        GeneratedField::Qual => {
                            if qual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("qual"));
                            }
                            qual__ = map_.next_value()?;
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UpdateColnos => {
                            if update_colnos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updateColnos"));
                            }
                            update_colnos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MergeAction {
                    matched: matched__.unwrap_or_default(),
                    command_type: command_type__.unwrap_or_default(),
                    r#override: r#override__.unwrap_or_default(),
                    qual: qual__,
                    target_list: target_list__.unwrap_or_default(),
                    update_colnos: update_colnos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.MergeAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MergeStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if self.source_relation.is_some() {
            len += 1;
        }
        if self.join_condition.is_some() {
            len += 1;
        }
        if !self.merge_when_clauses.is_empty() {
            len += 1;
        }
        if self.with_clause.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.MergeStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.source_relation.as_ref() {
            struct_ser.serialize_field("sourceRelation", v)?;
        }
        if let Some(v) = self.join_condition.as_ref() {
            struct_ser.serialize_field("joinCondition", v)?;
        }
        if !self.merge_when_clauses.is_empty() {
            struct_ser.serialize_field("mergeWhenClauses", &self.merge_when_clauses)?;
        }
        if let Some(v) = self.with_clause.as_ref() {
            struct_ser.serialize_field("withClause", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MergeStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "source_relation",
            "sourceRelation",
            "join_condition",
            "joinCondition",
            "merge_when_clauses",
            "mergeWhenClauses",
            "with_clause",
            "withClause",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            SourceRelation,
            JoinCondition,
            MergeWhenClauses,
            WithClause,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "sourceRelation" | "source_relation" => Ok(GeneratedField::SourceRelation),
                            "joinCondition" | "join_condition" => Ok(GeneratedField::JoinCondition),
                            "mergeWhenClauses" | "merge_when_clauses" => Ok(GeneratedField::MergeWhenClauses),
                            "withClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MergeStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.MergeStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MergeStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut source_relation__ = None;
                let mut join_condition__ = None;
                let mut merge_when_clauses__ = None;
                let mut with_clause__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::SourceRelation => {
                            if source_relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sourceRelation"));
                            }
                            source_relation__ = map_.next_value()?;
                        }
                        GeneratedField::JoinCondition => {
                            if join_condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("joinCondition"));
                            }
                            join_condition__ = map_.next_value()?;
                        }
                        GeneratedField::MergeWhenClauses => {
                            if merge_when_clauses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mergeWhenClauses"));
                            }
                            merge_when_clauses__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithClause => {
                            if with_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withClause"));
                            }
                            with_clause__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MergeStmt {
                    relation: relation__,
                    source_relation: source_relation__,
                    join_condition: join_condition__,
                    merge_when_clauses: merge_when_clauses__.unwrap_or_default(),
                    with_clause: with_clause__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.MergeStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MergeWhenClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.matched {
            len += 1;
        }
        if self.command_type != 0 {
            len += 1;
        }
        if self.r#override != 0 {
            len += 1;
        }
        if self.condition.is_some() {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.MergeWhenClause", len)?;
        if self.matched {
            struct_ser.serialize_field("matched", &self.matched)?;
        }
        if self.command_type != 0 {
            let v = CmdType::try_from(self.command_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.command_type)))?;
            struct_ser.serialize_field("commandType", &v)?;
        }
        if self.r#override != 0 {
            let v = OverridingKind::try_from(self.r#override)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#override)))?;
            struct_ser.serialize_field("override", &v)?;
        }
        if let Some(v) = self.condition.as_ref() {
            struct_ser.serialize_field("condition", v)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MergeWhenClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "matched",
            "command_type",
            "commandType",
            "override",
            "condition",
            "target_list",
            "targetList",
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Matched,
            CommandType,
            Override,
            Condition,
            TargetList,
            Values,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "matched" => Ok(GeneratedField::Matched),
                            "commandType" | "command_type" => Ok(GeneratedField::CommandType),
                            "override" => Ok(GeneratedField::Override),
                            "condition" => Ok(GeneratedField::Condition),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "values" => Ok(GeneratedField::Values),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MergeWhenClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.MergeWhenClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MergeWhenClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut matched__ = None;
                let mut command_type__ = None;
                let mut r#override__ = None;
                let mut condition__ = None;
                let mut target_list__ = None;
                let mut values__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Matched => {
                            if matched__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matched"));
                            }
                            matched__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CommandType => {
                            if command_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commandType"));
                            }
                            command_type__ = Some(map_.next_value::<CmdType>()? as i32);
                        }
                        GeneratedField::Override => {
                            if r#override__.is_some() {
                                return Err(serde::de::Error::duplicate_field("override"));
                            }
                            r#override__ = Some(map_.next_value::<OverridingKind>()? as i32);
                        }
                        GeneratedField::Condition => {
                            if condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("condition"));
                            }
                            condition__ = map_.next_value()?;
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MergeWhenClause {
                    matched: matched__.unwrap_or_default(),
                    command_type: command_type__.unwrap_or_default(),
                    r#override: r#override__.unwrap_or_default(),
                    condition: condition__,
                    target_list: target_list__.unwrap_or_default(),
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.MergeWhenClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MinMaxExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.minmaxtype != 0 {
            len += 1;
        }
        if self.minmaxcollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.MinMaxExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.minmaxtype != 0 {
            struct_ser.serialize_field("minmaxtype", &self.minmaxtype)?;
        }
        if self.minmaxcollid != 0 {
            struct_ser.serialize_field("minmaxcollid", &self.minmaxcollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if self.op != 0 {
            let v = MinMaxOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MinMaxExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "minmaxtype",
            "minmaxcollid",
            "inputcollid",
            "op",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Minmaxtype,
            Minmaxcollid,
            Inputcollid,
            Op,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "minmaxtype" => Ok(GeneratedField::Minmaxtype),
                            "minmaxcollid" => Ok(GeneratedField::Minmaxcollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "op" => Ok(GeneratedField::Op),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MinMaxExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.MinMaxExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MinMaxExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut minmaxtype__ = None;
                let mut minmaxcollid__ = None;
                let mut inputcollid__ = None;
                let mut op__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Minmaxtype => {
                            if minmaxtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minmaxtype"));
                            }
                            minmaxtype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Minmaxcollid => {
                            if minmaxcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minmaxcollid"));
                            }
                            minmaxcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<MinMaxOp>()? as i32);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MinMaxExpr {
                    xpr: xpr__,
                    minmaxtype: minmaxtype__.unwrap_or_default(),
                    minmaxcollid: minmaxcollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    op: op__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.MinMaxExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MinMaxOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "MIN_MAX_OP_UNDEFINED",
            Self::IsGreatest => "IS_GREATEST",
            Self::IsLeast => "IS_LEAST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for MinMaxOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MIN_MAX_OP_UNDEFINED",
            "IS_GREATEST",
            "IS_LEAST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MinMaxOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "MIN_MAX_OP_UNDEFINED" => Ok(MinMaxOp::Undefined),
                    "IS_GREATEST" => Ok(MinMaxOp::IsGreatest),
                    "IS_LEAST" => Ok(MinMaxOp::IsLeast),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MultiAssignRef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.source.is_some() {
            len += 1;
        }
        if self.colno != 0 {
            len += 1;
        }
        if self.ncolumns != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.MultiAssignRef", len)?;
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        if self.colno != 0 {
            struct_ser.serialize_field("colno", &self.colno)?;
        }
        if self.ncolumns != 0 {
            struct_ser.serialize_field("ncolumns", &self.ncolumns)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultiAssignRef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "source",
            "colno",
            "ncolumns",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Source,
            Colno,
            Ncolumns,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "source" => Ok(GeneratedField::Source),
                            "colno" => Ok(GeneratedField::Colno),
                            "ncolumns" => Ok(GeneratedField::Ncolumns),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultiAssignRef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.MultiAssignRef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultiAssignRef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut source__ = None;
                let mut colno__ = None;
                let mut ncolumns__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = map_.next_value()?;
                        }
                        GeneratedField::Colno => {
                            if colno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colno"));
                            }
                            colno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Ncolumns => {
                            if ncolumns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ncolumns"));
                            }
                            ncolumns__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MultiAssignRef {
                    source: source__,
                    colno: colno__.unwrap_or_default(),
                    ncolumns: ncolumns__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.MultiAssignRef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamedArgExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.argnumber != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.NamedArgExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if self.argnumber != 0 {
            struct_ser.serialize_field("argnumber", &self.argnumber)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamedArgExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "name",
            "argnumber",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Name,
            Argnumber,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "name" => Ok(GeneratedField::Name),
                            "argnumber" => Ok(GeneratedField::Argnumber),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamedArgExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.NamedArgExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NamedArgExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut name__ = None;
                let mut argnumber__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Argnumber => {
                            if argnumber__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argnumber"));
                            }
                            argnumber__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NamedArgExpr {
                    xpr: xpr__,
                    arg: arg__,
                    name: name__.unwrap_or_default(),
                    argnumber: argnumber__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.NamedArgExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NextValueExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.seqid != 0 {
            len += 1;
        }
        if self.type_id != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.NextValueExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.seqid != 0 {
            struct_ser.serialize_field("seqid", &self.seqid)?;
        }
        if self.type_id != 0 {
            struct_ser.serialize_field("typeId", &self.type_id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NextValueExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "seqid",
            "type_id",
            "typeId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Seqid,
            TypeId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "seqid" => Ok(GeneratedField::Seqid),
                            "typeId" | "type_id" => Ok(GeneratedField::TypeId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NextValueExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.NextValueExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NextValueExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut seqid__ = None;
                let mut type_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Seqid => {
                            if seqid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seqid"));
                            }
                            seqid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeId => {
                            if type_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeId"));
                            }
                            type_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NextValueExpr {
                    xpr: xpr__,
                    seqid: seqid__.unwrap_or_default(),
                    type_id: type_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.NextValueExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Node {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.node.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Node", len)?;
        if let Some(v) = self.node.as_ref() {
            match v {
                node::Node::Alias(v) => {
                    struct_ser.serialize_field("Alias", v)?;
                }
                node::Node::RangeVar(v) => {
                    struct_ser.serialize_field("RangeVar", v)?;
                }
                node::Node::TableFunc(v) => {
                    struct_ser.serialize_field("TableFunc", v)?;
                }
                node::Node::IntoClause(v) => {
                    struct_ser.serialize_field("IntoClause", v)?;
                }
                node::Node::Var(v) => {
                    struct_ser.serialize_field("Var", v)?;
                }
                node::Node::Param(v) => {
                    struct_ser.serialize_field("Param", v)?;
                }
                node::Node::Aggref(v) => {
                    struct_ser.serialize_field("Aggref", v)?;
                }
                node::Node::GroupingFunc(v) => {
                    struct_ser.serialize_field("GroupingFunc", v)?;
                }
                node::Node::WindowFunc(v) => {
                    struct_ser.serialize_field("WindowFunc", v)?;
                }
                node::Node::SubscriptingRef(v) => {
                    struct_ser.serialize_field("SubscriptingRef", v)?;
                }
                node::Node::FuncExpr(v) => {
                    struct_ser.serialize_field("FuncExpr", v)?;
                }
                node::Node::NamedArgExpr(v) => {
                    struct_ser.serialize_field("NamedArgExpr", v)?;
                }
                node::Node::OpExpr(v) => {
                    struct_ser.serialize_field("OpExpr", v)?;
                }
                node::Node::DistinctExpr(v) => {
                    struct_ser.serialize_field("DistinctExpr", v)?;
                }
                node::Node::NullIfExpr(v) => {
                    struct_ser.serialize_field("NullIfExpr", v)?;
                }
                node::Node::ScalarArrayOpExpr(v) => {
                    struct_ser.serialize_field("ScalarArrayOpExpr", v)?;
                }
                node::Node::BoolExpr(v) => {
                    struct_ser.serialize_field("BoolExpr", v)?;
                }
                node::Node::SubLink(v) => {
                    struct_ser.serialize_field("SubLink", v)?;
                }
                node::Node::SubPlan(v) => {
                    struct_ser.serialize_field("SubPlan", v)?;
                }
                node::Node::AlternativeSubPlan(v) => {
                    struct_ser.serialize_field("AlternativeSubPlan", v)?;
                }
                node::Node::FieldSelect(v) => {
                    struct_ser.serialize_field("FieldSelect", v)?;
                }
                node::Node::FieldStore(v) => {
                    struct_ser.serialize_field("FieldStore", v)?;
                }
                node::Node::RelabelType(v) => {
                    struct_ser.serialize_field("RelabelType", v)?;
                }
                node::Node::CoerceViaIo(v) => {
                    struct_ser.serialize_field("CoerceViaIO", v)?;
                }
                node::Node::ArrayCoerceExpr(v) => {
                    struct_ser.serialize_field("ArrayCoerceExpr", v)?;
                }
                node::Node::ConvertRowtypeExpr(v) => {
                    struct_ser.serialize_field("ConvertRowtypeExpr", v)?;
                }
                node::Node::CollateExpr(v) => {
                    struct_ser.serialize_field("CollateExpr", v)?;
                }
                node::Node::CaseExpr(v) => {
                    struct_ser.serialize_field("CaseExpr", v)?;
                }
                node::Node::CaseWhen(v) => {
                    struct_ser.serialize_field("CaseWhen", v)?;
                }
                node::Node::CaseTestExpr(v) => {
                    struct_ser.serialize_field("CaseTestExpr", v)?;
                }
                node::Node::ArrayExpr(v) => {
                    struct_ser.serialize_field("ArrayExpr", v)?;
                }
                node::Node::RowExpr(v) => {
                    struct_ser.serialize_field("RowExpr", v)?;
                }
                node::Node::RowCompareExpr(v) => {
                    struct_ser.serialize_field("RowCompareExpr", v)?;
                }
                node::Node::CoalesceExpr(v) => {
                    struct_ser.serialize_field("CoalesceExpr", v)?;
                }
                node::Node::MinMaxExpr(v) => {
                    struct_ser.serialize_field("MinMaxExpr", v)?;
                }
                node::Node::SqlvalueFunction(v) => {
                    struct_ser.serialize_field("SQLValueFunction", v)?;
                }
                node::Node::XmlExpr(v) => {
                    struct_ser.serialize_field("XmlExpr", v)?;
                }
                node::Node::JsonFormat(v) => {
                    struct_ser.serialize_field("JsonFormat", v)?;
                }
                node::Node::JsonReturning(v) => {
                    struct_ser.serialize_field("JsonReturning", v)?;
                }
                node::Node::JsonValueExpr(v) => {
                    struct_ser.serialize_field("JsonValueExpr", v)?;
                }
                node::Node::JsonConstructorExpr(v) => {
                    struct_ser.serialize_field("JsonConstructorExpr", v)?;
                }
                node::Node::JsonIsPredicate(v) => {
                    struct_ser.serialize_field("JsonIsPredicate", v)?;
                }
                node::Node::NullTest(v) => {
                    struct_ser.serialize_field("NullTest", v)?;
                }
                node::Node::BooleanTest(v) => {
                    struct_ser.serialize_field("BooleanTest", v)?;
                }
                node::Node::CoerceToDomain(v) => {
                    struct_ser.serialize_field("CoerceToDomain", v)?;
                }
                node::Node::CoerceToDomainValue(v) => {
                    struct_ser.serialize_field("CoerceToDomainValue", v)?;
                }
                node::Node::SetToDefault(v) => {
                    struct_ser.serialize_field("SetToDefault", v)?;
                }
                node::Node::CurrentOfExpr(v) => {
                    struct_ser.serialize_field("CurrentOfExpr", v)?;
                }
                node::Node::NextValueExpr(v) => {
                    struct_ser.serialize_field("NextValueExpr", v)?;
                }
                node::Node::InferenceElem(v) => {
                    struct_ser.serialize_field("InferenceElem", v)?;
                }
                node::Node::TargetEntry(v) => {
                    struct_ser.serialize_field("TargetEntry", v)?;
                }
                node::Node::RangeTblRef(v) => {
                    struct_ser.serialize_field("RangeTblRef", v)?;
                }
                node::Node::JoinExpr(v) => {
                    struct_ser.serialize_field("JoinExpr", v)?;
                }
                node::Node::FromExpr(v) => {
                    struct_ser.serialize_field("FromExpr", v)?;
                }
                node::Node::OnConflictExpr(v) => {
                    struct_ser.serialize_field("OnConflictExpr", v)?;
                }
                node::Node::Query(v) => {
                    struct_ser.serialize_field("Query", v)?;
                }
                node::Node::TypeName(v) => {
                    struct_ser.serialize_field("TypeName", v)?;
                }
                node::Node::ColumnRef(v) => {
                    struct_ser.serialize_field("ColumnRef", v)?;
                }
                node::Node::ParamRef(v) => {
                    struct_ser.serialize_field("ParamRef", v)?;
                }
                node::Node::AExpr(v) => {
                    struct_ser.serialize_field("A_Expr", v)?;
                }
                node::Node::TypeCast(v) => {
                    struct_ser.serialize_field("TypeCast", v)?;
                }
                node::Node::CollateClause(v) => {
                    struct_ser.serialize_field("CollateClause", v)?;
                }
                node::Node::RoleSpec(v) => {
                    struct_ser.serialize_field("RoleSpec", v)?;
                }
                node::Node::FuncCall(v) => {
                    struct_ser.serialize_field("FuncCall", v)?;
                }
                node::Node::AStar(v) => {
                    struct_ser.serialize_field("A_Star", v)?;
                }
                node::Node::AIndices(v) => {
                    struct_ser.serialize_field("A_Indices", v)?;
                }
                node::Node::AIndirection(v) => {
                    struct_ser.serialize_field("A_Indirection", v)?;
                }
                node::Node::AArrayExpr(v) => {
                    struct_ser.serialize_field("A_ArrayExpr", v)?;
                }
                node::Node::ResTarget(v) => {
                    struct_ser.serialize_field("ResTarget", v)?;
                }
                node::Node::MultiAssignRef(v) => {
                    struct_ser.serialize_field("MultiAssignRef", v)?;
                }
                node::Node::SortBy(v) => {
                    struct_ser.serialize_field("SortBy", v)?;
                }
                node::Node::WindowDef(v) => {
                    struct_ser.serialize_field("WindowDef", v)?;
                }
                node::Node::RangeSubselect(v) => {
                    struct_ser.serialize_field("RangeSubselect", v)?;
                }
                node::Node::RangeFunction(v) => {
                    struct_ser.serialize_field("RangeFunction", v)?;
                }
                node::Node::RangeTableFunc(v) => {
                    struct_ser.serialize_field("RangeTableFunc", v)?;
                }
                node::Node::RangeTableFuncCol(v) => {
                    struct_ser.serialize_field("RangeTableFuncCol", v)?;
                }
                node::Node::RangeTableSample(v) => {
                    struct_ser.serialize_field("RangeTableSample", v)?;
                }
                node::Node::ColumnDef(v) => {
                    struct_ser.serialize_field("ColumnDef", v)?;
                }
                node::Node::TableLikeClause(v) => {
                    struct_ser.serialize_field("TableLikeClause", v)?;
                }
                node::Node::IndexElem(v) => {
                    struct_ser.serialize_field("IndexElem", v)?;
                }
                node::Node::DefElem(v) => {
                    struct_ser.serialize_field("DefElem", v)?;
                }
                node::Node::LockingClause(v) => {
                    struct_ser.serialize_field("LockingClause", v)?;
                }
                node::Node::XmlSerialize(v) => {
                    struct_ser.serialize_field("XmlSerialize", v)?;
                }
                node::Node::PartitionElem(v) => {
                    struct_ser.serialize_field("PartitionElem", v)?;
                }
                node::Node::PartitionSpec(v) => {
                    struct_ser.serialize_field("PartitionSpec", v)?;
                }
                node::Node::PartitionBoundSpec(v) => {
                    struct_ser.serialize_field("PartitionBoundSpec", v)?;
                }
                node::Node::PartitionRangeDatum(v) => {
                    struct_ser.serialize_field("PartitionRangeDatum", v)?;
                }
                node::Node::PartitionCmd(v) => {
                    struct_ser.serialize_field("PartitionCmd", v)?;
                }
                node::Node::RangeTblEntry(v) => {
                    struct_ser.serialize_field("RangeTblEntry", v)?;
                }
                node::Node::RtepermissionInfo(v) => {
                    struct_ser.serialize_field("RTEPermissionInfo", v)?;
                }
                node::Node::RangeTblFunction(v) => {
                    struct_ser.serialize_field("RangeTblFunction", v)?;
                }
                node::Node::TableSampleClause(v) => {
                    struct_ser.serialize_field("TableSampleClause", v)?;
                }
                node::Node::WithCheckOption(v) => {
                    struct_ser.serialize_field("WithCheckOption", v)?;
                }
                node::Node::SortGroupClause(v) => {
                    struct_ser.serialize_field("SortGroupClause", v)?;
                }
                node::Node::GroupingSet(v) => {
                    struct_ser.serialize_field("GroupingSet", v)?;
                }
                node::Node::WindowClause(v) => {
                    struct_ser.serialize_field("WindowClause", v)?;
                }
                node::Node::RowMarkClause(v) => {
                    struct_ser.serialize_field("RowMarkClause", v)?;
                }
                node::Node::WithClause(v) => {
                    struct_ser.serialize_field("WithClause", v)?;
                }
                node::Node::InferClause(v) => {
                    struct_ser.serialize_field("InferClause", v)?;
                }
                node::Node::OnConflictClause(v) => {
                    struct_ser.serialize_field("OnConflictClause", v)?;
                }
                node::Node::CtesearchClause(v) => {
                    struct_ser.serialize_field("CTESearchClause", v)?;
                }
                node::Node::CtecycleClause(v) => {
                    struct_ser.serialize_field("CTECycleClause", v)?;
                }
                node::Node::CommonTableExpr(v) => {
                    struct_ser.serialize_field("CommonTableExpr", v)?;
                }
                node::Node::MergeWhenClause(v) => {
                    struct_ser.serialize_field("MergeWhenClause", v)?;
                }
                node::Node::MergeAction(v) => {
                    struct_ser.serialize_field("MergeAction", v)?;
                }
                node::Node::TriggerTransition(v) => {
                    struct_ser.serialize_field("TriggerTransition", v)?;
                }
                node::Node::JsonOutput(v) => {
                    struct_ser.serialize_field("JsonOutput", v)?;
                }
                node::Node::JsonKeyValue(v) => {
                    struct_ser.serialize_field("JsonKeyValue", v)?;
                }
                node::Node::JsonObjectConstructor(v) => {
                    struct_ser.serialize_field("JsonObjectConstructor", v)?;
                }
                node::Node::JsonArrayConstructor(v) => {
                    struct_ser.serialize_field("JsonArrayConstructor", v)?;
                }
                node::Node::JsonArrayQueryConstructor(v) => {
                    struct_ser.serialize_field("JsonArrayQueryConstructor", v)?;
                }
                node::Node::JsonAggConstructor(v) => {
                    struct_ser.serialize_field("JsonAggConstructor", v)?;
                }
                node::Node::JsonObjectAgg(v) => {
                    struct_ser.serialize_field("JsonObjectAgg", v)?;
                }
                node::Node::JsonArrayAgg(v) => {
                    struct_ser.serialize_field("JsonArrayAgg", v)?;
                }
                node::Node::RawStmt(v) => {
                    struct_ser.serialize_field("RawStmt", v)?;
                }
                node::Node::InsertStmt(v) => {
                    struct_ser.serialize_field("InsertStmt", v)?;
                }
                node::Node::DeleteStmt(v) => {
                    struct_ser.serialize_field("DeleteStmt", v)?;
                }
                node::Node::UpdateStmt(v) => {
                    struct_ser.serialize_field("UpdateStmt", v)?;
                }
                node::Node::MergeStmt(v) => {
                    struct_ser.serialize_field("MergeStmt", v)?;
                }
                node::Node::SelectStmt(v) => {
                    struct_ser.serialize_field("SelectStmt", v)?;
                }
                node::Node::SetOperationStmt(v) => {
                    struct_ser.serialize_field("SetOperationStmt", v)?;
                }
                node::Node::ReturnStmt(v) => {
                    struct_ser.serialize_field("ReturnStmt", v)?;
                }
                node::Node::PlassignStmt(v) => {
                    struct_ser.serialize_field("PLAssignStmt", v)?;
                }
                node::Node::CreateSchemaStmt(v) => {
                    struct_ser.serialize_field("CreateSchemaStmt", v)?;
                }
                node::Node::AlterTableStmt(v) => {
                    struct_ser.serialize_field("AlterTableStmt", v)?;
                }
                node::Node::ReplicaIdentityStmt(v) => {
                    struct_ser.serialize_field("ReplicaIdentityStmt", v)?;
                }
                node::Node::AlterTableCmd(v) => {
                    struct_ser.serialize_field("AlterTableCmd", v)?;
                }
                node::Node::AlterCollationStmt(v) => {
                    struct_ser.serialize_field("AlterCollationStmt", v)?;
                }
                node::Node::AlterDomainStmt(v) => {
                    struct_ser.serialize_field("AlterDomainStmt", v)?;
                }
                node::Node::GrantStmt(v) => {
                    struct_ser.serialize_field("GrantStmt", v)?;
                }
                node::Node::ObjectWithArgs(v) => {
                    struct_ser.serialize_field("ObjectWithArgs", v)?;
                }
                node::Node::AccessPriv(v) => {
                    struct_ser.serialize_field("AccessPriv", v)?;
                }
                node::Node::GrantRoleStmt(v) => {
                    struct_ser.serialize_field("GrantRoleStmt", v)?;
                }
                node::Node::AlterDefaultPrivilegesStmt(v) => {
                    struct_ser.serialize_field("AlterDefaultPrivilegesStmt", v)?;
                }
                node::Node::CopyStmt(v) => {
                    struct_ser.serialize_field("CopyStmt", v)?;
                }
                node::Node::VariableSetStmt(v) => {
                    struct_ser.serialize_field("VariableSetStmt", v)?;
                }
                node::Node::VariableShowStmt(v) => {
                    struct_ser.serialize_field("VariableShowStmt", v)?;
                }
                node::Node::CreateStmt(v) => {
                    struct_ser.serialize_field("CreateStmt", v)?;
                }
                node::Node::Constraint(v) => {
                    struct_ser.serialize_field("Constraint", v)?;
                }
                node::Node::CreateTableSpaceStmt(v) => {
                    struct_ser.serialize_field("CreateTableSpaceStmt", v)?;
                }
                node::Node::DropTableSpaceStmt(v) => {
                    struct_ser.serialize_field("DropTableSpaceStmt", v)?;
                }
                node::Node::AlterTableSpaceOptionsStmt(v) => {
                    struct_ser.serialize_field("AlterTableSpaceOptionsStmt", v)?;
                }
                node::Node::AlterTableMoveAllStmt(v) => {
                    struct_ser.serialize_field("AlterTableMoveAllStmt", v)?;
                }
                node::Node::CreateExtensionStmt(v) => {
                    struct_ser.serialize_field("CreateExtensionStmt", v)?;
                }
                node::Node::AlterExtensionStmt(v) => {
                    struct_ser.serialize_field("AlterExtensionStmt", v)?;
                }
                node::Node::AlterExtensionContentsStmt(v) => {
                    struct_ser.serialize_field("AlterExtensionContentsStmt", v)?;
                }
                node::Node::CreateFdwStmt(v) => {
                    struct_ser.serialize_field("CreateFdwStmt", v)?;
                }
                node::Node::AlterFdwStmt(v) => {
                    struct_ser.serialize_field("AlterFdwStmt", v)?;
                }
                node::Node::CreateForeignServerStmt(v) => {
                    struct_ser.serialize_field("CreateForeignServerStmt", v)?;
                }
                node::Node::AlterForeignServerStmt(v) => {
                    struct_ser.serialize_field("AlterForeignServerStmt", v)?;
                }
                node::Node::CreateForeignTableStmt(v) => {
                    struct_ser.serialize_field("CreateForeignTableStmt", v)?;
                }
                node::Node::CreateUserMappingStmt(v) => {
                    struct_ser.serialize_field("CreateUserMappingStmt", v)?;
                }
                node::Node::AlterUserMappingStmt(v) => {
                    struct_ser.serialize_field("AlterUserMappingStmt", v)?;
                }
                node::Node::DropUserMappingStmt(v) => {
                    struct_ser.serialize_field("DropUserMappingStmt", v)?;
                }
                node::Node::ImportForeignSchemaStmt(v) => {
                    struct_ser.serialize_field("ImportForeignSchemaStmt", v)?;
                }
                node::Node::CreatePolicyStmt(v) => {
                    struct_ser.serialize_field("CreatePolicyStmt", v)?;
                }
                node::Node::AlterPolicyStmt(v) => {
                    struct_ser.serialize_field("AlterPolicyStmt", v)?;
                }
                node::Node::CreateAmStmt(v) => {
                    struct_ser.serialize_field("CreateAmStmt", v)?;
                }
                node::Node::CreateTrigStmt(v) => {
                    struct_ser.serialize_field("CreateTrigStmt", v)?;
                }
                node::Node::CreateEventTrigStmt(v) => {
                    struct_ser.serialize_field("CreateEventTrigStmt", v)?;
                }
                node::Node::AlterEventTrigStmt(v) => {
                    struct_ser.serialize_field("AlterEventTrigStmt", v)?;
                }
                node::Node::CreatePlangStmt(v) => {
                    struct_ser.serialize_field("CreatePLangStmt", v)?;
                }
                node::Node::CreateRoleStmt(v) => {
                    struct_ser.serialize_field("CreateRoleStmt", v)?;
                }
                node::Node::AlterRoleStmt(v) => {
                    struct_ser.serialize_field("AlterRoleStmt", v)?;
                }
                node::Node::AlterRoleSetStmt(v) => {
                    struct_ser.serialize_field("AlterRoleSetStmt", v)?;
                }
                node::Node::DropRoleStmt(v) => {
                    struct_ser.serialize_field("DropRoleStmt", v)?;
                }
                node::Node::CreateSeqStmt(v) => {
                    struct_ser.serialize_field("CreateSeqStmt", v)?;
                }
                node::Node::AlterSeqStmt(v) => {
                    struct_ser.serialize_field("AlterSeqStmt", v)?;
                }
                node::Node::DefineStmt(v) => {
                    struct_ser.serialize_field("DefineStmt", v)?;
                }
                node::Node::CreateDomainStmt(v) => {
                    struct_ser.serialize_field("CreateDomainStmt", v)?;
                }
                node::Node::CreateOpClassStmt(v) => {
                    struct_ser.serialize_field("CreateOpClassStmt", v)?;
                }
                node::Node::CreateOpClassItem(v) => {
                    struct_ser.serialize_field("CreateOpClassItem", v)?;
                }
                node::Node::CreateOpFamilyStmt(v) => {
                    struct_ser.serialize_field("CreateOpFamilyStmt", v)?;
                }
                node::Node::AlterOpFamilyStmt(v) => {
                    struct_ser.serialize_field("AlterOpFamilyStmt", v)?;
                }
                node::Node::DropStmt(v) => {
                    struct_ser.serialize_field("DropStmt", v)?;
                }
                node::Node::TruncateStmt(v) => {
                    struct_ser.serialize_field("TruncateStmt", v)?;
                }
                node::Node::CommentStmt(v) => {
                    struct_ser.serialize_field("CommentStmt", v)?;
                }
                node::Node::SecLabelStmt(v) => {
                    struct_ser.serialize_field("SecLabelStmt", v)?;
                }
                node::Node::DeclareCursorStmt(v) => {
                    struct_ser.serialize_field("DeclareCursorStmt", v)?;
                }
                node::Node::ClosePortalStmt(v) => {
                    struct_ser.serialize_field("ClosePortalStmt", v)?;
                }
                node::Node::FetchStmt(v) => {
                    struct_ser.serialize_field("FetchStmt", v)?;
                }
                node::Node::IndexStmt(v) => {
                    struct_ser.serialize_field("IndexStmt", v)?;
                }
                node::Node::CreateStatsStmt(v) => {
                    struct_ser.serialize_field("CreateStatsStmt", v)?;
                }
                node::Node::StatsElem(v) => {
                    struct_ser.serialize_field("StatsElem", v)?;
                }
                node::Node::AlterStatsStmt(v) => {
                    struct_ser.serialize_field("AlterStatsStmt", v)?;
                }
                node::Node::CreateFunctionStmt(v) => {
                    struct_ser.serialize_field("CreateFunctionStmt", v)?;
                }
                node::Node::FunctionParameter(v) => {
                    struct_ser.serialize_field("FunctionParameter", v)?;
                }
                node::Node::AlterFunctionStmt(v) => {
                    struct_ser.serialize_field("AlterFunctionStmt", v)?;
                }
                node::Node::DoStmt(v) => {
                    struct_ser.serialize_field("DoStmt", v)?;
                }
                node::Node::InlineCodeBlock(v) => {
                    struct_ser.serialize_field("InlineCodeBlock", v)?;
                }
                node::Node::CallStmt(v) => {
                    struct_ser.serialize_field("CallStmt", v)?;
                }
                node::Node::CallContext(v) => {
                    struct_ser.serialize_field("CallContext", v)?;
                }
                node::Node::RenameStmt(v) => {
                    struct_ser.serialize_field("RenameStmt", v)?;
                }
                node::Node::AlterObjectDependsStmt(v) => {
                    struct_ser.serialize_field("AlterObjectDependsStmt", v)?;
                }
                node::Node::AlterObjectSchemaStmt(v) => {
                    struct_ser.serialize_field("AlterObjectSchemaStmt", v)?;
                }
                node::Node::AlterOwnerStmt(v) => {
                    struct_ser.serialize_field("AlterOwnerStmt", v)?;
                }
                node::Node::AlterOperatorStmt(v) => {
                    struct_ser.serialize_field("AlterOperatorStmt", v)?;
                }
                node::Node::AlterTypeStmt(v) => {
                    struct_ser.serialize_field("AlterTypeStmt", v)?;
                }
                node::Node::RuleStmt(v) => {
                    struct_ser.serialize_field("RuleStmt", v)?;
                }
                node::Node::NotifyStmt(v) => {
                    struct_ser.serialize_field("NotifyStmt", v)?;
                }
                node::Node::ListenStmt(v) => {
                    struct_ser.serialize_field("ListenStmt", v)?;
                }
                node::Node::UnlistenStmt(v) => {
                    struct_ser.serialize_field("UnlistenStmt", v)?;
                }
                node::Node::TransactionStmt(v) => {
                    struct_ser.serialize_field("TransactionStmt", v)?;
                }
                node::Node::CompositeTypeStmt(v) => {
                    struct_ser.serialize_field("CompositeTypeStmt", v)?;
                }
                node::Node::CreateEnumStmt(v) => {
                    struct_ser.serialize_field("CreateEnumStmt", v)?;
                }
                node::Node::CreateRangeStmt(v) => {
                    struct_ser.serialize_field("CreateRangeStmt", v)?;
                }
                node::Node::AlterEnumStmt(v) => {
                    struct_ser.serialize_field("AlterEnumStmt", v)?;
                }
                node::Node::ViewStmt(v) => {
                    struct_ser.serialize_field("ViewStmt", v)?;
                }
                node::Node::LoadStmt(v) => {
                    struct_ser.serialize_field("LoadStmt", v)?;
                }
                node::Node::CreatedbStmt(v) => {
                    struct_ser.serialize_field("CreatedbStmt", v)?;
                }
                node::Node::AlterDatabaseStmt(v) => {
                    struct_ser.serialize_field("AlterDatabaseStmt", v)?;
                }
                node::Node::AlterDatabaseRefreshCollStmt(v) => {
                    struct_ser.serialize_field("AlterDatabaseRefreshCollStmt", v)?;
                }
                node::Node::AlterDatabaseSetStmt(v) => {
                    struct_ser.serialize_field("AlterDatabaseSetStmt", v)?;
                }
                node::Node::DropdbStmt(v) => {
                    struct_ser.serialize_field("DropdbStmt", v)?;
                }
                node::Node::AlterSystemStmt(v) => {
                    struct_ser.serialize_field("AlterSystemStmt", v)?;
                }
                node::Node::ClusterStmt(v) => {
                    struct_ser.serialize_field("ClusterStmt", v)?;
                }
                node::Node::VacuumStmt(v) => {
                    struct_ser.serialize_field("VacuumStmt", v)?;
                }
                node::Node::VacuumRelation(v) => {
                    struct_ser.serialize_field("VacuumRelation", v)?;
                }
                node::Node::ExplainStmt(v) => {
                    struct_ser.serialize_field("ExplainStmt", v)?;
                }
                node::Node::CreateTableAsStmt(v) => {
                    struct_ser.serialize_field("CreateTableAsStmt", v)?;
                }
                node::Node::RefreshMatViewStmt(v) => {
                    struct_ser.serialize_field("RefreshMatViewStmt", v)?;
                }
                node::Node::CheckPointStmt(v) => {
                    struct_ser.serialize_field("CheckPointStmt", v)?;
                }
                node::Node::DiscardStmt(v) => {
                    struct_ser.serialize_field("DiscardStmt", v)?;
                }
                node::Node::LockStmt(v) => {
                    struct_ser.serialize_field("LockStmt", v)?;
                }
                node::Node::ConstraintsSetStmt(v) => {
                    struct_ser.serialize_field("ConstraintsSetStmt", v)?;
                }
                node::Node::ReindexStmt(v) => {
                    struct_ser.serialize_field("ReindexStmt", v)?;
                }
                node::Node::CreateConversionStmt(v) => {
                    struct_ser.serialize_field("CreateConversionStmt", v)?;
                }
                node::Node::CreateCastStmt(v) => {
                    struct_ser.serialize_field("CreateCastStmt", v)?;
                }
                node::Node::CreateTransformStmt(v) => {
                    struct_ser.serialize_field("CreateTransformStmt", v)?;
                }
                node::Node::PrepareStmt(v) => {
                    struct_ser.serialize_field("PrepareStmt", v)?;
                }
                node::Node::ExecuteStmt(v) => {
                    struct_ser.serialize_field("ExecuteStmt", v)?;
                }
                node::Node::DeallocateStmt(v) => {
                    struct_ser.serialize_field("DeallocateStmt", v)?;
                }
                node::Node::DropOwnedStmt(v) => {
                    struct_ser.serialize_field("DropOwnedStmt", v)?;
                }
                node::Node::ReassignOwnedStmt(v) => {
                    struct_ser.serialize_field("ReassignOwnedStmt", v)?;
                }
                node::Node::AlterTsdictionaryStmt(v) => {
                    struct_ser.serialize_field("AlterTSDictionaryStmt", v)?;
                }
                node::Node::AlterTsconfigurationStmt(v) => {
                    struct_ser.serialize_field("AlterTSConfigurationStmt", v)?;
                }
                node::Node::PublicationTable(v) => {
                    struct_ser.serialize_field("PublicationTable", v)?;
                }
                node::Node::PublicationObjSpec(v) => {
                    struct_ser.serialize_field("PublicationObjSpec", v)?;
                }
                node::Node::CreatePublicationStmt(v) => {
                    struct_ser.serialize_field("CreatePublicationStmt", v)?;
                }
                node::Node::AlterPublicationStmt(v) => {
                    struct_ser.serialize_field("AlterPublicationStmt", v)?;
                }
                node::Node::CreateSubscriptionStmt(v) => {
                    struct_ser.serialize_field("CreateSubscriptionStmt", v)?;
                }
                node::Node::AlterSubscriptionStmt(v) => {
                    struct_ser.serialize_field("AlterSubscriptionStmt", v)?;
                }
                node::Node::DropSubscriptionStmt(v) => {
                    struct_ser.serialize_field("DropSubscriptionStmt", v)?;
                }
                node::Node::Integer(v) => {
                    struct_ser.serialize_field("Integer", v)?;
                }
                node::Node::Float(v) => {
                    struct_ser.serialize_field("Float", v)?;
                }
                node::Node::Boolean(v) => {
                    struct_ser.serialize_field("Boolean", v)?;
                }
                node::Node::String(v) => {
                    struct_ser.serialize_field("String", v)?;
                }
                node::Node::BitString(v) => {
                    struct_ser.serialize_field("BitString", v)?;
                }
                node::Node::List(v) => {
                    struct_ser.serialize_field("List", v)?;
                }
                node::Node::IntList(v) => {
                    struct_ser.serialize_field("IntList", v)?;
                }
                node::Node::OidList(v) => {
                    struct_ser.serialize_field("OidList", v)?;
                }
                node::Node::AConst(v) => {
                    struct_ser.serialize_field("A_Const", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Node {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "alias",
            "Alias",
            "range_var",
            "RangeVar",
            "table_func",
            "TableFunc",
            "into_clause",
            "IntoClause",
            "var",
            "Var",
            "param",
            "Param",
            "aggref",
            "Aggref",
            "grouping_func",
            "GroupingFunc",
            "window_func",
            "WindowFunc",
            "subscripting_ref",
            "SubscriptingRef",
            "func_expr",
            "FuncExpr",
            "named_arg_expr",
            "NamedArgExpr",
            "op_expr",
            "OpExpr",
            "distinct_expr",
            "DistinctExpr",
            "null_if_expr",
            "NullIfExpr",
            "scalar_array_op_expr",
            "ScalarArrayOpExpr",
            "bool_expr",
            "BoolExpr",
            "sub_link",
            "SubLink",
            "sub_plan",
            "SubPlan",
            "alternative_sub_plan",
            "AlternativeSubPlan",
            "field_select",
            "FieldSelect",
            "field_store",
            "FieldStore",
            "relabel_type",
            "RelabelType",
            "coerce_via_io",
            "CoerceViaIO",
            "array_coerce_expr",
            "ArrayCoerceExpr",
            "convert_rowtype_expr",
            "ConvertRowtypeExpr",
            "collate_expr",
            "CollateExpr",
            "case_expr",
            "CaseExpr",
            "case_when",
            "CaseWhen",
            "case_test_expr",
            "CaseTestExpr",
            "array_expr",
            "ArrayExpr",
            "row_expr",
            "RowExpr",
            "row_compare_expr",
            "RowCompareExpr",
            "coalesce_expr",
            "CoalesceExpr",
            "min_max_expr",
            "MinMaxExpr",
            "sqlvalue_function",
            "SQLValueFunction",
            "xml_expr",
            "XmlExpr",
            "json_format",
            "JsonFormat",
            "json_returning",
            "JsonReturning",
            "json_value_expr",
            "JsonValueExpr",
            "json_constructor_expr",
            "JsonConstructorExpr",
            "json_is_predicate",
            "JsonIsPredicate",
            "null_test",
            "NullTest",
            "boolean_test",
            "BooleanTest",
            "coerce_to_domain",
            "CoerceToDomain",
            "coerce_to_domain_value",
            "CoerceToDomainValue",
            "set_to_default",
            "SetToDefault",
            "current_of_expr",
            "CurrentOfExpr",
            "next_value_expr",
            "NextValueExpr",
            "inference_elem",
            "InferenceElem",
            "target_entry",
            "TargetEntry",
            "range_tbl_ref",
            "RangeTblRef",
            "join_expr",
            "JoinExpr",
            "from_expr",
            "FromExpr",
            "on_conflict_expr",
            "OnConflictExpr",
            "query",
            "Query",
            "type_name",
            "TypeName",
            "column_ref",
            "ColumnRef",
            "param_ref",
            "ParamRef",
            "a_expr",
            "A_Expr",
            "type_cast",
            "TypeCast",
            "collate_clause",
            "CollateClause",
            "role_spec",
            "RoleSpec",
            "func_call",
            "FuncCall",
            "a_star",
            "A_Star",
            "a_indices",
            "A_Indices",
            "a_indirection",
            "A_Indirection",
            "a_array_expr",
            "A_ArrayExpr",
            "res_target",
            "ResTarget",
            "multi_assign_ref",
            "MultiAssignRef",
            "sort_by",
            "SortBy",
            "window_def",
            "WindowDef",
            "range_subselect",
            "RangeSubselect",
            "range_function",
            "RangeFunction",
            "range_table_func",
            "RangeTableFunc",
            "range_table_func_col",
            "RangeTableFuncCol",
            "range_table_sample",
            "RangeTableSample",
            "column_def",
            "ColumnDef",
            "table_like_clause",
            "TableLikeClause",
            "index_elem",
            "IndexElem",
            "def_elem",
            "DefElem",
            "locking_clause",
            "LockingClause",
            "xml_serialize",
            "XmlSerialize",
            "partition_elem",
            "PartitionElem",
            "partition_spec",
            "PartitionSpec",
            "partition_bound_spec",
            "PartitionBoundSpec",
            "partition_range_datum",
            "PartitionRangeDatum",
            "partition_cmd",
            "PartitionCmd",
            "range_tbl_entry",
            "RangeTblEntry",
            "rtepermission_info",
            "RTEPermissionInfo",
            "range_tbl_function",
            "RangeTblFunction",
            "table_sample_clause",
            "TableSampleClause",
            "with_check_option",
            "WithCheckOption",
            "sort_group_clause",
            "SortGroupClause",
            "grouping_set",
            "GroupingSet",
            "window_clause",
            "WindowClause",
            "row_mark_clause",
            "RowMarkClause",
            "with_clause",
            "WithClause",
            "infer_clause",
            "InferClause",
            "on_conflict_clause",
            "OnConflictClause",
            "ctesearch_clause",
            "CTESearchClause",
            "ctecycle_clause",
            "CTECycleClause",
            "common_table_expr",
            "CommonTableExpr",
            "merge_when_clause",
            "MergeWhenClause",
            "merge_action",
            "MergeAction",
            "trigger_transition",
            "TriggerTransition",
            "json_output",
            "JsonOutput",
            "json_key_value",
            "JsonKeyValue",
            "json_object_constructor",
            "JsonObjectConstructor",
            "json_array_constructor",
            "JsonArrayConstructor",
            "json_array_query_constructor",
            "JsonArrayQueryConstructor",
            "json_agg_constructor",
            "JsonAggConstructor",
            "json_object_agg",
            "JsonObjectAgg",
            "json_array_agg",
            "JsonArrayAgg",
            "raw_stmt",
            "RawStmt",
            "insert_stmt",
            "InsertStmt",
            "delete_stmt",
            "DeleteStmt",
            "update_stmt",
            "UpdateStmt",
            "merge_stmt",
            "MergeStmt",
            "select_stmt",
            "SelectStmt",
            "set_operation_stmt",
            "SetOperationStmt",
            "return_stmt",
            "ReturnStmt",
            "plassign_stmt",
            "PLAssignStmt",
            "create_schema_stmt",
            "CreateSchemaStmt",
            "alter_table_stmt",
            "AlterTableStmt",
            "replica_identity_stmt",
            "ReplicaIdentityStmt",
            "alter_table_cmd",
            "AlterTableCmd",
            "alter_collation_stmt",
            "AlterCollationStmt",
            "alter_domain_stmt",
            "AlterDomainStmt",
            "grant_stmt",
            "GrantStmt",
            "object_with_args",
            "ObjectWithArgs",
            "access_priv",
            "AccessPriv",
            "grant_role_stmt",
            "GrantRoleStmt",
            "alter_default_privileges_stmt",
            "AlterDefaultPrivilegesStmt",
            "copy_stmt",
            "CopyStmt",
            "variable_set_stmt",
            "VariableSetStmt",
            "variable_show_stmt",
            "VariableShowStmt",
            "create_stmt",
            "CreateStmt",
            "constraint",
            "Constraint",
            "create_table_space_stmt",
            "CreateTableSpaceStmt",
            "drop_table_space_stmt",
            "DropTableSpaceStmt",
            "alter_table_space_options_stmt",
            "AlterTableSpaceOptionsStmt",
            "alter_table_move_all_stmt",
            "AlterTableMoveAllStmt",
            "create_extension_stmt",
            "CreateExtensionStmt",
            "alter_extension_stmt",
            "AlterExtensionStmt",
            "alter_extension_contents_stmt",
            "AlterExtensionContentsStmt",
            "create_fdw_stmt",
            "CreateFdwStmt",
            "alter_fdw_stmt",
            "AlterFdwStmt",
            "create_foreign_server_stmt",
            "CreateForeignServerStmt",
            "alter_foreign_server_stmt",
            "AlterForeignServerStmt",
            "create_foreign_table_stmt",
            "CreateForeignTableStmt",
            "create_user_mapping_stmt",
            "CreateUserMappingStmt",
            "alter_user_mapping_stmt",
            "AlterUserMappingStmt",
            "drop_user_mapping_stmt",
            "DropUserMappingStmt",
            "import_foreign_schema_stmt",
            "ImportForeignSchemaStmt",
            "create_policy_stmt",
            "CreatePolicyStmt",
            "alter_policy_stmt",
            "AlterPolicyStmt",
            "create_am_stmt",
            "CreateAmStmt",
            "create_trig_stmt",
            "CreateTrigStmt",
            "create_event_trig_stmt",
            "CreateEventTrigStmt",
            "alter_event_trig_stmt",
            "AlterEventTrigStmt",
            "create_plang_stmt",
            "CreatePLangStmt",
            "create_role_stmt",
            "CreateRoleStmt",
            "alter_role_stmt",
            "AlterRoleStmt",
            "alter_role_set_stmt",
            "AlterRoleSetStmt",
            "drop_role_stmt",
            "DropRoleStmt",
            "create_seq_stmt",
            "CreateSeqStmt",
            "alter_seq_stmt",
            "AlterSeqStmt",
            "define_stmt",
            "DefineStmt",
            "create_domain_stmt",
            "CreateDomainStmt",
            "create_op_class_stmt",
            "CreateOpClassStmt",
            "create_op_class_item",
            "CreateOpClassItem",
            "create_op_family_stmt",
            "CreateOpFamilyStmt",
            "alter_op_family_stmt",
            "AlterOpFamilyStmt",
            "drop_stmt",
            "DropStmt",
            "truncate_stmt",
            "TruncateStmt",
            "comment_stmt",
            "CommentStmt",
            "sec_label_stmt",
            "SecLabelStmt",
            "declare_cursor_stmt",
            "DeclareCursorStmt",
            "close_portal_stmt",
            "ClosePortalStmt",
            "fetch_stmt",
            "FetchStmt",
            "index_stmt",
            "IndexStmt",
            "create_stats_stmt",
            "CreateStatsStmt",
            "stats_elem",
            "StatsElem",
            "alter_stats_stmt",
            "AlterStatsStmt",
            "create_function_stmt",
            "CreateFunctionStmt",
            "function_parameter",
            "FunctionParameter",
            "alter_function_stmt",
            "AlterFunctionStmt",
            "do_stmt",
            "DoStmt",
            "inline_code_block",
            "InlineCodeBlock",
            "call_stmt",
            "CallStmt",
            "call_context",
            "CallContext",
            "rename_stmt",
            "RenameStmt",
            "alter_object_depends_stmt",
            "AlterObjectDependsStmt",
            "alter_object_schema_stmt",
            "AlterObjectSchemaStmt",
            "alter_owner_stmt",
            "AlterOwnerStmt",
            "alter_operator_stmt",
            "AlterOperatorStmt",
            "alter_type_stmt",
            "AlterTypeStmt",
            "rule_stmt",
            "RuleStmt",
            "notify_stmt",
            "NotifyStmt",
            "listen_stmt",
            "ListenStmt",
            "unlisten_stmt",
            "UnlistenStmt",
            "transaction_stmt",
            "TransactionStmt",
            "composite_type_stmt",
            "CompositeTypeStmt",
            "create_enum_stmt",
            "CreateEnumStmt",
            "create_range_stmt",
            "CreateRangeStmt",
            "alter_enum_stmt",
            "AlterEnumStmt",
            "view_stmt",
            "ViewStmt",
            "load_stmt",
            "LoadStmt",
            "createdb_stmt",
            "CreatedbStmt",
            "alter_database_stmt",
            "AlterDatabaseStmt",
            "alter_database_refresh_coll_stmt",
            "AlterDatabaseRefreshCollStmt",
            "alter_database_set_stmt",
            "AlterDatabaseSetStmt",
            "dropdb_stmt",
            "DropdbStmt",
            "alter_system_stmt",
            "AlterSystemStmt",
            "cluster_stmt",
            "ClusterStmt",
            "vacuum_stmt",
            "VacuumStmt",
            "vacuum_relation",
            "VacuumRelation",
            "explain_stmt",
            "ExplainStmt",
            "create_table_as_stmt",
            "CreateTableAsStmt",
            "refresh_mat_view_stmt",
            "RefreshMatViewStmt",
            "check_point_stmt",
            "CheckPointStmt",
            "discard_stmt",
            "DiscardStmt",
            "lock_stmt",
            "LockStmt",
            "constraints_set_stmt",
            "ConstraintsSetStmt",
            "reindex_stmt",
            "ReindexStmt",
            "create_conversion_stmt",
            "CreateConversionStmt",
            "create_cast_stmt",
            "CreateCastStmt",
            "create_transform_stmt",
            "CreateTransformStmt",
            "prepare_stmt",
            "PrepareStmt",
            "execute_stmt",
            "ExecuteStmt",
            "deallocate_stmt",
            "DeallocateStmt",
            "drop_owned_stmt",
            "DropOwnedStmt",
            "reassign_owned_stmt",
            "ReassignOwnedStmt",
            "alter_tsdictionary_stmt",
            "AlterTSDictionaryStmt",
            "alter_tsconfiguration_stmt",
            "AlterTSConfigurationStmt",
            "publication_table",
            "PublicationTable",
            "publication_obj_spec",
            "PublicationObjSpec",
            "create_publication_stmt",
            "CreatePublicationStmt",
            "alter_publication_stmt",
            "AlterPublicationStmt",
            "create_subscription_stmt",
            "CreateSubscriptionStmt",
            "alter_subscription_stmt",
            "AlterSubscriptionStmt",
            "drop_subscription_stmt",
            "DropSubscriptionStmt",
            "integer",
            "Integer",
            "float",
            "Float",
            "boolean",
            "Boolean",
            "string",
            "String",
            "bit_string",
            "BitString",
            "list",
            "List",
            "int_list",
            "IntList",
            "oid_list",
            "OidList",
            "a_const",
            "A_Const",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Alias,
            RangeVar,
            TableFunc,
            IntoClause,
            Var,
            Param,
            Aggref,
            GroupingFunc,
            WindowFunc,
            SubscriptingRef,
            FuncExpr,
            NamedArgExpr,
            OpExpr,
            DistinctExpr,
            NullIfExpr,
            ScalarArrayOpExpr,
            BoolExpr,
            SubLink,
            SubPlan,
            AlternativeSubPlan,
            FieldSelect,
            FieldStore,
            RelabelType,
            CoerceViaIo,
            ArrayCoerceExpr,
            ConvertRowtypeExpr,
            CollateExpr,
            CaseExpr,
            CaseWhen,
            CaseTestExpr,
            ArrayExpr,
            RowExpr,
            RowCompareExpr,
            CoalesceExpr,
            MinMaxExpr,
            SqlvalueFunction,
            XmlExpr,
            JsonFormat,
            JsonReturning,
            JsonValueExpr,
            JsonConstructorExpr,
            JsonIsPredicate,
            NullTest,
            BooleanTest,
            CoerceToDomain,
            CoerceToDomainValue,
            SetToDefault,
            CurrentOfExpr,
            NextValueExpr,
            InferenceElem,
            TargetEntry,
            RangeTblRef,
            JoinExpr,
            FromExpr,
            OnConflictExpr,
            Query,
            TypeName,
            ColumnRef,
            ParamRef,
            AExpr,
            TypeCast,
            CollateClause,
            RoleSpec,
            FuncCall,
            AStar,
            AIndices,
            AIndirection,
            AArrayExpr,
            ResTarget,
            MultiAssignRef,
            SortBy,
            WindowDef,
            RangeSubselect,
            RangeFunction,
            RangeTableFunc,
            RangeTableFuncCol,
            RangeTableSample,
            ColumnDef,
            TableLikeClause,
            IndexElem,
            DefElem,
            LockingClause,
            XmlSerialize,
            PartitionElem,
            PartitionSpec,
            PartitionBoundSpec,
            PartitionRangeDatum,
            PartitionCmd,
            RangeTblEntry,
            RtepermissionInfo,
            RangeTblFunction,
            TableSampleClause,
            WithCheckOption,
            SortGroupClause,
            GroupingSet,
            WindowClause,
            RowMarkClause,
            WithClause,
            InferClause,
            OnConflictClause,
            CtesearchClause,
            CtecycleClause,
            CommonTableExpr,
            MergeWhenClause,
            MergeAction,
            TriggerTransition,
            JsonOutput,
            JsonKeyValue,
            JsonObjectConstructor,
            JsonArrayConstructor,
            JsonArrayQueryConstructor,
            JsonAggConstructor,
            JsonObjectAgg,
            JsonArrayAgg,
            RawStmt,
            InsertStmt,
            DeleteStmt,
            UpdateStmt,
            MergeStmt,
            SelectStmt,
            SetOperationStmt,
            ReturnStmt,
            PlassignStmt,
            CreateSchemaStmt,
            AlterTableStmt,
            ReplicaIdentityStmt,
            AlterTableCmd,
            AlterCollationStmt,
            AlterDomainStmt,
            GrantStmt,
            ObjectWithArgs,
            AccessPriv,
            GrantRoleStmt,
            AlterDefaultPrivilegesStmt,
            CopyStmt,
            VariableSetStmt,
            VariableShowStmt,
            CreateStmt,
            Constraint,
            CreateTableSpaceStmt,
            DropTableSpaceStmt,
            AlterTableSpaceOptionsStmt,
            AlterTableMoveAllStmt,
            CreateExtensionStmt,
            AlterExtensionStmt,
            AlterExtensionContentsStmt,
            CreateFdwStmt,
            AlterFdwStmt,
            CreateForeignServerStmt,
            AlterForeignServerStmt,
            CreateForeignTableStmt,
            CreateUserMappingStmt,
            AlterUserMappingStmt,
            DropUserMappingStmt,
            ImportForeignSchemaStmt,
            CreatePolicyStmt,
            AlterPolicyStmt,
            CreateAmStmt,
            CreateTrigStmt,
            CreateEventTrigStmt,
            AlterEventTrigStmt,
            CreatePlangStmt,
            CreateRoleStmt,
            AlterRoleStmt,
            AlterRoleSetStmt,
            DropRoleStmt,
            CreateSeqStmt,
            AlterSeqStmt,
            DefineStmt,
            CreateDomainStmt,
            CreateOpClassStmt,
            CreateOpClassItem,
            CreateOpFamilyStmt,
            AlterOpFamilyStmt,
            DropStmt,
            TruncateStmt,
            CommentStmt,
            SecLabelStmt,
            DeclareCursorStmt,
            ClosePortalStmt,
            FetchStmt,
            IndexStmt,
            CreateStatsStmt,
            StatsElem,
            AlterStatsStmt,
            CreateFunctionStmt,
            FunctionParameter,
            AlterFunctionStmt,
            DoStmt,
            InlineCodeBlock,
            CallStmt,
            CallContext,
            RenameStmt,
            AlterObjectDependsStmt,
            AlterObjectSchemaStmt,
            AlterOwnerStmt,
            AlterOperatorStmt,
            AlterTypeStmt,
            RuleStmt,
            NotifyStmt,
            ListenStmt,
            UnlistenStmt,
            TransactionStmt,
            CompositeTypeStmt,
            CreateEnumStmt,
            CreateRangeStmt,
            AlterEnumStmt,
            ViewStmt,
            LoadStmt,
            CreatedbStmt,
            AlterDatabaseStmt,
            AlterDatabaseRefreshCollStmt,
            AlterDatabaseSetStmt,
            DropdbStmt,
            AlterSystemStmt,
            ClusterStmt,
            VacuumStmt,
            VacuumRelation,
            ExplainStmt,
            CreateTableAsStmt,
            RefreshMatViewStmt,
            CheckPointStmt,
            DiscardStmt,
            LockStmt,
            ConstraintsSetStmt,
            ReindexStmt,
            CreateConversionStmt,
            CreateCastStmt,
            CreateTransformStmt,
            PrepareStmt,
            ExecuteStmt,
            DeallocateStmt,
            DropOwnedStmt,
            ReassignOwnedStmt,
            AlterTsdictionaryStmt,
            AlterTsconfigurationStmt,
            PublicationTable,
            PublicationObjSpec,
            CreatePublicationStmt,
            AlterPublicationStmt,
            CreateSubscriptionStmt,
            AlterSubscriptionStmt,
            DropSubscriptionStmt,
            Integer,
            Float,
            Boolean,
            String,
            BitString,
            List,
            IntList,
            OidList,
            AConst,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Alias" | "alias" => Ok(GeneratedField::Alias),
                            "RangeVar" | "range_var" => Ok(GeneratedField::RangeVar),
                            "TableFunc" | "table_func" => Ok(GeneratedField::TableFunc),
                            "IntoClause" | "into_clause" => Ok(GeneratedField::IntoClause),
                            "Var" | "var" => Ok(GeneratedField::Var),
                            "Param" | "param" => Ok(GeneratedField::Param),
                            "Aggref" | "aggref" => Ok(GeneratedField::Aggref),
                            "GroupingFunc" | "grouping_func" => Ok(GeneratedField::GroupingFunc),
                            "WindowFunc" | "window_func" => Ok(GeneratedField::WindowFunc),
                            "SubscriptingRef" | "subscripting_ref" => Ok(GeneratedField::SubscriptingRef),
                            "FuncExpr" | "func_expr" => Ok(GeneratedField::FuncExpr),
                            "NamedArgExpr" | "named_arg_expr" => Ok(GeneratedField::NamedArgExpr),
                            "OpExpr" | "op_expr" => Ok(GeneratedField::OpExpr),
                            "DistinctExpr" | "distinct_expr" => Ok(GeneratedField::DistinctExpr),
                            "NullIfExpr" | "null_if_expr" => Ok(GeneratedField::NullIfExpr),
                            "ScalarArrayOpExpr" | "scalar_array_op_expr" => Ok(GeneratedField::ScalarArrayOpExpr),
                            "BoolExpr" | "bool_expr" => Ok(GeneratedField::BoolExpr),
                            "SubLink" | "sub_link" => Ok(GeneratedField::SubLink),
                            "SubPlan" | "sub_plan" => Ok(GeneratedField::SubPlan),
                            "AlternativeSubPlan" | "alternative_sub_plan" => Ok(GeneratedField::AlternativeSubPlan),
                            "FieldSelect" | "field_select" => Ok(GeneratedField::FieldSelect),
                            "FieldStore" | "field_store" => Ok(GeneratedField::FieldStore),
                            "RelabelType" | "relabel_type" => Ok(GeneratedField::RelabelType),
                            "CoerceViaIO" | "coerce_via_io" => Ok(GeneratedField::CoerceViaIo),
                            "ArrayCoerceExpr" | "array_coerce_expr" => Ok(GeneratedField::ArrayCoerceExpr),
                            "ConvertRowtypeExpr" | "convert_rowtype_expr" => Ok(GeneratedField::ConvertRowtypeExpr),
                            "CollateExpr" | "collate_expr" => Ok(GeneratedField::CollateExpr),
                            "CaseExpr" | "case_expr" => Ok(GeneratedField::CaseExpr),
                            "CaseWhen" | "case_when" => Ok(GeneratedField::CaseWhen),
                            "CaseTestExpr" | "case_test_expr" => Ok(GeneratedField::CaseTestExpr),
                            "ArrayExpr" | "array_expr" => Ok(GeneratedField::ArrayExpr),
                            "RowExpr" | "row_expr" => Ok(GeneratedField::RowExpr),
                            "RowCompareExpr" | "row_compare_expr" => Ok(GeneratedField::RowCompareExpr),
                            "CoalesceExpr" | "coalesce_expr" => Ok(GeneratedField::CoalesceExpr),
                            "MinMaxExpr" | "min_max_expr" => Ok(GeneratedField::MinMaxExpr),
                            "SQLValueFunction" | "sqlvalue_function" => Ok(GeneratedField::SqlvalueFunction),
                            "XmlExpr" | "xml_expr" => Ok(GeneratedField::XmlExpr),
                            "JsonFormat" | "json_format" => Ok(GeneratedField::JsonFormat),
                            "JsonReturning" | "json_returning" => Ok(GeneratedField::JsonReturning),
                            "JsonValueExpr" | "json_value_expr" => Ok(GeneratedField::JsonValueExpr),
                            "JsonConstructorExpr" | "json_constructor_expr" => Ok(GeneratedField::JsonConstructorExpr),
                            "JsonIsPredicate" | "json_is_predicate" => Ok(GeneratedField::JsonIsPredicate),
                            "NullTest" | "null_test" => Ok(GeneratedField::NullTest),
                            "BooleanTest" | "boolean_test" => Ok(GeneratedField::BooleanTest),
                            "CoerceToDomain" | "coerce_to_domain" => Ok(GeneratedField::CoerceToDomain),
                            "CoerceToDomainValue" | "coerce_to_domain_value" => Ok(GeneratedField::CoerceToDomainValue),
                            "SetToDefault" | "set_to_default" => Ok(GeneratedField::SetToDefault),
                            "CurrentOfExpr" | "current_of_expr" => Ok(GeneratedField::CurrentOfExpr),
                            "NextValueExpr" | "next_value_expr" => Ok(GeneratedField::NextValueExpr),
                            "InferenceElem" | "inference_elem" => Ok(GeneratedField::InferenceElem),
                            "TargetEntry" | "target_entry" => Ok(GeneratedField::TargetEntry),
                            "RangeTblRef" | "range_tbl_ref" => Ok(GeneratedField::RangeTblRef),
                            "JoinExpr" | "join_expr" => Ok(GeneratedField::JoinExpr),
                            "FromExpr" | "from_expr" => Ok(GeneratedField::FromExpr),
                            "OnConflictExpr" | "on_conflict_expr" => Ok(GeneratedField::OnConflictExpr),
                            "Query" | "query" => Ok(GeneratedField::Query),
                            "TypeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "ColumnRef" | "column_ref" => Ok(GeneratedField::ColumnRef),
                            "ParamRef" | "param_ref" => Ok(GeneratedField::ParamRef),
                            "A_Expr" | "a_expr" => Ok(GeneratedField::AExpr),
                            "TypeCast" | "type_cast" => Ok(GeneratedField::TypeCast),
                            "CollateClause" | "collate_clause" => Ok(GeneratedField::CollateClause),
                            "RoleSpec" | "role_spec" => Ok(GeneratedField::RoleSpec),
                            "FuncCall" | "func_call" => Ok(GeneratedField::FuncCall),
                            "A_Star" | "a_star" => Ok(GeneratedField::AStar),
                            "A_Indices" | "a_indices" => Ok(GeneratedField::AIndices),
                            "A_Indirection" | "a_indirection" => Ok(GeneratedField::AIndirection),
                            "A_ArrayExpr" | "a_array_expr" => Ok(GeneratedField::AArrayExpr),
                            "ResTarget" | "res_target" => Ok(GeneratedField::ResTarget),
                            "MultiAssignRef" | "multi_assign_ref" => Ok(GeneratedField::MultiAssignRef),
                            "SortBy" | "sort_by" => Ok(GeneratedField::SortBy),
                            "WindowDef" | "window_def" => Ok(GeneratedField::WindowDef),
                            "RangeSubselect" | "range_subselect" => Ok(GeneratedField::RangeSubselect),
                            "RangeFunction" | "range_function" => Ok(GeneratedField::RangeFunction),
                            "RangeTableFunc" | "range_table_func" => Ok(GeneratedField::RangeTableFunc),
                            "RangeTableFuncCol" | "range_table_func_col" => Ok(GeneratedField::RangeTableFuncCol),
                            "RangeTableSample" | "range_table_sample" => Ok(GeneratedField::RangeTableSample),
                            "ColumnDef" | "column_def" => Ok(GeneratedField::ColumnDef),
                            "TableLikeClause" | "table_like_clause" => Ok(GeneratedField::TableLikeClause),
                            "IndexElem" | "index_elem" => Ok(GeneratedField::IndexElem),
                            "DefElem" | "def_elem" => Ok(GeneratedField::DefElem),
                            "LockingClause" | "locking_clause" => Ok(GeneratedField::LockingClause),
                            "XmlSerialize" | "xml_serialize" => Ok(GeneratedField::XmlSerialize),
                            "PartitionElem" | "partition_elem" => Ok(GeneratedField::PartitionElem),
                            "PartitionSpec" | "partition_spec" => Ok(GeneratedField::PartitionSpec),
                            "PartitionBoundSpec" | "partition_bound_spec" => Ok(GeneratedField::PartitionBoundSpec),
                            "PartitionRangeDatum" | "partition_range_datum" => Ok(GeneratedField::PartitionRangeDatum),
                            "PartitionCmd" | "partition_cmd" => Ok(GeneratedField::PartitionCmd),
                            "RangeTblEntry" | "range_tbl_entry" => Ok(GeneratedField::RangeTblEntry),
                            "RTEPermissionInfo" | "rtepermission_info" => Ok(GeneratedField::RtepermissionInfo),
                            "RangeTblFunction" | "range_tbl_function" => Ok(GeneratedField::RangeTblFunction),
                            "TableSampleClause" | "table_sample_clause" => Ok(GeneratedField::TableSampleClause),
                            "WithCheckOption" | "with_check_option" => Ok(GeneratedField::WithCheckOption),
                            "SortGroupClause" | "sort_group_clause" => Ok(GeneratedField::SortGroupClause),
                            "GroupingSet" | "grouping_set" => Ok(GeneratedField::GroupingSet),
                            "WindowClause" | "window_clause" => Ok(GeneratedField::WindowClause),
                            "RowMarkClause" | "row_mark_clause" => Ok(GeneratedField::RowMarkClause),
                            "WithClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            "InferClause" | "infer_clause" => Ok(GeneratedField::InferClause),
                            "OnConflictClause" | "on_conflict_clause" => Ok(GeneratedField::OnConflictClause),
                            "CTESearchClause" | "ctesearch_clause" => Ok(GeneratedField::CtesearchClause),
                            "CTECycleClause" | "ctecycle_clause" => Ok(GeneratedField::CtecycleClause),
                            "CommonTableExpr" | "common_table_expr" => Ok(GeneratedField::CommonTableExpr),
                            "MergeWhenClause" | "merge_when_clause" => Ok(GeneratedField::MergeWhenClause),
                            "MergeAction" | "merge_action" => Ok(GeneratedField::MergeAction),
                            "TriggerTransition" | "trigger_transition" => Ok(GeneratedField::TriggerTransition),
                            "JsonOutput" | "json_output" => Ok(GeneratedField::JsonOutput),
                            "JsonKeyValue" | "json_key_value" => Ok(GeneratedField::JsonKeyValue),
                            "JsonObjectConstructor" | "json_object_constructor" => Ok(GeneratedField::JsonObjectConstructor),
                            "JsonArrayConstructor" | "json_array_constructor" => Ok(GeneratedField::JsonArrayConstructor),
                            "JsonArrayQueryConstructor" | "json_array_query_constructor" => Ok(GeneratedField::JsonArrayQueryConstructor),
                            "JsonAggConstructor" | "json_agg_constructor" => Ok(GeneratedField::JsonAggConstructor),
                            "JsonObjectAgg" | "json_object_agg" => Ok(GeneratedField::JsonObjectAgg),
                            "JsonArrayAgg" | "json_array_agg" => Ok(GeneratedField::JsonArrayAgg),
                            "RawStmt" | "raw_stmt" => Ok(GeneratedField::RawStmt),
                            "InsertStmt" | "insert_stmt" => Ok(GeneratedField::InsertStmt),
                            "DeleteStmt" | "delete_stmt" => Ok(GeneratedField::DeleteStmt),
                            "UpdateStmt" | "update_stmt" => Ok(GeneratedField::UpdateStmt),
                            "MergeStmt" | "merge_stmt" => Ok(GeneratedField::MergeStmt),
                            "SelectStmt" | "select_stmt" => Ok(GeneratedField::SelectStmt),
                            "SetOperationStmt" | "set_operation_stmt" => Ok(GeneratedField::SetOperationStmt),
                            "ReturnStmt" | "return_stmt" => Ok(GeneratedField::ReturnStmt),
                            "PLAssignStmt" | "plassign_stmt" => Ok(GeneratedField::PlassignStmt),
                            "CreateSchemaStmt" | "create_schema_stmt" => Ok(GeneratedField::CreateSchemaStmt),
                            "AlterTableStmt" | "alter_table_stmt" => Ok(GeneratedField::AlterTableStmt),
                            "ReplicaIdentityStmt" | "replica_identity_stmt" => Ok(GeneratedField::ReplicaIdentityStmt),
                            "AlterTableCmd" | "alter_table_cmd" => Ok(GeneratedField::AlterTableCmd),
                            "AlterCollationStmt" | "alter_collation_stmt" => Ok(GeneratedField::AlterCollationStmt),
                            "AlterDomainStmt" | "alter_domain_stmt" => Ok(GeneratedField::AlterDomainStmt),
                            "GrantStmt" | "grant_stmt" => Ok(GeneratedField::GrantStmt),
                            "ObjectWithArgs" | "object_with_args" => Ok(GeneratedField::ObjectWithArgs),
                            "AccessPriv" | "access_priv" => Ok(GeneratedField::AccessPriv),
                            "GrantRoleStmt" | "grant_role_stmt" => Ok(GeneratedField::GrantRoleStmt),
                            "AlterDefaultPrivilegesStmt" | "alter_default_privileges_stmt" => Ok(GeneratedField::AlterDefaultPrivilegesStmt),
                            "CopyStmt" | "copy_stmt" => Ok(GeneratedField::CopyStmt),
                            "VariableSetStmt" | "variable_set_stmt" => Ok(GeneratedField::VariableSetStmt),
                            "VariableShowStmt" | "variable_show_stmt" => Ok(GeneratedField::VariableShowStmt),
                            "CreateStmt" | "create_stmt" => Ok(GeneratedField::CreateStmt),
                            "Constraint" | "constraint" => Ok(GeneratedField::Constraint),
                            "CreateTableSpaceStmt" | "create_table_space_stmt" => Ok(GeneratedField::CreateTableSpaceStmt),
                            "DropTableSpaceStmt" | "drop_table_space_stmt" => Ok(GeneratedField::DropTableSpaceStmt),
                            "AlterTableSpaceOptionsStmt" | "alter_table_space_options_stmt" => Ok(GeneratedField::AlterTableSpaceOptionsStmt),
                            "AlterTableMoveAllStmt" | "alter_table_move_all_stmt" => Ok(GeneratedField::AlterTableMoveAllStmt),
                            "CreateExtensionStmt" | "create_extension_stmt" => Ok(GeneratedField::CreateExtensionStmt),
                            "AlterExtensionStmt" | "alter_extension_stmt" => Ok(GeneratedField::AlterExtensionStmt),
                            "AlterExtensionContentsStmt" | "alter_extension_contents_stmt" => Ok(GeneratedField::AlterExtensionContentsStmt),
                            "CreateFdwStmt" | "create_fdw_stmt" => Ok(GeneratedField::CreateFdwStmt),
                            "AlterFdwStmt" | "alter_fdw_stmt" => Ok(GeneratedField::AlterFdwStmt),
                            "CreateForeignServerStmt" | "create_foreign_server_stmt" => Ok(GeneratedField::CreateForeignServerStmt),
                            "AlterForeignServerStmt" | "alter_foreign_server_stmt" => Ok(GeneratedField::AlterForeignServerStmt),
                            "CreateForeignTableStmt" | "create_foreign_table_stmt" => Ok(GeneratedField::CreateForeignTableStmt),
                            "CreateUserMappingStmt" | "create_user_mapping_stmt" => Ok(GeneratedField::CreateUserMappingStmt),
                            "AlterUserMappingStmt" | "alter_user_mapping_stmt" => Ok(GeneratedField::AlterUserMappingStmt),
                            "DropUserMappingStmt" | "drop_user_mapping_stmt" => Ok(GeneratedField::DropUserMappingStmt),
                            "ImportForeignSchemaStmt" | "import_foreign_schema_stmt" => Ok(GeneratedField::ImportForeignSchemaStmt),
                            "CreatePolicyStmt" | "create_policy_stmt" => Ok(GeneratedField::CreatePolicyStmt),
                            "AlterPolicyStmt" | "alter_policy_stmt" => Ok(GeneratedField::AlterPolicyStmt),
                            "CreateAmStmt" | "create_am_stmt" => Ok(GeneratedField::CreateAmStmt),
                            "CreateTrigStmt" | "create_trig_stmt" => Ok(GeneratedField::CreateTrigStmt),
                            "CreateEventTrigStmt" | "create_event_trig_stmt" => Ok(GeneratedField::CreateEventTrigStmt),
                            "AlterEventTrigStmt" | "alter_event_trig_stmt" => Ok(GeneratedField::AlterEventTrigStmt),
                            "CreatePLangStmt" | "create_plang_stmt" => Ok(GeneratedField::CreatePlangStmt),
                            "CreateRoleStmt" | "create_role_stmt" => Ok(GeneratedField::CreateRoleStmt),
                            "AlterRoleStmt" | "alter_role_stmt" => Ok(GeneratedField::AlterRoleStmt),
                            "AlterRoleSetStmt" | "alter_role_set_stmt" => Ok(GeneratedField::AlterRoleSetStmt),
                            "DropRoleStmt" | "drop_role_stmt" => Ok(GeneratedField::DropRoleStmt),
                            "CreateSeqStmt" | "create_seq_stmt" => Ok(GeneratedField::CreateSeqStmt),
                            "AlterSeqStmt" | "alter_seq_stmt" => Ok(GeneratedField::AlterSeqStmt),
                            "DefineStmt" | "define_stmt" => Ok(GeneratedField::DefineStmt),
                            "CreateDomainStmt" | "create_domain_stmt" => Ok(GeneratedField::CreateDomainStmt),
                            "CreateOpClassStmt" | "create_op_class_stmt" => Ok(GeneratedField::CreateOpClassStmt),
                            "CreateOpClassItem" | "create_op_class_item" => Ok(GeneratedField::CreateOpClassItem),
                            "CreateOpFamilyStmt" | "create_op_family_stmt" => Ok(GeneratedField::CreateOpFamilyStmt),
                            "AlterOpFamilyStmt" | "alter_op_family_stmt" => Ok(GeneratedField::AlterOpFamilyStmt),
                            "DropStmt" | "drop_stmt" => Ok(GeneratedField::DropStmt),
                            "TruncateStmt" | "truncate_stmt" => Ok(GeneratedField::TruncateStmt),
                            "CommentStmt" | "comment_stmt" => Ok(GeneratedField::CommentStmt),
                            "SecLabelStmt" | "sec_label_stmt" => Ok(GeneratedField::SecLabelStmt),
                            "DeclareCursorStmt" | "declare_cursor_stmt" => Ok(GeneratedField::DeclareCursorStmt),
                            "ClosePortalStmt" | "close_portal_stmt" => Ok(GeneratedField::ClosePortalStmt),
                            "FetchStmt" | "fetch_stmt" => Ok(GeneratedField::FetchStmt),
                            "IndexStmt" | "index_stmt" => Ok(GeneratedField::IndexStmt),
                            "CreateStatsStmt" | "create_stats_stmt" => Ok(GeneratedField::CreateStatsStmt),
                            "StatsElem" | "stats_elem" => Ok(GeneratedField::StatsElem),
                            "AlterStatsStmt" | "alter_stats_stmt" => Ok(GeneratedField::AlterStatsStmt),
                            "CreateFunctionStmt" | "create_function_stmt" => Ok(GeneratedField::CreateFunctionStmt),
                            "FunctionParameter" | "function_parameter" => Ok(GeneratedField::FunctionParameter),
                            "AlterFunctionStmt" | "alter_function_stmt" => Ok(GeneratedField::AlterFunctionStmt),
                            "DoStmt" | "do_stmt" => Ok(GeneratedField::DoStmt),
                            "InlineCodeBlock" | "inline_code_block" => Ok(GeneratedField::InlineCodeBlock),
                            "CallStmt" | "call_stmt" => Ok(GeneratedField::CallStmt),
                            "CallContext" | "call_context" => Ok(GeneratedField::CallContext),
                            "RenameStmt" | "rename_stmt" => Ok(GeneratedField::RenameStmt),
                            "AlterObjectDependsStmt" | "alter_object_depends_stmt" => Ok(GeneratedField::AlterObjectDependsStmt),
                            "AlterObjectSchemaStmt" | "alter_object_schema_stmt" => Ok(GeneratedField::AlterObjectSchemaStmt),
                            "AlterOwnerStmt" | "alter_owner_stmt" => Ok(GeneratedField::AlterOwnerStmt),
                            "AlterOperatorStmt" | "alter_operator_stmt" => Ok(GeneratedField::AlterOperatorStmt),
                            "AlterTypeStmt" | "alter_type_stmt" => Ok(GeneratedField::AlterTypeStmt),
                            "RuleStmt" | "rule_stmt" => Ok(GeneratedField::RuleStmt),
                            "NotifyStmt" | "notify_stmt" => Ok(GeneratedField::NotifyStmt),
                            "ListenStmt" | "listen_stmt" => Ok(GeneratedField::ListenStmt),
                            "UnlistenStmt" | "unlisten_stmt" => Ok(GeneratedField::UnlistenStmt),
                            "TransactionStmt" | "transaction_stmt" => Ok(GeneratedField::TransactionStmt),
                            "CompositeTypeStmt" | "composite_type_stmt" => Ok(GeneratedField::CompositeTypeStmt),
                            "CreateEnumStmt" | "create_enum_stmt" => Ok(GeneratedField::CreateEnumStmt),
                            "CreateRangeStmt" | "create_range_stmt" => Ok(GeneratedField::CreateRangeStmt),
                            "AlterEnumStmt" | "alter_enum_stmt" => Ok(GeneratedField::AlterEnumStmt),
                            "ViewStmt" | "view_stmt" => Ok(GeneratedField::ViewStmt),
                            "LoadStmt" | "load_stmt" => Ok(GeneratedField::LoadStmt),
                            "CreatedbStmt" | "createdb_stmt" => Ok(GeneratedField::CreatedbStmt),
                            "AlterDatabaseStmt" | "alter_database_stmt" => Ok(GeneratedField::AlterDatabaseStmt),
                            "AlterDatabaseRefreshCollStmt" | "alter_database_refresh_coll_stmt" => Ok(GeneratedField::AlterDatabaseRefreshCollStmt),
                            "AlterDatabaseSetStmt" | "alter_database_set_stmt" => Ok(GeneratedField::AlterDatabaseSetStmt),
                            "DropdbStmt" | "dropdb_stmt" => Ok(GeneratedField::DropdbStmt),
                            "AlterSystemStmt" | "alter_system_stmt" => Ok(GeneratedField::AlterSystemStmt),
                            "ClusterStmt" | "cluster_stmt" => Ok(GeneratedField::ClusterStmt),
                            "VacuumStmt" | "vacuum_stmt" => Ok(GeneratedField::VacuumStmt),
                            "VacuumRelation" | "vacuum_relation" => Ok(GeneratedField::VacuumRelation),
                            "ExplainStmt" | "explain_stmt" => Ok(GeneratedField::ExplainStmt),
                            "CreateTableAsStmt" | "create_table_as_stmt" => Ok(GeneratedField::CreateTableAsStmt),
                            "RefreshMatViewStmt" | "refresh_mat_view_stmt" => Ok(GeneratedField::RefreshMatViewStmt),
                            "CheckPointStmt" | "check_point_stmt" => Ok(GeneratedField::CheckPointStmt),
                            "DiscardStmt" | "discard_stmt" => Ok(GeneratedField::DiscardStmt),
                            "LockStmt" | "lock_stmt" => Ok(GeneratedField::LockStmt),
                            "ConstraintsSetStmt" | "constraints_set_stmt" => Ok(GeneratedField::ConstraintsSetStmt),
                            "ReindexStmt" | "reindex_stmt" => Ok(GeneratedField::ReindexStmt),
                            "CreateConversionStmt" | "create_conversion_stmt" => Ok(GeneratedField::CreateConversionStmt),
                            "CreateCastStmt" | "create_cast_stmt" => Ok(GeneratedField::CreateCastStmt),
                            "CreateTransformStmt" | "create_transform_stmt" => Ok(GeneratedField::CreateTransformStmt),
                            "PrepareStmt" | "prepare_stmt" => Ok(GeneratedField::PrepareStmt),
                            "ExecuteStmt" | "execute_stmt" => Ok(GeneratedField::ExecuteStmt),
                            "DeallocateStmt" | "deallocate_stmt" => Ok(GeneratedField::DeallocateStmt),
                            "DropOwnedStmt" | "drop_owned_stmt" => Ok(GeneratedField::DropOwnedStmt),
                            "ReassignOwnedStmt" | "reassign_owned_stmt" => Ok(GeneratedField::ReassignOwnedStmt),
                            "AlterTSDictionaryStmt" | "alter_tsdictionary_stmt" => Ok(GeneratedField::AlterTsdictionaryStmt),
                            "AlterTSConfigurationStmt" | "alter_tsconfiguration_stmt" => Ok(GeneratedField::AlterTsconfigurationStmt),
                            "PublicationTable" | "publication_table" => Ok(GeneratedField::PublicationTable),
                            "PublicationObjSpec" | "publication_obj_spec" => Ok(GeneratedField::PublicationObjSpec),
                            "CreatePublicationStmt" | "create_publication_stmt" => Ok(GeneratedField::CreatePublicationStmt),
                            "AlterPublicationStmt" | "alter_publication_stmt" => Ok(GeneratedField::AlterPublicationStmt),
                            "CreateSubscriptionStmt" | "create_subscription_stmt" => Ok(GeneratedField::CreateSubscriptionStmt),
                            "AlterSubscriptionStmt" | "alter_subscription_stmt" => Ok(GeneratedField::AlterSubscriptionStmt),
                            "DropSubscriptionStmt" | "drop_subscription_stmt" => Ok(GeneratedField::DropSubscriptionStmt),
                            "Integer" | "integer" => Ok(GeneratedField::Integer),
                            "Float" | "float" => Ok(GeneratedField::Float),
                            "Boolean" | "boolean" => Ok(GeneratedField::Boolean),
                            "String" | "string" => Ok(GeneratedField::String),
                            "BitString" | "bit_string" => Ok(GeneratedField::BitString),
                            "List" | "list" => Ok(GeneratedField::List),
                            "IntList" | "int_list" => Ok(GeneratedField::IntList),
                            "OidList" | "oid_list" => Ok(GeneratedField::OidList),
                            "A_Const" | "a_const" => Ok(GeneratedField::AConst),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Node;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Node")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Node, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut node__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Alias => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Alias"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Alias)
;
                        }
                        GeneratedField::RangeVar => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeVar"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeVar)
;
                        }
                        GeneratedField::TableFunc => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TableFunc"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TableFunc)
;
                        }
                        GeneratedField::IntoClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IntoClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::IntoClause)
;
                        }
                        GeneratedField::Var => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Var"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Var)
;
                        }
                        GeneratedField::Param => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Param"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Param)
;
                        }
                        GeneratedField::Aggref => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Aggref"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Aggref)
;
                        }
                        GeneratedField::GroupingFunc => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupingFunc"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::GroupingFunc)
;
                        }
                        GeneratedField::WindowFunc => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WindowFunc"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::WindowFunc)
;
                        }
                        GeneratedField::SubscriptingRef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubscriptingRef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SubscriptingRef)
;
                        }
                        GeneratedField::FuncExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FuncExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FuncExpr)
;
                        }
                        GeneratedField::NamedArgExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NamedArgExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::NamedArgExpr)
;
                        }
                        GeneratedField::OpExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::OpExpr)
;
                        }
                        GeneratedField::DistinctExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DistinctExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DistinctExpr)
;
                        }
                        GeneratedField::NullIfExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NullIfExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::NullIfExpr)
;
                        }
                        GeneratedField::ScalarArrayOpExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScalarArrayOpExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ScalarArrayOpExpr)
;
                        }
                        GeneratedField::BoolExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BoolExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::BoolExpr)
;
                        }
                        GeneratedField::SubLink => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubLink"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SubLink)
;
                        }
                        GeneratedField::SubPlan => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubPlan"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SubPlan)
;
                        }
                        GeneratedField::AlternativeSubPlan => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlternativeSubPlan"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlternativeSubPlan)
;
                        }
                        GeneratedField::FieldSelect => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FieldSelect"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FieldSelect)
;
                        }
                        GeneratedField::FieldStore => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FieldStore"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FieldStore)
;
                        }
                        GeneratedField::RelabelType => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RelabelType"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RelabelType)
;
                        }
                        GeneratedField::CoerceViaIo => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoerceViaIO"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CoerceViaIo)
;
                        }
                        GeneratedField::ArrayCoerceExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ArrayCoerceExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ArrayCoerceExpr)
;
                        }
                        GeneratedField::ConvertRowtypeExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConvertRowtypeExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ConvertRowtypeExpr)
;
                        }
                        GeneratedField::CollateExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollateExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CollateExpr)
;
                        }
                        GeneratedField::CaseExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CaseExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CaseExpr)
;
                        }
                        GeneratedField::CaseWhen => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CaseWhen"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CaseWhen)
;
                        }
                        GeneratedField::CaseTestExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CaseTestExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CaseTestExpr)
;
                        }
                        GeneratedField::ArrayExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ArrayExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ArrayExpr)
;
                        }
                        GeneratedField::RowExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RowExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RowExpr)
;
                        }
                        GeneratedField::RowCompareExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RowCompareExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RowCompareExpr)
;
                        }
                        GeneratedField::CoalesceExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoalesceExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CoalesceExpr)
;
                        }
                        GeneratedField::MinMaxExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MinMaxExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::MinMaxExpr)
;
                        }
                        GeneratedField::SqlvalueFunction => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SQLValueFunction"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SqlvalueFunction)
;
                        }
                        GeneratedField::XmlExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("XmlExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::XmlExpr)
;
                        }
                        GeneratedField::JsonFormat => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonFormat"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonFormat)
;
                        }
                        GeneratedField::JsonReturning => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonReturning"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonReturning)
;
                        }
                        GeneratedField::JsonValueExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonValueExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonValueExpr)
;
                        }
                        GeneratedField::JsonConstructorExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonConstructorExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonConstructorExpr)
;
                        }
                        GeneratedField::JsonIsPredicate => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonIsPredicate"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonIsPredicate)
;
                        }
                        GeneratedField::NullTest => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NullTest"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::NullTest)
;
                        }
                        GeneratedField::BooleanTest => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BooleanTest"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::BooleanTest)
;
                        }
                        GeneratedField::CoerceToDomain => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoerceToDomain"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CoerceToDomain)
;
                        }
                        GeneratedField::CoerceToDomainValue => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoerceToDomainValue"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CoerceToDomainValue)
;
                        }
                        GeneratedField::SetToDefault => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SetToDefault"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SetToDefault)
;
                        }
                        GeneratedField::CurrentOfExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurrentOfExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CurrentOfExpr)
;
                        }
                        GeneratedField::NextValueExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextValueExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::NextValueExpr)
;
                        }
                        GeneratedField::InferenceElem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InferenceElem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::InferenceElem)
;
                        }
                        GeneratedField::TargetEntry => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetEntry"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TargetEntry)
;
                        }
                        GeneratedField::RangeTblRef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTblRef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTblRef)
;
                        }
                        GeneratedField::JoinExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JoinExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JoinExpr)
;
                        }
                        GeneratedField::FromExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FromExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FromExpr)
;
                        }
                        GeneratedField::OnConflictExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnConflictExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::OnConflictExpr)
;
                        }
                        GeneratedField::Query => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Query"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Query)
;
                        }
                        GeneratedField::TypeName => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TypeName"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TypeName)
;
                        }
                        GeneratedField::ColumnRef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColumnRef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ColumnRef)
;
                        }
                        GeneratedField::ParamRef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ParamRef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ParamRef)
;
                        }
                        GeneratedField::AExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_Expr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AExpr)
;
                        }
                        GeneratedField::TypeCast => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TypeCast"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TypeCast)
;
                        }
                        GeneratedField::CollateClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollateClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CollateClause)
;
                        }
                        GeneratedField::RoleSpec => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoleSpec"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RoleSpec)
;
                        }
                        GeneratedField::FuncCall => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FuncCall"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FuncCall)
;
                        }
                        GeneratedField::AStar => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_Star"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AStar)
;
                        }
                        GeneratedField::AIndices => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_Indices"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AIndices)
;
                        }
                        GeneratedField::AIndirection => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_Indirection"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AIndirection)
;
                        }
                        GeneratedField::AArrayExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_ArrayExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AArrayExpr)
;
                        }
                        GeneratedField::ResTarget => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResTarget"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ResTarget)
;
                        }
                        GeneratedField::MultiAssignRef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MultiAssignRef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::MultiAssignRef)
;
                        }
                        GeneratedField::SortBy => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SortBy"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SortBy)
;
                        }
                        GeneratedField::WindowDef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WindowDef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::WindowDef)
;
                        }
                        GeneratedField::RangeSubselect => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeSubselect"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeSubselect)
;
                        }
                        GeneratedField::RangeFunction => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeFunction"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeFunction)
;
                        }
                        GeneratedField::RangeTableFunc => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTableFunc"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTableFunc)
;
                        }
                        GeneratedField::RangeTableFuncCol => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTableFuncCol"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTableFuncCol)
;
                        }
                        GeneratedField::RangeTableSample => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTableSample"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTableSample)
;
                        }
                        GeneratedField::ColumnDef => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColumnDef"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ColumnDef)
;
                        }
                        GeneratedField::TableLikeClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TableLikeClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TableLikeClause)
;
                        }
                        GeneratedField::IndexElem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IndexElem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::IndexElem)
;
                        }
                        GeneratedField::DefElem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DefElem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DefElem)
;
                        }
                        GeneratedField::LockingClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LockingClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::LockingClause)
;
                        }
                        GeneratedField::XmlSerialize => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("XmlSerialize"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::XmlSerialize)
;
                        }
                        GeneratedField::PartitionElem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartitionElem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PartitionElem)
;
                        }
                        GeneratedField::PartitionSpec => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartitionSpec"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PartitionSpec)
;
                        }
                        GeneratedField::PartitionBoundSpec => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartitionBoundSpec"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PartitionBoundSpec)
;
                        }
                        GeneratedField::PartitionRangeDatum => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartitionRangeDatum"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PartitionRangeDatum)
;
                        }
                        GeneratedField::PartitionCmd => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartitionCmd"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PartitionCmd)
;
                        }
                        GeneratedField::RangeTblEntry => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTblEntry"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTblEntry)
;
                        }
                        GeneratedField::RtepermissionInfo => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RTEPermissionInfo"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RtepermissionInfo)
;
                        }
                        GeneratedField::RangeTblFunction => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RangeTblFunction"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RangeTblFunction)
;
                        }
                        GeneratedField::TableSampleClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TableSampleClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TableSampleClause)
;
                        }
                        GeneratedField::WithCheckOption => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WithCheckOption"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::WithCheckOption)
;
                        }
                        GeneratedField::SortGroupClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SortGroupClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SortGroupClause)
;
                        }
                        GeneratedField::GroupingSet => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupingSet"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::GroupingSet)
;
                        }
                        GeneratedField::WindowClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WindowClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::WindowClause)
;
                        }
                        GeneratedField::RowMarkClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RowMarkClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RowMarkClause)
;
                        }
                        GeneratedField::WithClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WithClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::WithClause)
;
                        }
                        GeneratedField::InferClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InferClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::InferClause)
;
                        }
                        GeneratedField::OnConflictClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnConflictClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::OnConflictClause)
;
                        }
                        GeneratedField::CtesearchClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CTESearchClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CtesearchClause)
;
                        }
                        GeneratedField::CtecycleClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CTECycleClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CtecycleClause)
;
                        }
                        GeneratedField::CommonTableExpr => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommonTableExpr"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CommonTableExpr)
;
                        }
                        GeneratedField::MergeWhenClause => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MergeWhenClause"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::MergeWhenClause)
;
                        }
                        GeneratedField::MergeAction => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MergeAction"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::MergeAction)
;
                        }
                        GeneratedField::TriggerTransition => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerTransition"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TriggerTransition)
;
                        }
                        GeneratedField::JsonOutput => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonOutput"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonOutput)
;
                        }
                        GeneratedField::JsonKeyValue => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonKeyValue"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonKeyValue)
;
                        }
                        GeneratedField::JsonObjectConstructor => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonObjectConstructor"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonObjectConstructor)
;
                        }
                        GeneratedField::JsonArrayConstructor => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonArrayConstructor"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonArrayConstructor)
;
                        }
                        GeneratedField::JsonArrayQueryConstructor => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonArrayQueryConstructor"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonArrayQueryConstructor)
;
                        }
                        GeneratedField::JsonAggConstructor => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonAggConstructor"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonAggConstructor)
;
                        }
                        GeneratedField::JsonObjectAgg => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonObjectAgg"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonObjectAgg)
;
                        }
                        GeneratedField::JsonArrayAgg => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JsonArrayAgg"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::JsonArrayAgg)
;
                        }
                        GeneratedField::RawStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RawStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RawStmt)
;
                        }
                        GeneratedField::InsertStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InsertStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::InsertStmt)
;
                        }
                        GeneratedField::DeleteStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeleteStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DeleteStmt)
;
                        }
                        GeneratedField::UpdateStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UpdateStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::UpdateStmt)
;
                        }
                        GeneratedField::MergeStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MergeStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::MergeStmt)
;
                        }
                        GeneratedField::SelectStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SelectStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SelectStmt)
;
                        }
                        GeneratedField::SetOperationStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SetOperationStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SetOperationStmt)
;
                        }
                        GeneratedField::ReturnStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReturnStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ReturnStmt)
;
                        }
                        GeneratedField::PlassignStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PLAssignStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PlassignStmt)
;
                        }
                        GeneratedField::CreateSchemaStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateSchemaStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateSchemaStmt)
;
                        }
                        GeneratedField::AlterTableStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTableStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTableStmt)
;
                        }
                        GeneratedField::ReplicaIdentityStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReplicaIdentityStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ReplicaIdentityStmt)
;
                        }
                        GeneratedField::AlterTableCmd => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTableCmd"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTableCmd)
;
                        }
                        GeneratedField::AlterCollationStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterCollationStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterCollationStmt)
;
                        }
                        GeneratedField::AlterDomainStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterDomainStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterDomainStmt)
;
                        }
                        GeneratedField::GrantStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GrantStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::GrantStmt)
;
                        }
                        GeneratedField::ObjectWithArgs => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjectWithArgs"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ObjectWithArgs)
;
                        }
                        GeneratedField::AccessPriv => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccessPriv"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AccessPriv)
;
                        }
                        GeneratedField::GrantRoleStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GrantRoleStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::GrantRoleStmt)
;
                        }
                        GeneratedField::AlterDefaultPrivilegesStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterDefaultPrivilegesStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterDefaultPrivilegesStmt)
;
                        }
                        GeneratedField::CopyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CopyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CopyStmt)
;
                        }
                        GeneratedField::VariableSetStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VariableSetStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::VariableSetStmt)
;
                        }
                        GeneratedField::VariableShowStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VariableShowStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::VariableShowStmt)
;
                        }
                        GeneratedField::CreateStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateStmt)
;
                        }
                        GeneratedField::Constraint => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Constraint"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Constraint)
;
                        }
                        GeneratedField::CreateTableSpaceStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTableSpaceStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateTableSpaceStmt)
;
                        }
                        GeneratedField::DropTableSpaceStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropTableSpaceStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropTableSpaceStmt)
;
                        }
                        GeneratedField::AlterTableSpaceOptionsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTableSpaceOptionsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTableSpaceOptionsStmt)
;
                        }
                        GeneratedField::AlterTableMoveAllStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTableMoveAllStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTableMoveAllStmt)
;
                        }
                        GeneratedField::CreateExtensionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateExtensionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateExtensionStmt)
;
                        }
                        GeneratedField::AlterExtensionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterExtensionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterExtensionStmt)
;
                        }
                        GeneratedField::AlterExtensionContentsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterExtensionContentsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterExtensionContentsStmt)
;
                        }
                        GeneratedField::CreateFdwStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateFdwStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateFdwStmt)
;
                        }
                        GeneratedField::AlterFdwStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterFdwStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterFdwStmt)
;
                        }
                        GeneratedField::CreateForeignServerStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateForeignServerStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateForeignServerStmt)
;
                        }
                        GeneratedField::AlterForeignServerStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterForeignServerStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterForeignServerStmt)
;
                        }
                        GeneratedField::CreateForeignTableStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateForeignTableStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateForeignTableStmt)
;
                        }
                        GeneratedField::CreateUserMappingStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateUserMappingStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateUserMappingStmt)
;
                        }
                        GeneratedField::AlterUserMappingStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterUserMappingStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterUserMappingStmt)
;
                        }
                        GeneratedField::DropUserMappingStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropUserMappingStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropUserMappingStmt)
;
                        }
                        GeneratedField::ImportForeignSchemaStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ImportForeignSchemaStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ImportForeignSchemaStmt)
;
                        }
                        GeneratedField::CreatePolicyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreatePolicyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreatePolicyStmt)
;
                        }
                        GeneratedField::AlterPolicyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterPolicyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterPolicyStmt)
;
                        }
                        GeneratedField::CreateAmStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateAmStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateAmStmt)
;
                        }
                        GeneratedField::CreateTrigStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTrigStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateTrigStmt)
;
                        }
                        GeneratedField::CreateEventTrigStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateEventTrigStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateEventTrigStmt)
;
                        }
                        GeneratedField::AlterEventTrigStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterEventTrigStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterEventTrigStmt)
;
                        }
                        GeneratedField::CreatePlangStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreatePLangStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreatePlangStmt)
;
                        }
                        GeneratedField::CreateRoleStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateRoleStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateRoleStmt)
;
                        }
                        GeneratedField::AlterRoleStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterRoleStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterRoleStmt)
;
                        }
                        GeneratedField::AlterRoleSetStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterRoleSetStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterRoleSetStmt)
;
                        }
                        GeneratedField::DropRoleStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropRoleStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropRoleStmt)
;
                        }
                        GeneratedField::CreateSeqStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateSeqStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateSeqStmt)
;
                        }
                        GeneratedField::AlterSeqStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterSeqStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterSeqStmt)
;
                        }
                        GeneratedField::DefineStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DefineStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DefineStmt)
;
                        }
                        GeneratedField::CreateDomainStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateDomainStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateDomainStmt)
;
                        }
                        GeneratedField::CreateOpClassStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateOpClassStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateOpClassStmt)
;
                        }
                        GeneratedField::CreateOpClassItem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateOpClassItem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateOpClassItem)
;
                        }
                        GeneratedField::CreateOpFamilyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateOpFamilyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateOpFamilyStmt)
;
                        }
                        GeneratedField::AlterOpFamilyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterOpFamilyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterOpFamilyStmt)
;
                        }
                        GeneratedField::DropStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropStmt)
;
                        }
                        GeneratedField::TruncateStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TruncateStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TruncateStmt)
;
                        }
                        GeneratedField::CommentStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommentStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CommentStmt)
;
                        }
                        GeneratedField::SecLabelStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SecLabelStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::SecLabelStmt)
;
                        }
                        GeneratedField::DeclareCursorStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeclareCursorStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DeclareCursorStmt)
;
                        }
                        GeneratedField::ClosePortalStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClosePortalStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ClosePortalStmt)
;
                        }
                        GeneratedField::FetchStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FetchStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FetchStmt)
;
                        }
                        GeneratedField::IndexStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IndexStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::IndexStmt)
;
                        }
                        GeneratedField::CreateStatsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateStatsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateStatsStmt)
;
                        }
                        GeneratedField::StatsElem => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StatsElem"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::StatsElem)
;
                        }
                        GeneratedField::AlterStatsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterStatsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterStatsStmt)
;
                        }
                        GeneratedField::CreateFunctionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateFunctionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateFunctionStmt)
;
                        }
                        GeneratedField::FunctionParameter => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionParameter"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::FunctionParameter)
;
                        }
                        GeneratedField::AlterFunctionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterFunctionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterFunctionStmt)
;
                        }
                        GeneratedField::DoStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DoStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DoStmt)
;
                        }
                        GeneratedField::InlineCodeBlock => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InlineCodeBlock"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::InlineCodeBlock)
;
                        }
                        GeneratedField::CallStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CallStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CallStmt)
;
                        }
                        GeneratedField::CallContext => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CallContext"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CallContext)
;
                        }
                        GeneratedField::RenameStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RenameStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RenameStmt)
;
                        }
                        GeneratedField::AlterObjectDependsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterObjectDependsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterObjectDependsStmt)
;
                        }
                        GeneratedField::AlterObjectSchemaStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterObjectSchemaStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterObjectSchemaStmt)
;
                        }
                        GeneratedField::AlterOwnerStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterOwnerStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterOwnerStmt)
;
                        }
                        GeneratedField::AlterOperatorStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterOperatorStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterOperatorStmt)
;
                        }
                        GeneratedField::AlterTypeStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTypeStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTypeStmt)
;
                        }
                        GeneratedField::RuleStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RuleStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RuleStmt)
;
                        }
                        GeneratedField::NotifyStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NotifyStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::NotifyStmt)
;
                        }
                        GeneratedField::ListenStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ListenStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ListenStmt)
;
                        }
                        GeneratedField::UnlistenStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlistenStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::UnlistenStmt)
;
                        }
                        GeneratedField::TransactionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransactionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::TransactionStmt)
;
                        }
                        GeneratedField::CompositeTypeStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompositeTypeStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CompositeTypeStmt)
;
                        }
                        GeneratedField::CreateEnumStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateEnumStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateEnumStmt)
;
                        }
                        GeneratedField::CreateRangeStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateRangeStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateRangeStmt)
;
                        }
                        GeneratedField::AlterEnumStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterEnumStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterEnumStmt)
;
                        }
                        GeneratedField::ViewStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ViewStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ViewStmt)
;
                        }
                        GeneratedField::LoadStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LoadStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::LoadStmt)
;
                        }
                        GeneratedField::CreatedbStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreatedbStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreatedbStmt)
;
                        }
                        GeneratedField::AlterDatabaseStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterDatabaseStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterDatabaseStmt)
;
                        }
                        GeneratedField::AlterDatabaseRefreshCollStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterDatabaseRefreshCollStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterDatabaseRefreshCollStmt)
;
                        }
                        GeneratedField::AlterDatabaseSetStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterDatabaseSetStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterDatabaseSetStmt)
;
                        }
                        GeneratedField::DropdbStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropdbStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropdbStmt)
;
                        }
                        GeneratedField::AlterSystemStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterSystemStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterSystemStmt)
;
                        }
                        GeneratedField::ClusterStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClusterStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ClusterStmt)
;
                        }
                        GeneratedField::VacuumStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VacuumStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::VacuumStmt)
;
                        }
                        GeneratedField::VacuumRelation => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VacuumRelation"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::VacuumRelation)
;
                        }
                        GeneratedField::ExplainStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExplainStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ExplainStmt)
;
                        }
                        GeneratedField::CreateTableAsStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTableAsStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateTableAsStmt)
;
                        }
                        GeneratedField::RefreshMatViewStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshMatViewStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::RefreshMatViewStmt)
;
                        }
                        GeneratedField::CheckPointStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CheckPointStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CheckPointStmt)
;
                        }
                        GeneratedField::DiscardStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DiscardStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DiscardStmt)
;
                        }
                        GeneratedField::LockStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LockStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::LockStmt)
;
                        }
                        GeneratedField::ConstraintsSetStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConstraintsSetStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ConstraintsSetStmt)
;
                        }
                        GeneratedField::ReindexStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReindexStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ReindexStmt)
;
                        }
                        GeneratedField::CreateConversionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateConversionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateConversionStmt)
;
                        }
                        GeneratedField::CreateCastStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateCastStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateCastStmt)
;
                        }
                        GeneratedField::CreateTransformStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTransformStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateTransformStmt)
;
                        }
                        GeneratedField::PrepareStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrepareStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PrepareStmt)
;
                        }
                        GeneratedField::ExecuteStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExecuteStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ExecuteStmt)
;
                        }
                        GeneratedField::DeallocateStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeallocateStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DeallocateStmt)
;
                        }
                        GeneratedField::DropOwnedStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropOwnedStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropOwnedStmt)
;
                        }
                        GeneratedField::ReassignOwnedStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReassignOwnedStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::ReassignOwnedStmt)
;
                        }
                        GeneratedField::AlterTsdictionaryStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTSDictionaryStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTsdictionaryStmt)
;
                        }
                        GeneratedField::AlterTsconfigurationStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterTSConfigurationStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterTsconfigurationStmt)
;
                        }
                        GeneratedField::PublicationTable => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PublicationTable"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PublicationTable)
;
                        }
                        GeneratedField::PublicationObjSpec => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PublicationObjSpec"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::PublicationObjSpec)
;
                        }
                        GeneratedField::CreatePublicationStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreatePublicationStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreatePublicationStmt)
;
                        }
                        GeneratedField::AlterPublicationStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterPublicationStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterPublicationStmt)
;
                        }
                        GeneratedField::CreateSubscriptionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateSubscriptionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::CreateSubscriptionStmt)
;
                        }
                        GeneratedField::AlterSubscriptionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AlterSubscriptionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AlterSubscriptionStmt)
;
                        }
                        GeneratedField::DropSubscriptionStmt => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropSubscriptionStmt"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::DropSubscriptionStmt)
;
                        }
                        GeneratedField::Integer => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Integer"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Integer)
;
                        }
                        GeneratedField::Float => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Float"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Float)
;
                        }
                        GeneratedField::Boolean => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Boolean"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::Boolean)
;
                        }
                        GeneratedField::String => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("String"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::String)
;
                        }
                        GeneratedField::BitString => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BitString"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::BitString)
;
                        }
                        GeneratedField::List => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("List"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::List)
;
                        }
                        GeneratedField::IntList => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IntList"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::IntList)
;
                        }
                        GeneratedField::OidList => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OidList"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::OidList)
;
                        }
                        GeneratedField::AConst => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("A_Const"));
                            }
                            node__ = map_.next_value::<::std::option::Option<_>>()?.map(node::Node::AConst)
;
                        }
                    }
                }
                Ok(Node {
                    node: node__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Node", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.conditionname.is_empty() {
            len += 1;
        }
        if !self.payload.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.NotifyStmt", len)?;
        if !self.conditionname.is_empty() {
            struct_ser.serialize_field("conditionname", &self.conditionname)?;
        }
        if !self.payload.is_empty() {
            struct_ser.serialize_field("payload", &self.payload)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "conditionname",
            "payload",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Conditionname,
            Payload,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "conditionname" => Ok(GeneratedField::Conditionname),
                            "payload" => Ok(GeneratedField::Payload),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.NotifyStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut conditionname__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Conditionname => {
                            if conditionname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditionname"));
                            }
                            conditionname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Payload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payload"));
                            }
                            payload__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(NotifyStmt {
                    conditionname: conditionname__.unwrap_or_default(),
                    payload: payload__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.NotifyStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NullIfExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.opno != 0 {
            len += 1;
        }
        if self.opresulttype != 0 {
            len += 1;
        }
        if self.opretset {
            len += 1;
        }
        if self.opcollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.NullIfExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.opno != 0 {
            struct_ser.serialize_field("opno", &self.opno)?;
        }
        if self.opresulttype != 0 {
            struct_ser.serialize_field("opresulttype", &self.opresulttype)?;
        }
        if self.opretset {
            struct_ser.serialize_field("opretset", &self.opretset)?;
        }
        if self.opcollid != 0 {
            struct_ser.serialize_field("opcollid", &self.opcollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NullIfExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "opno",
            "opresulttype",
            "opretset",
            "opcollid",
            "inputcollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Opno,
            Opresulttype,
            Opretset,
            Opcollid,
            Inputcollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "opno" => Ok(GeneratedField::Opno),
                            "opresulttype" => Ok(GeneratedField::Opresulttype),
                            "opretset" => Ok(GeneratedField::Opretset),
                            "opcollid" => Ok(GeneratedField::Opcollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NullIfExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.NullIfExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NullIfExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut opno__ = None;
                let mut opresulttype__ = None;
                let mut opretset__ = None;
                let mut opcollid__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Opno => {
                            if opno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opno"));
                            }
                            opno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opresulttype => {
                            if opresulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opresulttype"));
                            }
                            opresulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opretset => {
                            if opretset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opretset"));
                            }
                            opretset__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opcollid => {
                            if opcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opcollid"));
                            }
                            opcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NullIfExpr {
                    xpr: xpr__,
                    opno: opno__.unwrap_or_default(),
                    opresulttype: opresulttype__.unwrap_or_default(),
                    opretset: opretset__.unwrap_or_default(),
                    opcollid: opcollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.NullIfExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NullTest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.nulltesttype != 0 {
            len += 1;
        }
        if self.argisrow {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.NullTest", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.nulltesttype != 0 {
            let v = NullTestType::try_from(self.nulltesttype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nulltesttype)))?;
            struct_ser.serialize_field("nulltesttype", &v)?;
        }
        if self.argisrow {
            struct_ser.serialize_field("argisrow", &self.argisrow)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NullTest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "nulltesttype",
            "argisrow",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Nulltesttype,
            Argisrow,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "nulltesttype" => Ok(GeneratedField::Nulltesttype),
                            "argisrow" => Ok(GeneratedField::Argisrow),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NullTest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.NullTest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NullTest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut nulltesttype__ = None;
                let mut argisrow__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Nulltesttype => {
                            if nulltesttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nulltesttype"));
                            }
                            nulltesttype__ = Some(map_.next_value::<NullTestType>()? as i32);
                        }
                        GeneratedField::Argisrow => {
                            if argisrow__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argisrow"));
                            }
                            argisrow__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NullTest {
                    xpr: xpr__,
                    arg: arg__,
                    nulltesttype: nulltesttype__.unwrap_or_default(),
                    argisrow: argisrow__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.NullTest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NullTestType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "NULL_TEST_TYPE_UNDEFINED",
            Self::IsNull => "IS_NULL",
            Self::IsNotNull => "IS_NOT_NULL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for NullTestType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NULL_TEST_TYPE_UNDEFINED",
            "IS_NULL",
            "IS_NOT_NULL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NullTestType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NULL_TEST_TYPE_UNDEFINED" => Ok(NullTestType::Undefined),
                    "IS_NULL" => Ok(NullTestType::IsNull),
                    "IS_NOT_NULL" => Ok(NullTestType::IsNotNull),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ObjectType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "OBJECT_TYPE_UNDEFINED",
            Self::ObjectAccessMethod => "OBJECT_ACCESS_METHOD",
            Self::ObjectAggregate => "OBJECT_AGGREGATE",
            Self::ObjectAmop => "OBJECT_AMOP",
            Self::ObjectAmproc => "OBJECT_AMPROC",
            Self::ObjectAttribute => "OBJECT_ATTRIBUTE",
            Self::ObjectCast => "OBJECT_CAST",
            Self::ObjectColumn => "OBJECT_COLUMN",
            Self::ObjectCollation => "OBJECT_COLLATION",
            Self::ObjectConversion => "OBJECT_CONVERSION",
            Self::ObjectDatabase => "OBJECT_DATABASE",
            Self::ObjectDefault => "OBJECT_DEFAULT",
            Self::ObjectDefacl => "OBJECT_DEFACL",
            Self::ObjectDomain => "OBJECT_DOMAIN",
            Self::ObjectDomconstraint => "OBJECT_DOMCONSTRAINT",
            Self::ObjectEventTrigger => "OBJECT_EVENT_TRIGGER",
            Self::ObjectExtension => "OBJECT_EXTENSION",
            Self::ObjectFdw => "OBJECT_FDW",
            Self::ObjectForeignServer => "OBJECT_FOREIGN_SERVER",
            Self::ObjectForeignTable => "OBJECT_FOREIGN_TABLE",
            Self::ObjectFunction => "OBJECT_FUNCTION",
            Self::ObjectIndex => "OBJECT_INDEX",
            Self::ObjectLanguage => "OBJECT_LANGUAGE",
            Self::ObjectLargeobject => "OBJECT_LARGEOBJECT",
            Self::ObjectMatview => "OBJECT_MATVIEW",
            Self::ObjectOpclass => "OBJECT_OPCLASS",
            Self::ObjectOperator => "OBJECT_OPERATOR",
            Self::ObjectOpfamily => "OBJECT_OPFAMILY",
            Self::ObjectParameterAcl => "OBJECT_PARAMETER_ACL",
            Self::ObjectPolicy => "OBJECT_POLICY",
            Self::ObjectProcedure => "OBJECT_PROCEDURE",
            Self::ObjectPublication => "OBJECT_PUBLICATION",
            Self::ObjectPublicationNamespace => "OBJECT_PUBLICATION_NAMESPACE",
            Self::ObjectPublicationRel => "OBJECT_PUBLICATION_REL",
            Self::ObjectRole => "OBJECT_ROLE",
            Self::ObjectRoutine => "OBJECT_ROUTINE",
            Self::ObjectRule => "OBJECT_RULE",
            Self::ObjectSchema => "OBJECT_SCHEMA",
            Self::ObjectSequence => "OBJECT_SEQUENCE",
            Self::ObjectSubscription => "OBJECT_SUBSCRIPTION",
            Self::ObjectStatisticExt => "OBJECT_STATISTIC_EXT",
            Self::ObjectTabconstraint => "OBJECT_TABCONSTRAINT",
            Self::ObjectTable => "OBJECT_TABLE",
            Self::ObjectTablespace => "OBJECT_TABLESPACE",
            Self::ObjectTransform => "OBJECT_TRANSFORM",
            Self::ObjectTrigger => "OBJECT_TRIGGER",
            Self::ObjectTsconfiguration => "OBJECT_TSCONFIGURATION",
            Self::ObjectTsdictionary => "OBJECT_TSDICTIONARY",
            Self::ObjectTsparser => "OBJECT_TSPARSER",
            Self::ObjectTstemplate => "OBJECT_TSTEMPLATE",
            Self::ObjectType => "OBJECT_TYPE",
            Self::ObjectUserMapping => "OBJECT_USER_MAPPING",
            Self::ObjectView => "OBJECT_VIEW",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ObjectType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OBJECT_TYPE_UNDEFINED",
            "OBJECT_ACCESS_METHOD",
            "OBJECT_AGGREGATE",
            "OBJECT_AMOP",
            "OBJECT_AMPROC",
            "OBJECT_ATTRIBUTE",
            "OBJECT_CAST",
            "OBJECT_COLUMN",
            "OBJECT_COLLATION",
            "OBJECT_CONVERSION",
            "OBJECT_DATABASE",
            "OBJECT_DEFAULT",
            "OBJECT_DEFACL",
            "OBJECT_DOMAIN",
            "OBJECT_DOMCONSTRAINT",
            "OBJECT_EVENT_TRIGGER",
            "OBJECT_EXTENSION",
            "OBJECT_FDW",
            "OBJECT_FOREIGN_SERVER",
            "OBJECT_FOREIGN_TABLE",
            "OBJECT_FUNCTION",
            "OBJECT_INDEX",
            "OBJECT_LANGUAGE",
            "OBJECT_LARGEOBJECT",
            "OBJECT_MATVIEW",
            "OBJECT_OPCLASS",
            "OBJECT_OPERATOR",
            "OBJECT_OPFAMILY",
            "OBJECT_PARAMETER_ACL",
            "OBJECT_POLICY",
            "OBJECT_PROCEDURE",
            "OBJECT_PUBLICATION",
            "OBJECT_PUBLICATION_NAMESPACE",
            "OBJECT_PUBLICATION_REL",
            "OBJECT_ROLE",
            "OBJECT_ROUTINE",
            "OBJECT_RULE",
            "OBJECT_SCHEMA",
            "OBJECT_SEQUENCE",
            "OBJECT_SUBSCRIPTION",
            "OBJECT_STATISTIC_EXT",
            "OBJECT_TABCONSTRAINT",
            "OBJECT_TABLE",
            "OBJECT_TABLESPACE",
            "OBJECT_TRANSFORM",
            "OBJECT_TRIGGER",
            "OBJECT_TSCONFIGURATION",
            "OBJECT_TSDICTIONARY",
            "OBJECT_TSPARSER",
            "OBJECT_TSTEMPLATE",
            "OBJECT_TYPE",
            "OBJECT_USER_MAPPING",
            "OBJECT_VIEW",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ObjectType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OBJECT_TYPE_UNDEFINED" => Ok(ObjectType::Undefined),
                    "OBJECT_ACCESS_METHOD" => Ok(ObjectType::ObjectAccessMethod),
                    "OBJECT_AGGREGATE" => Ok(ObjectType::ObjectAggregate),
                    "OBJECT_AMOP" => Ok(ObjectType::ObjectAmop),
                    "OBJECT_AMPROC" => Ok(ObjectType::ObjectAmproc),
                    "OBJECT_ATTRIBUTE" => Ok(ObjectType::ObjectAttribute),
                    "OBJECT_CAST" => Ok(ObjectType::ObjectCast),
                    "OBJECT_COLUMN" => Ok(ObjectType::ObjectColumn),
                    "OBJECT_COLLATION" => Ok(ObjectType::ObjectCollation),
                    "OBJECT_CONVERSION" => Ok(ObjectType::ObjectConversion),
                    "OBJECT_DATABASE" => Ok(ObjectType::ObjectDatabase),
                    "OBJECT_DEFAULT" => Ok(ObjectType::ObjectDefault),
                    "OBJECT_DEFACL" => Ok(ObjectType::ObjectDefacl),
                    "OBJECT_DOMAIN" => Ok(ObjectType::ObjectDomain),
                    "OBJECT_DOMCONSTRAINT" => Ok(ObjectType::ObjectDomconstraint),
                    "OBJECT_EVENT_TRIGGER" => Ok(ObjectType::ObjectEventTrigger),
                    "OBJECT_EXTENSION" => Ok(ObjectType::ObjectExtension),
                    "OBJECT_FDW" => Ok(ObjectType::ObjectFdw),
                    "OBJECT_FOREIGN_SERVER" => Ok(ObjectType::ObjectForeignServer),
                    "OBJECT_FOREIGN_TABLE" => Ok(ObjectType::ObjectForeignTable),
                    "OBJECT_FUNCTION" => Ok(ObjectType::ObjectFunction),
                    "OBJECT_INDEX" => Ok(ObjectType::ObjectIndex),
                    "OBJECT_LANGUAGE" => Ok(ObjectType::ObjectLanguage),
                    "OBJECT_LARGEOBJECT" => Ok(ObjectType::ObjectLargeobject),
                    "OBJECT_MATVIEW" => Ok(ObjectType::ObjectMatview),
                    "OBJECT_OPCLASS" => Ok(ObjectType::ObjectOpclass),
                    "OBJECT_OPERATOR" => Ok(ObjectType::ObjectOperator),
                    "OBJECT_OPFAMILY" => Ok(ObjectType::ObjectOpfamily),
                    "OBJECT_PARAMETER_ACL" => Ok(ObjectType::ObjectParameterAcl),
                    "OBJECT_POLICY" => Ok(ObjectType::ObjectPolicy),
                    "OBJECT_PROCEDURE" => Ok(ObjectType::ObjectProcedure),
                    "OBJECT_PUBLICATION" => Ok(ObjectType::ObjectPublication),
                    "OBJECT_PUBLICATION_NAMESPACE" => Ok(ObjectType::ObjectPublicationNamespace),
                    "OBJECT_PUBLICATION_REL" => Ok(ObjectType::ObjectPublicationRel),
                    "OBJECT_ROLE" => Ok(ObjectType::ObjectRole),
                    "OBJECT_ROUTINE" => Ok(ObjectType::ObjectRoutine),
                    "OBJECT_RULE" => Ok(ObjectType::ObjectRule),
                    "OBJECT_SCHEMA" => Ok(ObjectType::ObjectSchema),
                    "OBJECT_SEQUENCE" => Ok(ObjectType::ObjectSequence),
                    "OBJECT_SUBSCRIPTION" => Ok(ObjectType::ObjectSubscription),
                    "OBJECT_STATISTIC_EXT" => Ok(ObjectType::ObjectStatisticExt),
                    "OBJECT_TABCONSTRAINT" => Ok(ObjectType::ObjectTabconstraint),
                    "OBJECT_TABLE" => Ok(ObjectType::ObjectTable),
                    "OBJECT_TABLESPACE" => Ok(ObjectType::ObjectTablespace),
                    "OBJECT_TRANSFORM" => Ok(ObjectType::ObjectTransform),
                    "OBJECT_TRIGGER" => Ok(ObjectType::ObjectTrigger),
                    "OBJECT_TSCONFIGURATION" => Ok(ObjectType::ObjectTsconfiguration),
                    "OBJECT_TSDICTIONARY" => Ok(ObjectType::ObjectTsdictionary),
                    "OBJECT_TSPARSER" => Ok(ObjectType::ObjectTsparser),
                    "OBJECT_TSTEMPLATE" => Ok(ObjectType::ObjectTstemplate),
                    "OBJECT_TYPE" => Ok(ObjectType::ObjectType),
                    "OBJECT_USER_MAPPING" => Ok(ObjectType::ObjectUserMapping),
                    "OBJECT_VIEW" => Ok(ObjectType::ObjectView),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ObjectWithArgs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objname.is_empty() {
            len += 1;
        }
        if !self.objargs.is_empty() {
            len += 1;
        }
        if !self.objfuncargs.is_empty() {
            len += 1;
        }
        if self.args_unspecified {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ObjectWithArgs", len)?;
        if !self.objname.is_empty() {
            struct_ser.serialize_field("objname", &self.objname)?;
        }
        if !self.objargs.is_empty() {
            struct_ser.serialize_field("objargs", &self.objargs)?;
        }
        if !self.objfuncargs.is_empty() {
            struct_ser.serialize_field("objfuncargs", &self.objfuncargs)?;
        }
        if self.args_unspecified {
            struct_ser.serialize_field("args_unspecified", &self.args_unspecified)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ObjectWithArgs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objname",
            "objargs",
            "objfuncargs",
            "args_unspecified",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objname,
            Objargs,
            Objfuncargs,
            ArgsUnspecified,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objname" => Ok(GeneratedField::Objname),
                            "objargs" => Ok(GeneratedField::Objargs),
                            "objfuncargs" => Ok(GeneratedField::Objfuncargs),
                            "args_unspecified" => Ok(GeneratedField::ArgsUnspecified),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ObjectWithArgs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ObjectWithArgs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ObjectWithArgs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objname__ = None;
                let mut objargs__ = None;
                let mut objfuncargs__ = None;
                let mut args_unspecified__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objname => {
                            if objname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objname"));
                            }
                            objname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Objargs => {
                            if objargs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objargs"));
                            }
                            objargs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Objfuncargs => {
                            if objfuncargs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objfuncargs"));
                            }
                            objfuncargs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ArgsUnspecified => {
                            if args_unspecified__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args_unspecified"));
                            }
                            args_unspecified__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ObjectWithArgs {
                    objname: objname__.unwrap_or_default(),
                    objargs: objargs__.unwrap_or_default(),
                    objfuncargs: objfuncargs__.unwrap_or_default(),
                    args_unspecified: args_unspecified__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ObjectWithArgs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OidList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.OidList", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OidList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OidList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.OidList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OidList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OidList {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.OidList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OnCommitAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ON_COMMIT_ACTION_UNDEFINED",
            Self::OncommitNoop => "ONCOMMIT_NOOP",
            Self::OncommitPreserveRows => "ONCOMMIT_PRESERVE_ROWS",
            Self::OncommitDeleteRows => "ONCOMMIT_DELETE_ROWS",
            Self::OncommitDrop => "ONCOMMIT_DROP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for OnCommitAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ON_COMMIT_ACTION_UNDEFINED",
            "ONCOMMIT_NOOP",
            "ONCOMMIT_PRESERVE_ROWS",
            "ONCOMMIT_DELETE_ROWS",
            "ONCOMMIT_DROP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OnCommitAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ON_COMMIT_ACTION_UNDEFINED" => Ok(OnCommitAction::Undefined),
                    "ONCOMMIT_NOOP" => Ok(OnCommitAction::OncommitNoop),
                    "ONCOMMIT_PRESERVE_ROWS" => Ok(OnCommitAction::OncommitPreserveRows),
                    "ONCOMMIT_DELETE_ROWS" => Ok(OnCommitAction::OncommitDeleteRows),
                    "ONCOMMIT_DROP" => Ok(OnCommitAction::OncommitDrop),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for OnConflictAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ON_CONFLICT_ACTION_UNDEFINED",
            Self::OnconflictNone => "ONCONFLICT_NONE",
            Self::OnconflictNothing => "ONCONFLICT_NOTHING",
            Self::OnconflictUpdate => "ONCONFLICT_UPDATE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for OnConflictAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ON_CONFLICT_ACTION_UNDEFINED",
            "ONCONFLICT_NONE",
            "ONCONFLICT_NOTHING",
            "ONCONFLICT_UPDATE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OnConflictAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ON_CONFLICT_ACTION_UNDEFINED" => Ok(OnConflictAction::Undefined),
                    "ONCONFLICT_NONE" => Ok(OnConflictAction::OnconflictNone),
                    "ONCONFLICT_NOTHING" => Ok(OnConflictAction::OnconflictNothing),
                    "ONCONFLICT_UPDATE" => Ok(OnConflictAction::OnconflictUpdate),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for OnConflictClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.action != 0 {
            len += 1;
        }
        if self.infer.is_some() {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.OnConflictClause", len)?;
        if self.action != 0 {
            let v = OnConflictAction::try_from(self.action)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.action)))?;
            struct_ser.serialize_field("action", &v)?;
        }
        if let Some(v) = self.infer.as_ref() {
            struct_ser.serialize_field("infer", v)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OnConflictClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "action",
            "infer",
            "target_list",
            "targetList",
            "where_clause",
            "whereClause",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Action,
            Infer,
            TargetList,
            WhereClause,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "action" => Ok(GeneratedField::Action),
                            "infer" => Ok(GeneratedField::Infer),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OnConflictClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.OnConflictClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OnConflictClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut action__ = None;
                let mut infer__ = None;
                let mut target_list__ = None;
                let mut where_clause__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = Some(map_.next_value::<OnConflictAction>()? as i32);
                        }
                        GeneratedField::Infer => {
                            if infer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("infer"));
                            }
                            infer__ = map_.next_value()?;
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(OnConflictClause {
                    action: action__.unwrap_or_default(),
                    infer: infer__,
                    target_list: target_list__.unwrap_or_default(),
                    where_clause: where_clause__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.OnConflictClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OnConflictExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.action != 0 {
            len += 1;
        }
        if !self.arbiter_elems.is_empty() {
            len += 1;
        }
        if self.arbiter_where.is_some() {
            len += 1;
        }
        if self.constraint != 0 {
            len += 1;
        }
        if !self.on_conflict_set.is_empty() {
            len += 1;
        }
        if self.on_conflict_where.is_some() {
            len += 1;
        }
        if self.excl_rel_index != 0 {
            len += 1;
        }
        if !self.excl_rel_tlist.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.OnConflictExpr", len)?;
        if self.action != 0 {
            let v = OnConflictAction::try_from(self.action)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.action)))?;
            struct_ser.serialize_field("action", &v)?;
        }
        if !self.arbiter_elems.is_empty() {
            struct_ser.serialize_field("arbiterElems", &self.arbiter_elems)?;
        }
        if let Some(v) = self.arbiter_where.as_ref() {
            struct_ser.serialize_field("arbiterWhere", v)?;
        }
        if self.constraint != 0 {
            struct_ser.serialize_field("constraint", &self.constraint)?;
        }
        if !self.on_conflict_set.is_empty() {
            struct_ser.serialize_field("onConflictSet", &self.on_conflict_set)?;
        }
        if let Some(v) = self.on_conflict_where.as_ref() {
            struct_ser.serialize_field("onConflictWhere", v)?;
        }
        if self.excl_rel_index != 0 {
            struct_ser.serialize_field("exclRelIndex", &self.excl_rel_index)?;
        }
        if !self.excl_rel_tlist.is_empty() {
            struct_ser.serialize_field("exclRelTlist", &self.excl_rel_tlist)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OnConflictExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "action",
            "arbiter_elems",
            "arbiterElems",
            "arbiter_where",
            "arbiterWhere",
            "constraint",
            "on_conflict_set",
            "onConflictSet",
            "on_conflict_where",
            "onConflictWhere",
            "excl_rel_index",
            "exclRelIndex",
            "excl_rel_tlist",
            "exclRelTlist",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Action,
            ArbiterElems,
            ArbiterWhere,
            Constraint,
            OnConflictSet,
            OnConflictWhere,
            ExclRelIndex,
            ExclRelTlist,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "action" => Ok(GeneratedField::Action),
                            "arbiterElems" | "arbiter_elems" => Ok(GeneratedField::ArbiterElems),
                            "arbiterWhere" | "arbiter_where" => Ok(GeneratedField::ArbiterWhere),
                            "constraint" => Ok(GeneratedField::Constraint),
                            "onConflictSet" | "on_conflict_set" => Ok(GeneratedField::OnConflictSet),
                            "onConflictWhere" | "on_conflict_where" => Ok(GeneratedField::OnConflictWhere),
                            "exclRelIndex" | "excl_rel_index" => Ok(GeneratedField::ExclRelIndex),
                            "exclRelTlist" | "excl_rel_tlist" => Ok(GeneratedField::ExclRelTlist),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OnConflictExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.OnConflictExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OnConflictExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut action__ = None;
                let mut arbiter_elems__ = None;
                let mut arbiter_where__ = None;
                let mut constraint__ = None;
                let mut on_conflict_set__ = None;
                let mut on_conflict_where__ = None;
                let mut excl_rel_index__ = None;
                let mut excl_rel_tlist__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = Some(map_.next_value::<OnConflictAction>()? as i32);
                        }
                        GeneratedField::ArbiterElems => {
                            if arbiter_elems__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arbiterElems"));
                            }
                            arbiter_elems__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ArbiterWhere => {
                            if arbiter_where__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arbiterWhere"));
                            }
                            arbiter_where__ = map_.next_value()?;
                        }
                        GeneratedField::Constraint => {
                            if constraint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraint"));
                            }
                            constraint__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::OnConflictSet => {
                            if on_conflict_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onConflictSet"));
                            }
                            on_conflict_set__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OnConflictWhere => {
                            if on_conflict_where__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onConflictWhere"));
                            }
                            on_conflict_where__ = map_.next_value()?;
                        }
                        GeneratedField::ExclRelIndex => {
                            if excl_rel_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exclRelIndex"));
                            }
                            excl_rel_index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ExclRelTlist => {
                            if excl_rel_tlist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exclRelTlist"));
                            }
                            excl_rel_tlist__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OnConflictExpr {
                    action: action__.unwrap_or_default(),
                    arbiter_elems: arbiter_elems__.unwrap_or_default(),
                    arbiter_where: arbiter_where__,
                    constraint: constraint__.unwrap_or_default(),
                    on_conflict_set: on_conflict_set__.unwrap_or_default(),
                    on_conflict_where: on_conflict_where__,
                    excl_rel_index: excl_rel_index__.unwrap_or_default(),
                    excl_rel_tlist: excl_rel_tlist__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.OnConflictExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OpExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.opno != 0 {
            len += 1;
        }
        if self.opresulttype != 0 {
            len += 1;
        }
        if self.opretset {
            len += 1;
        }
        if self.opcollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.OpExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.opno != 0 {
            struct_ser.serialize_field("opno", &self.opno)?;
        }
        if self.opresulttype != 0 {
            struct_ser.serialize_field("opresulttype", &self.opresulttype)?;
        }
        if self.opretset {
            struct_ser.serialize_field("opretset", &self.opretset)?;
        }
        if self.opcollid != 0 {
            struct_ser.serialize_field("opcollid", &self.opcollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OpExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "opno",
            "opresulttype",
            "opretset",
            "opcollid",
            "inputcollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Opno,
            Opresulttype,
            Opretset,
            Opcollid,
            Inputcollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "opno" => Ok(GeneratedField::Opno),
                            "opresulttype" => Ok(GeneratedField::Opresulttype),
                            "opretset" => Ok(GeneratedField::Opretset),
                            "opcollid" => Ok(GeneratedField::Opcollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OpExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.OpExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OpExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut opno__ = None;
                let mut opresulttype__ = None;
                let mut opretset__ = None;
                let mut opcollid__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Opno => {
                            if opno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opno"));
                            }
                            opno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opresulttype => {
                            if opresulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opresulttype"));
                            }
                            opresulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Opretset => {
                            if opretset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opretset"));
                            }
                            opretset__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opcollid => {
                            if opcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opcollid"));
                            }
                            opcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(OpExpr {
                    xpr: xpr__,
                    opno: opno__.unwrap_or_default(),
                    opresulttype: opresulttype__.unwrap_or_default(),
                    opretset: opretset__.unwrap_or_default(),
                    opcollid: opcollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.OpExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OverridingKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "OVERRIDING_KIND_UNDEFINED",
            Self::OverridingNotSet => "OVERRIDING_NOT_SET",
            Self::OverridingUserValue => "OVERRIDING_USER_VALUE",
            Self::OverridingSystemValue => "OVERRIDING_SYSTEM_VALUE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for OverridingKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OVERRIDING_KIND_UNDEFINED",
            "OVERRIDING_NOT_SET",
            "OVERRIDING_USER_VALUE",
            "OVERRIDING_SYSTEM_VALUE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OverridingKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OVERRIDING_KIND_UNDEFINED" => Ok(OverridingKind::Undefined),
                    "OVERRIDING_NOT_SET" => Ok(OverridingKind::OverridingNotSet),
                    "OVERRIDING_USER_VALUE" => Ok(OverridingKind::OverridingUserValue),
                    "OVERRIDING_SYSTEM_VALUE" => Ok(OverridingKind::OverridingSystemValue),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PlAssignStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.indirection.is_empty() {
            len += 1;
        }
        if self.nnames != 0 {
            len += 1;
        }
        if self.val.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PLAssignStmt", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.indirection.is_empty() {
            struct_ser.serialize_field("indirection", &self.indirection)?;
        }
        if self.nnames != 0 {
            struct_ser.serialize_field("nnames", &self.nnames)?;
        }
        if let Some(v) = self.val.as_ref() {
            struct_ser.serialize_field("val", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlAssignStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "indirection",
            "nnames",
            "val",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Indirection,
            Nnames,
            Val,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "indirection" => Ok(GeneratedField::Indirection),
                            "nnames" => Ok(GeneratedField::Nnames),
                            "val" => Ok(GeneratedField::Val),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlAssignStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PLAssignStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlAssignStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut indirection__ = None;
                let mut nnames__ = None;
                let mut val__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Indirection => {
                            if indirection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indirection"));
                            }
                            indirection__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Nnames => {
                            if nnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nnames"));
                            }
                            nnames__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Val => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("val"));
                            }
                            val__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PlAssignStmt {
                    name: name__.unwrap_or_default(),
                    indirection: indirection__.unwrap_or_default(),
                    nnames: nnames__.unwrap_or_default(),
                    val: val__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PLAssignStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Param {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.paramkind != 0 {
            len += 1;
        }
        if self.paramid != 0 {
            len += 1;
        }
        if self.paramtype != 0 {
            len += 1;
        }
        if self.paramtypmod != 0 {
            len += 1;
        }
        if self.paramcollid != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Param", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.paramkind != 0 {
            let v = ParamKind::try_from(self.paramkind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.paramkind)))?;
            struct_ser.serialize_field("paramkind", &v)?;
        }
        if self.paramid != 0 {
            struct_ser.serialize_field("paramid", &self.paramid)?;
        }
        if self.paramtype != 0 {
            struct_ser.serialize_field("paramtype", &self.paramtype)?;
        }
        if self.paramtypmod != 0 {
            struct_ser.serialize_field("paramtypmod", &self.paramtypmod)?;
        }
        if self.paramcollid != 0 {
            struct_ser.serialize_field("paramcollid", &self.paramcollid)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Param {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "paramkind",
            "paramid",
            "paramtype",
            "paramtypmod",
            "paramcollid",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Paramkind,
            Paramid,
            Paramtype,
            Paramtypmod,
            Paramcollid,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "paramkind" => Ok(GeneratedField::Paramkind),
                            "paramid" => Ok(GeneratedField::Paramid),
                            "paramtype" => Ok(GeneratedField::Paramtype),
                            "paramtypmod" => Ok(GeneratedField::Paramtypmod),
                            "paramcollid" => Ok(GeneratedField::Paramcollid),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Param;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Param")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Param, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut paramkind__ = None;
                let mut paramid__ = None;
                let mut paramtype__ = None;
                let mut paramtypmod__ = None;
                let mut paramcollid__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Paramkind => {
                            if paramkind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramkind"));
                            }
                            paramkind__ = Some(map_.next_value::<ParamKind>()? as i32);
                        }
                        GeneratedField::Paramid => {
                            if paramid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramid"));
                            }
                            paramid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Paramtype => {
                            if paramtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramtype"));
                            }
                            paramtype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Paramtypmod => {
                            if paramtypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramtypmod"));
                            }
                            paramtypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Paramcollid => {
                            if paramcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramcollid"));
                            }
                            paramcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Param {
                    xpr: xpr__,
                    paramkind: paramkind__.unwrap_or_default(),
                    paramid: paramid__.unwrap_or_default(),
                    paramtype: paramtype__.unwrap_or_default(),
                    paramtypmod: paramtypmod__.unwrap_or_default(),
                    paramcollid: paramcollid__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Param", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ParamKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "PARAM_KIND_UNDEFINED",
            Self::ParamExtern => "PARAM_EXTERN",
            Self::ParamExec => "PARAM_EXEC",
            Self::ParamSublink => "PARAM_SUBLINK",
            Self::ParamMultiexpr => "PARAM_MULTIEXPR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ParamKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PARAM_KIND_UNDEFINED",
            "PARAM_EXTERN",
            "PARAM_EXEC",
            "PARAM_SUBLINK",
            "PARAM_MULTIEXPR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParamKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PARAM_KIND_UNDEFINED" => Ok(ParamKind::Undefined),
                    "PARAM_EXTERN" => Ok(ParamKind::ParamExtern),
                    "PARAM_EXEC" => Ok(ParamKind::ParamExec),
                    "PARAM_SUBLINK" => Ok(ParamKind::ParamSublink),
                    "PARAM_MULTIEXPR" => Ok(ParamKind::ParamMultiexpr),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ParamRef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.number != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ParamRef", len)?;
        if self.number != 0 {
            struct_ser.serialize_field("number", &self.number)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ParamRef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "number",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Number,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "number" => Ok(GeneratedField::Number),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParamRef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ParamRef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ParamRef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut number__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Number => {
                            if number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ParamRef {
                    number: number__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ParamRef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ParseResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version != 0 {
            len += 1;
        }
        if !self.stmts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ParseResult", len)?;
        if self.version != 0 {
            struct_ser.serialize_field("version", &self.version)?;
        }
        if !self.stmts.is_empty() {
            struct_ser.serialize_field("stmts", &self.stmts)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ParseResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "stmts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            Stmts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "stmts" => Ok(GeneratedField::Stmts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParseResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ParseResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ParseResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut stmts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Stmts => {
                            if stmts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmts"));
                            }
                            stmts__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ParseResult {
                    version: version__.unwrap_or_default(),
                    stmts: stmts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ParseResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionBoundSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.strategy.is_empty() {
            len += 1;
        }
        if self.is_default {
            len += 1;
        }
        if self.modulus != 0 {
            len += 1;
        }
        if self.remainder != 0 {
            len += 1;
        }
        if !self.listdatums.is_empty() {
            len += 1;
        }
        if !self.lowerdatums.is_empty() {
            len += 1;
        }
        if !self.upperdatums.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PartitionBoundSpec", len)?;
        if !self.strategy.is_empty() {
            struct_ser.serialize_field("strategy", &self.strategy)?;
        }
        if self.is_default {
            struct_ser.serialize_field("is_default", &self.is_default)?;
        }
        if self.modulus != 0 {
            struct_ser.serialize_field("modulus", &self.modulus)?;
        }
        if self.remainder != 0 {
            struct_ser.serialize_field("remainder", &self.remainder)?;
        }
        if !self.listdatums.is_empty() {
            struct_ser.serialize_field("listdatums", &self.listdatums)?;
        }
        if !self.lowerdatums.is_empty() {
            struct_ser.serialize_field("lowerdatums", &self.lowerdatums)?;
        }
        if !self.upperdatums.is_empty() {
            struct_ser.serialize_field("upperdatums", &self.upperdatums)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PartitionBoundSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "strategy",
            "is_default",
            "modulus",
            "remainder",
            "listdatums",
            "lowerdatums",
            "upperdatums",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Strategy,
            IsDefault,
            Modulus,
            Remainder,
            Listdatums,
            Lowerdatums,
            Upperdatums,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "strategy" => Ok(GeneratedField::Strategy),
                            "is_default" => Ok(GeneratedField::IsDefault),
                            "modulus" => Ok(GeneratedField::Modulus),
                            "remainder" => Ok(GeneratedField::Remainder),
                            "listdatums" => Ok(GeneratedField::Listdatums),
                            "lowerdatums" => Ok(GeneratedField::Lowerdatums),
                            "upperdatums" => Ok(GeneratedField::Upperdatums),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionBoundSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PartitionBoundSpec")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PartitionBoundSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut strategy__ = None;
                let mut is_default__ = None;
                let mut modulus__ = None;
                let mut remainder__ = None;
                let mut listdatums__ = None;
                let mut lowerdatums__ = None;
                let mut upperdatums__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Strategy => {
                            if strategy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strategy"));
                            }
                            strategy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsDefault => {
                            if is_default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_default"));
                            }
                            is_default__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Modulus => {
                            if modulus__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modulus"));
                            }
                            modulus__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Remainder => {
                            if remainder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remainder"));
                            }
                            remainder__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Listdatums => {
                            if listdatums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("listdatums"));
                            }
                            listdatums__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Lowerdatums => {
                            if lowerdatums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowerdatums"));
                            }
                            lowerdatums__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Upperdatums => {
                            if upperdatums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upperdatums"));
                            }
                            upperdatums__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PartitionBoundSpec {
                    strategy: strategy__.unwrap_or_default(),
                    is_default: is_default__.unwrap_or_default(),
                    modulus: modulus__.unwrap_or_default(),
                    remainder: remainder__.unwrap_or_default(),
                    listdatums: listdatums__.unwrap_or_default(),
                    lowerdatums: lowerdatums__.unwrap_or_default(),
                    upperdatums: upperdatums__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PartitionBoundSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionCmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.bound.is_some() {
            len += 1;
        }
        if self.concurrent {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PartitionCmd", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.bound.as_ref() {
            struct_ser.serialize_field("bound", v)?;
        }
        if self.concurrent {
            struct_ser.serialize_field("concurrent", &self.concurrent)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PartitionCmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "bound",
            "concurrent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Bound,
            Concurrent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "bound" => Ok(GeneratedField::Bound),
                            "concurrent" => Ok(GeneratedField::Concurrent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionCmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PartitionCmd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PartitionCmd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut bound__ = None;
                let mut concurrent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Bound => {
                            if bound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bound"));
                            }
                            bound__ = map_.next_value()?;
                        }
                        GeneratedField::Concurrent => {
                            if concurrent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("concurrent"));
                            }
                            concurrent__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PartitionCmd {
                    name: name__,
                    bound: bound__,
                    concurrent: concurrent__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PartitionCmd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionElem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if !self.collation.is_empty() {
            len += 1;
        }
        if !self.opclass.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PartitionElem", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if !self.collation.is_empty() {
            struct_ser.serialize_field("collation", &self.collation)?;
        }
        if !self.opclass.is_empty() {
            struct_ser.serialize_field("opclass", &self.opclass)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PartitionElem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "expr",
            "collation",
            "opclass",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Expr,
            Collation,
            Opclass,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "expr" => Ok(GeneratedField::Expr),
                            "collation" => Ok(GeneratedField::Collation),
                            "opclass" => Ok(GeneratedField::Opclass),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionElem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PartitionElem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PartitionElem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut expr__ = None;
                let mut collation__ = None;
                let mut opclass__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Collation => {
                            if collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collation"));
                            }
                            collation__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opclass => {
                            if opclass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opclass"));
                            }
                            opclass__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PartitionElem {
                    name: name__.unwrap_or_default(),
                    expr: expr__,
                    collation: collation__.unwrap_or_default(),
                    opclass: opclass__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PartitionElem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionRangeDatum {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PartitionRangeDatum", len)?;
        if self.kind != 0 {
            let v = PartitionRangeDatumKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PartitionRangeDatum {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "value",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Value,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "value" => Ok(GeneratedField::Value),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionRangeDatum;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PartitionRangeDatum")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PartitionRangeDatum, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut value__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<PartitionRangeDatumKind>()? as i32);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PartitionRangeDatum {
                    kind: kind__.unwrap_or_default(),
                    value: value__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PartitionRangeDatum", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionRangeDatumKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "PARTITION_RANGE_DATUM_KIND_UNDEFINED",
            Self::PartitionRangeDatumMinvalue => "PARTITION_RANGE_DATUM_MINVALUE",
            Self::PartitionRangeDatumValue => "PARTITION_RANGE_DATUM_VALUE",
            Self::PartitionRangeDatumMaxvalue => "PARTITION_RANGE_DATUM_MAXVALUE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PartitionRangeDatumKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PARTITION_RANGE_DATUM_KIND_UNDEFINED",
            "PARTITION_RANGE_DATUM_MINVALUE",
            "PARTITION_RANGE_DATUM_VALUE",
            "PARTITION_RANGE_DATUM_MAXVALUE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionRangeDatumKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PARTITION_RANGE_DATUM_KIND_UNDEFINED" => Ok(PartitionRangeDatumKind::Undefined),
                    "PARTITION_RANGE_DATUM_MINVALUE" => Ok(PartitionRangeDatumKind::PartitionRangeDatumMinvalue),
                    "PARTITION_RANGE_DATUM_VALUE" => Ok(PartitionRangeDatumKind::PartitionRangeDatumValue),
                    "PARTITION_RANGE_DATUM_MAXVALUE" => Ok(PartitionRangeDatumKind::PartitionRangeDatumMaxvalue),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.strategy != 0 {
            len += 1;
        }
        if !self.part_params.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PartitionSpec", len)?;
        if self.strategy != 0 {
            let v = PartitionStrategy::try_from(self.strategy)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.strategy)))?;
            struct_ser.serialize_field("strategy", &v)?;
        }
        if !self.part_params.is_empty() {
            struct_ser.serialize_field("partParams", &self.part_params)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PartitionSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "strategy",
            "part_params",
            "partParams",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Strategy,
            PartParams,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "strategy" => Ok(GeneratedField::Strategy),
                            "partParams" | "part_params" => Ok(GeneratedField::PartParams),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PartitionSpec")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PartitionSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut strategy__ = None;
                let mut part_params__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Strategy => {
                            if strategy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strategy"));
                            }
                            strategy__ = Some(map_.next_value::<PartitionStrategy>()? as i32);
                        }
                        GeneratedField::PartParams => {
                            if part_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partParams"));
                            }
                            part_params__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PartitionSpec {
                    strategy: strategy__.unwrap_or_default(),
                    part_params: part_params__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PartitionSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PartitionStrategy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "PARTITION_STRATEGY_UNDEFINED",
            Self::List => "PARTITION_STRATEGY_LIST",
            Self::Range => "PARTITION_STRATEGY_RANGE",
            Self::Hash => "PARTITION_STRATEGY_HASH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PartitionStrategy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PARTITION_STRATEGY_UNDEFINED",
            "PARTITION_STRATEGY_LIST",
            "PARTITION_STRATEGY_RANGE",
            "PARTITION_STRATEGY_HASH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PartitionStrategy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PARTITION_STRATEGY_UNDEFINED" => Ok(PartitionStrategy::Undefined),
                    "PARTITION_STRATEGY_LIST" => Ok(PartitionStrategy::List),
                    "PARTITION_STRATEGY_RANGE" => Ok(PartitionStrategy::Range),
                    "PARTITION_STRATEGY_HASH" => Ok(PartitionStrategy::Hash),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.argtypes.is_empty() {
            len += 1;
        }
        if self.query.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PrepareStmt", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.argtypes.is_empty() {
            struct_ser.serialize_field("argtypes", &self.argtypes)?;
        }
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "argtypes",
            "query",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Argtypes,
            Query,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "argtypes" => Ok(GeneratedField::Argtypes),
                            "query" => Ok(GeneratedField::Query),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PrepareStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut argtypes__ = None;
                let mut query__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Argtypes => {
                            if argtypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argtypes"));
                            }
                            argtypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PrepareStmt {
                    name: name__.unwrap_or_default(),
                    argtypes: argtypes__.unwrap_or_default(),
                    query: query__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PrepareStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PublicationObjSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pubobjtype != 0 {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.pubtable.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PublicationObjSpec", len)?;
        if self.pubobjtype != 0 {
            let v = PublicationObjSpecType::try_from(self.pubobjtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.pubobjtype)))?;
            struct_ser.serialize_field("pubobjtype", &v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.pubtable.as_ref() {
            struct_ser.serialize_field("pubtable", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PublicationObjSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pubobjtype",
            "name",
            "pubtable",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Pubobjtype,
            Name,
            Pubtable,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pubobjtype" => Ok(GeneratedField::Pubobjtype),
                            "name" => Ok(GeneratedField::Name),
                            "pubtable" => Ok(GeneratedField::Pubtable),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PublicationObjSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PublicationObjSpec")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PublicationObjSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pubobjtype__ = None;
                let mut name__ = None;
                let mut pubtable__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Pubobjtype => {
                            if pubobjtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubobjtype"));
                            }
                            pubobjtype__ = Some(map_.next_value::<PublicationObjSpecType>()? as i32);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pubtable => {
                            if pubtable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubtable"));
                            }
                            pubtable__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PublicationObjSpec {
                    pubobjtype: pubobjtype__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    pubtable: pubtable__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PublicationObjSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PublicationObjSpecType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED",
            Self::PublicationobjTable => "PUBLICATIONOBJ_TABLE",
            Self::PublicationobjTablesInSchema => "PUBLICATIONOBJ_TABLES_IN_SCHEMA",
            Self::PublicationobjTablesInCurSchema => "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA",
            Self::PublicationobjContinuation => "PUBLICATIONOBJ_CONTINUATION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PublicationObjSpecType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED",
            "PUBLICATIONOBJ_TABLE",
            "PUBLICATIONOBJ_TABLES_IN_SCHEMA",
            "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA",
            "PUBLICATIONOBJ_CONTINUATION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PublicationObjSpecType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED" => Ok(PublicationObjSpecType::Undefined),
                    "PUBLICATIONOBJ_TABLE" => Ok(PublicationObjSpecType::PublicationobjTable),
                    "PUBLICATIONOBJ_TABLES_IN_SCHEMA" => Ok(PublicationObjSpecType::PublicationobjTablesInSchema),
                    "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA" => Ok(PublicationObjSpecType::PublicationobjTablesInCurSchema),
                    "PUBLICATIONOBJ_CONTINUATION" => Ok(PublicationObjSpecType::PublicationobjContinuation),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PublicationTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.columns.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.PublicationTable", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.columns.is_empty() {
            struct_ser.serialize_field("columns", &self.columns)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PublicationTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "where_clause",
            "whereClause",
            "columns",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            WhereClause,
            Columns,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "columns" => Ok(GeneratedField::Columns),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PublicationTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.PublicationTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PublicationTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut where_clause__ = None;
                let mut columns__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Columns => {
                            if columns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("columns"));
                            }
                            columns__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PublicationTable {
                    relation: relation__,
                    where_clause: where_clause__,
                    columns: columns__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.PublicationTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Query {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.command_type != 0 {
            len += 1;
        }
        if self.query_source != 0 {
            len += 1;
        }
        if self.can_set_tag {
            len += 1;
        }
        if self.utility_stmt.is_some() {
            len += 1;
        }
        if self.result_relation != 0 {
            len += 1;
        }
        if self.has_aggs {
            len += 1;
        }
        if self.has_window_funcs {
            len += 1;
        }
        if self.has_target_srfs {
            len += 1;
        }
        if self.has_sub_links {
            len += 1;
        }
        if self.has_distinct_on {
            len += 1;
        }
        if self.has_recursive {
            len += 1;
        }
        if self.has_modifying_cte {
            len += 1;
        }
        if self.has_for_update {
            len += 1;
        }
        if self.has_row_security {
            len += 1;
        }
        if self.is_return {
            len += 1;
        }
        if !self.cte_list.is_empty() {
            len += 1;
        }
        if !self.rtable.is_empty() {
            len += 1;
        }
        if !self.rteperminfos.is_empty() {
            len += 1;
        }
        if self.jointree.is_some() {
            len += 1;
        }
        if !self.merge_action_list.is_empty() {
            len += 1;
        }
        if self.merge_use_outer_join {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if self.r#override != 0 {
            len += 1;
        }
        if self.on_conflict.is_some() {
            len += 1;
        }
        if !self.returning_list.is_empty() {
            len += 1;
        }
        if !self.group_clause.is_empty() {
            len += 1;
        }
        if self.group_distinct {
            len += 1;
        }
        if !self.grouping_sets.is_empty() {
            len += 1;
        }
        if self.having_qual.is_some() {
            len += 1;
        }
        if !self.window_clause.is_empty() {
            len += 1;
        }
        if !self.distinct_clause.is_empty() {
            len += 1;
        }
        if !self.sort_clause.is_empty() {
            len += 1;
        }
        if self.limit_offset.is_some() {
            len += 1;
        }
        if self.limit_count.is_some() {
            len += 1;
        }
        if self.limit_option != 0 {
            len += 1;
        }
        if !self.row_marks.is_empty() {
            len += 1;
        }
        if self.set_operations.is_some() {
            len += 1;
        }
        if !self.constraint_deps.is_empty() {
            len += 1;
        }
        if !self.with_check_options.is_empty() {
            len += 1;
        }
        if self.stmt_location != 0 {
            len += 1;
        }
        if self.stmt_len != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Query", len)?;
        if self.command_type != 0 {
            let v = CmdType::try_from(self.command_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.command_type)))?;
            struct_ser.serialize_field("commandType", &v)?;
        }
        if self.query_source != 0 {
            let v = QuerySource::try_from(self.query_source)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.query_source)))?;
            struct_ser.serialize_field("querySource", &v)?;
        }
        if self.can_set_tag {
            struct_ser.serialize_field("canSetTag", &self.can_set_tag)?;
        }
        if let Some(v) = self.utility_stmt.as_ref() {
            struct_ser.serialize_field("utilityStmt", v)?;
        }
        if self.result_relation != 0 {
            struct_ser.serialize_field("resultRelation", &self.result_relation)?;
        }
        if self.has_aggs {
            struct_ser.serialize_field("hasAggs", &self.has_aggs)?;
        }
        if self.has_window_funcs {
            struct_ser.serialize_field("hasWindowFuncs", &self.has_window_funcs)?;
        }
        if self.has_target_srfs {
            struct_ser.serialize_field("hasTargetSRFs", &self.has_target_srfs)?;
        }
        if self.has_sub_links {
            struct_ser.serialize_field("hasSubLinks", &self.has_sub_links)?;
        }
        if self.has_distinct_on {
            struct_ser.serialize_field("hasDistinctOn", &self.has_distinct_on)?;
        }
        if self.has_recursive {
            struct_ser.serialize_field("hasRecursive", &self.has_recursive)?;
        }
        if self.has_modifying_cte {
            struct_ser.serialize_field("hasModifyingCTE", &self.has_modifying_cte)?;
        }
        if self.has_for_update {
            struct_ser.serialize_field("hasForUpdate", &self.has_for_update)?;
        }
        if self.has_row_security {
            struct_ser.serialize_field("hasRowSecurity", &self.has_row_security)?;
        }
        if self.is_return {
            struct_ser.serialize_field("isReturn", &self.is_return)?;
        }
        if !self.cte_list.is_empty() {
            struct_ser.serialize_field("cteList", &self.cte_list)?;
        }
        if !self.rtable.is_empty() {
            struct_ser.serialize_field("rtable", &self.rtable)?;
        }
        if !self.rteperminfos.is_empty() {
            struct_ser.serialize_field("rteperminfos", &self.rteperminfos)?;
        }
        if let Some(v) = self.jointree.as_ref() {
            struct_ser.serialize_field("jointree", v)?;
        }
        if !self.merge_action_list.is_empty() {
            struct_ser.serialize_field("mergeActionList", &self.merge_action_list)?;
        }
        if self.merge_use_outer_join {
            struct_ser.serialize_field("mergeUseOuterJoin", &self.merge_use_outer_join)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if self.r#override != 0 {
            let v = OverridingKind::try_from(self.r#override)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#override)))?;
            struct_ser.serialize_field("override", &v)?;
        }
        if let Some(v) = self.on_conflict.as_ref() {
            struct_ser.serialize_field("onConflict", v)?;
        }
        if !self.returning_list.is_empty() {
            struct_ser.serialize_field("returningList", &self.returning_list)?;
        }
        if !self.group_clause.is_empty() {
            struct_ser.serialize_field("groupClause", &self.group_clause)?;
        }
        if self.group_distinct {
            struct_ser.serialize_field("groupDistinct", &self.group_distinct)?;
        }
        if !self.grouping_sets.is_empty() {
            struct_ser.serialize_field("groupingSets", &self.grouping_sets)?;
        }
        if let Some(v) = self.having_qual.as_ref() {
            struct_ser.serialize_field("havingQual", v)?;
        }
        if !self.window_clause.is_empty() {
            struct_ser.serialize_field("windowClause", &self.window_clause)?;
        }
        if !self.distinct_clause.is_empty() {
            struct_ser.serialize_field("distinctClause", &self.distinct_clause)?;
        }
        if !self.sort_clause.is_empty() {
            struct_ser.serialize_field("sortClause", &self.sort_clause)?;
        }
        if let Some(v) = self.limit_offset.as_ref() {
            struct_ser.serialize_field("limitOffset", v)?;
        }
        if let Some(v) = self.limit_count.as_ref() {
            struct_ser.serialize_field("limitCount", v)?;
        }
        if self.limit_option != 0 {
            let v = LimitOption::try_from(self.limit_option)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.limit_option)))?;
            struct_ser.serialize_field("limitOption", &v)?;
        }
        if !self.row_marks.is_empty() {
            struct_ser.serialize_field("rowMarks", &self.row_marks)?;
        }
        if let Some(v) = self.set_operations.as_ref() {
            struct_ser.serialize_field("setOperations", v)?;
        }
        if !self.constraint_deps.is_empty() {
            struct_ser.serialize_field("constraintDeps", &self.constraint_deps)?;
        }
        if !self.with_check_options.is_empty() {
            struct_ser.serialize_field("withCheckOptions", &self.with_check_options)?;
        }
        if self.stmt_location != 0 {
            struct_ser.serialize_field("stmt_location", &self.stmt_location)?;
        }
        if self.stmt_len != 0 {
            struct_ser.serialize_field("stmt_len", &self.stmt_len)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Query {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "command_type",
            "commandType",
            "query_source",
            "querySource",
            "can_set_tag",
            "canSetTag",
            "utility_stmt",
            "utilityStmt",
            "result_relation",
            "resultRelation",
            "has_aggs",
            "hasAggs",
            "has_window_funcs",
            "hasWindowFuncs",
            "has_target_srfs",
            "hasTargetSRFs",
            "has_sub_links",
            "hasSubLinks",
            "has_distinct_on",
            "hasDistinctOn",
            "has_recursive",
            "hasRecursive",
            "has_modifying_cte",
            "hasModifyingCTE",
            "has_for_update",
            "hasForUpdate",
            "has_row_security",
            "hasRowSecurity",
            "is_return",
            "isReturn",
            "cte_list",
            "cteList",
            "rtable",
            "rteperminfos",
            "jointree",
            "merge_action_list",
            "mergeActionList",
            "merge_use_outer_join",
            "mergeUseOuterJoin",
            "target_list",
            "targetList",
            "override",
            "on_conflict",
            "onConflict",
            "returning_list",
            "returningList",
            "group_clause",
            "groupClause",
            "group_distinct",
            "groupDistinct",
            "grouping_sets",
            "groupingSets",
            "having_qual",
            "havingQual",
            "window_clause",
            "windowClause",
            "distinct_clause",
            "distinctClause",
            "sort_clause",
            "sortClause",
            "limit_offset",
            "limitOffset",
            "limit_count",
            "limitCount",
            "limit_option",
            "limitOption",
            "row_marks",
            "rowMarks",
            "set_operations",
            "setOperations",
            "constraint_deps",
            "constraintDeps",
            "with_check_options",
            "withCheckOptions",
            "stmt_location",
            "stmt_len",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommandType,
            QuerySource,
            CanSetTag,
            UtilityStmt,
            ResultRelation,
            HasAggs,
            HasWindowFuncs,
            HasTargetSrfs,
            HasSubLinks,
            HasDistinctOn,
            HasRecursive,
            HasModifyingCte,
            HasForUpdate,
            HasRowSecurity,
            IsReturn,
            CteList,
            Rtable,
            Rteperminfos,
            Jointree,
            MergeActionList,
            MergeUseOuterJoin,
            TargetList,
            Override,
            OnConflict,
            ReturningList,
            GroupClause,
            GroupDistinct,
            GroupingSets,
            HavingQual,
            WindowClause,
            DistinctClause,
            SortClause,
            LimitOffset,
            LimitCount,
            LimitOption,
            RowMarks,
            SetOperations,
            ConstraintDeps,
            WithCheckOptions,
            StmtLocation,
            StmtLen,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "commandType" | "command_type" => Ok(GeneratedField::CommandType),
                            "querySource" | "query_source" => Ok(GeneratedField::QuerySource),
                            "canSetTag" | "can_set_tag" => Ok(GeneratedField::CanSetTag),
                            "utilityStmt" | "utility_stmt" => Ok(GeneratedField::UtilityStmt),
                            "resultRelation" | "result_relation" => Ok(GeneratedField::ResultRelation),
                            "hasAggs" | "has_aggs" => Ok(GeneratedField::HasAggs),
                            "hasWindowFuncs" | "has_window_funcs" => Ok(GeneratedField::HasWindowFuncs),
                            "hasTargetSRFs" | "has_target_srfs" => Ok(GeneratedField::HasTargetSrfs),
                            "hasSubLinks" | "has_sub_links" => Ok(GeneratedField::HasSubLinks),
                            "hasDistinctOn" | "has_distinct_on" => Ok(GeneratedField::HasDistinctOn),
                            "hasRecursive" | "has_recursive" => Ok(GeneratedField::HasRecursive),
                            "hasModifyingCTE" | "has_modifying_cte" => Ok(GeneratedField::HasModifyingCte),
                            "hasForUpdate" | "has_for_update" => Ok(GeneratedField::HasForUpdate),
                            "hasRowSecurity" | "has_row_security" => Ok(GeneratedField::HasRowSecurity),
                            "isReturn" | "is_return" => Ok(GeneratedField::IsReturn),
                            "cteList" | "cte_list" => Ok(GeneratedField::CteList),
                            "rtable" => Ok(GeneratedField::Rtable),
                            "rteperminfos" => Ok(GeneratedField::Rteperminfos),
                            "jointree" => Ok(GeneratedField::Jointree),
                            "mergeActionList" | "merge_action_list" => Ok(GeneratedField::MergeActionList),
                            "mergeUseOuterJoin" | "merge_use_outer_join" => Ok(GeneratedField::MergeUseOuterJoin),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "override" => Ok(GeneratedField::Override),
                            "onConflict" | "on_conflict" => Ok(GeneratedField::OnConflict),
                            "returningList" | "returning_list" => Ok(GeneratedField::ReturningList),
                            "groupClause" | "group_clause" => Ok(GeneratedField::GroupClause),
                            "groupDistinct" | "group_distinct" => Ok(GeneratedField::GroupDistinct),
                            "groupingSets" | "grouping_sets" => Ok(GeneratedField::GroupingSets),
                            "havingQual" | "having_qual" => Ok(GeneratedField::HavingQual),
                            "windowClause" | "window_clause" => Ok(GeneratedField::WindowClause),
                            "distinctClause" | "distinct_clause" => Ok(GeneratedField::DistinctClause),
                            "sortClause" | "sort_clause" => Ok(GeneratedField::SortClause),
                            "limitOffset" | "limit_offset" => Ok(GeneratedField::LimitOffset),
                            "limitCount" | "limit_count" => Ok(GeneratedField::LimitCount),
                            "limitOption" | "limit_option" => Ok(GeneratedField::LimitOption),
                            "rowMarks" | "row_marks" => Ok(GeneratedField::RowMarks),
                            "setOperations" | "set_operations" => Ok(GeneratedField::SetOperations),
                            "constraintDeps" | "constraint_deps" => Ok(GeneratedField::ConstraintDeps),
                            "withCheckOptions" | "with_check_options" => Ok(GeneratedField::WithCheckOptions),
                            "stmt_location" => Ok(GeneratedField::StmtLocation),
                            "stmt_len" => Ok(GeneratedField::StmtLen),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Query;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Query")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Query, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut command_type__ = None;
                let mut query_source__ = None;
                let mut can_set_tag__ = None;
                let mut utility_stmt__ = None;
                let mut result_relation__ = None;
                let mut has_aggs__ = None;
                let mut has_window_funcs__ = None;
                let mut has_target_srfs__ = None;
                let mut has_sub_links__ = None;
                let mut has_distinct_on__ = None;
                let mut has_recursive__ = None;
                let mut has_modifying_cte__ = None;
                let mut has_for_update__ = None;
                let mut has_row_security__ = None;
                let mut is_return__ = None;
                let mut cte_list__ = None;
                let mut rtable__ = None;
                let mut rteperminfos__ = None;
                let mut jointree__ = None;
                let mut merge_action_list__ = None;
                let mut merge_use_outer_join__ = None;
                let mut target_list__ = None;
                let mut r#override__ = None;
                let mut on_conflict__ = None;
                let mut returning_list__ = None;
                let mut group_clause__ = None;
                let mut group_distinct__ = None;
                let mut grouping_sets__ = None;
                let mut having_qual__ = None;
                let mut window_clause__ = None;
                let mut distinct_clause__ = None;
                let mut sort_clause__ = None;
                let mut limit_offset__ = None;
                let mut limit_count__ = None;
                let mut limit_option__ = None;
                let mut row_marks__ = None;
                let mut set_operations__ = None;
                let mut constraint_deps__ = None;
                let mut with_check_options__ = None;
                let mut stmt_location__ = None;
                let mut stmt_len__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommandType => {
                            if command_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commandType"));
                            }
                            command_type__ = Some(map_.next_value::<CmdType>()? as i32);
                        }
                        GeneratedField::QuerySource => {
                            if query_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("querySource"));
                            }
                            query_source__ = Some(map_.next_value::<QuerySource>()? as i32);
                        }
                        GeneratedField::CanSetTag => {
                            if can_set_tag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canSetTag"));
                            }
                            can_set_tag__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UtilityStmt => {
                            if utility_stmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("utilityStmt"));
                            }
                            utility_stmt__ = map_.next_value()?;
                        }
                        GeneratedField::ResultRelation => {
                            if result_relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultRelation"));
                            }
                            result_relation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HasAggs => {
                            if has_aggs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasAggs"));
                            }
                            has_aggs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasWindowFuncs => {
                            if has_window_funcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasWindowFuncs"));
                            }
                            has_window_funcs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasTargetSrfs => {
                            if has_target_srfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasTargetSRFs"));
                            }
                            has_target_srfs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasSubLinks => {
                            if has_sub_links__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasSubLinks"));
                            }
                            has_sub_links__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasDistinctOn => {
                            if has_distinct_on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasDistinctOn"));
                            }
                            has_distinct_on__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasRecursive => {
                            if has_recursive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasRecursive"));
                            }
                            has_recursive__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasModifyingCte => {
                            if has_modifying_cte__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasModifyingCTE"));
                            }
                            has_modifying_cte__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasForUpdate => {
                            if has_for_update__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasForUpdate"));
                            }
                            has_for_update__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HasRowSecurity => {
                            if has_row_security__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasRowSecurity"));
                            }
                            has_row_security__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsReturn => {
                            if is_return__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isReturn"));
                            }
                            is_return__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CteList => {
                            if cte_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cteList"));
                            }
                            cte_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rtable => {
                            if rtable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rtable"));
                            }
                            rtable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rteperminfos => {
                            if rteperminfos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rteperminfos"));
                            }
                            rteperminfos__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Jointree => {
                            if jointree__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jointree"));
                            }
                            jointree__ = map_.next_value()?;
                        }
                        GeneratedField::MergeActionList => {
                            if merge_action_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mergeActionList"));
                            }
                            merge_action_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MergeUseOuterJoin => {
                            if merge_use_outer_join__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mergeUseOuterJoin"));
                            }
                            merge_use_outer_join__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Override => {
                            if r#override__.is_some() {
                                return Err(serde::de::Error::duplicate_field("override"));
                            }
                            r#override__ = Some(map_.next_value::<OverridingKind>()? as i32);
                        }
                        GeneratedField::OnConflict => {
                            if on_conflict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onConflict"));
                            }
                            on_conflict__ = map_.next_value()?;
                        }
                        GeneratedField::ReturningList => {
                            if returning_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returningList"));
                            }
                            returning_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupClause => {
                            if group_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupClause"));
                            }
                            group_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupDistinct => {
                            if group_distinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupDistinct"));
                            }
                            group_distinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupingSets => {
                            if grouping_sets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupingSets"));
                            }
                            grouping_sets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HavingQual => {
                            if having_qual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("havingQual"));
                            }
                            having_qual__ = map_.next_value()?;
                        }
                        GeneratedField::WindowClause => {
                            if window_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowClause"));
                            }
                            window_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DistinctClause => {
                            if distinct_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distinctClause"));
                            }
                            distinct_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SortClause => {
                            if sort_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sortClause"));
                            }
                            sort_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitOffset => {
                            if limit_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOffset"));
                            }
                            limit_offset__ = map_.next_value()?;
                        }
                        GeneratedField::LimitCount => {
                            if limit_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitCount"));
                            }
                            limit_count__ = map_.next_value()?;
                        }
                        GeneratedField::LimitOption => {
                            if limit_option__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOption"));
                            }
                            limit_option__ = Some(map_.next_value::<LimitOption>()? as i32);
                        }
                        GeneratedField::RowMarks => {
                            if row_marks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rowMarks"));
                            }
                            row_marks__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SetOperations => {
                            if set_operations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setOperations"));
                            }
                            set_operations__ = map_.next_value()?;
                        }
                        GeneratedField::ConstraintDeps => {
                            if constraint_deps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraintDeps"));
                            }
                            constraint_deps__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithCheckOptions => {
                            if with_check_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withCheckOptions"));
                            }
                            with_check_options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StmtLocation => {
                            if stmt_location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt_location"));
                            }
                            stmt_location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StmtLen => {
                            if stmt_len__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt_len"));
                            }
                            stmt_len__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Query {
                    command_type: command_type__.unwrap_or_default(),
                    query_source: query_source__.unwrap_or_default(),
                    can_set_tag: can_set_tag__.unwrap_or_default(),
                    utility_stmt: utility_stmt__,
                    result_relation: result_relation__.unwrap_or_default(),
                    has_aggs: has_aggs__.unwrap_or_default(),
                    has_window_funcs: has_window_funcs__.unwrap_or_default(),
                    has_target_srfs: has_target_srfs__.unwrap_or_default(),
                    has_sub_links: has_sub_links__.unwrap_or_default(),
                    has_distinct_on: has_distinct_on__.unwrap_or_default(),
                    has_recursive: has_recursive__.unwrap_or_default(),
                    has_modifying_cte: has_modifying_cte__.unwrap_or_default(),
                    has_for_update: has_for_update__.unwrap_or_default(),
                    has_row_security: has_row_security__.unwrap_or_default(),
                    is_return: is_return__.unwrap_or_default(),
                    cte_list: cte_list__.unwrap_or_default(),
                    rtable: rtable__.unwrap_or_default(),
                    rteperminfos: rteperminfos__.unwrap_or_default(),
                    jointree: jointree__,
                    merge_action_list: merge_action_list__.unwrap_or_default(),
                    merge_use_outer_join: merge_use_outer_join__.unwrap_or_default(),
                    target_list: target_list__.unwrap_or_default(),
                    r#override: r#override__.unwrap_or_default(),
                    on_conflict: on_conflict__,
                    returning_list: returning_list__.unwrap_or_default(),
                    group_clause: group_clause__.unwrap_or_default(),
                    group_distinct: group_distinct__.unwrap_or_default(),
                    grouping_sets: grouping_sets__.unwrap_or_default(),
                    having_qual: having_qual__,
                    window_clause: window_clause__.unwrap_or_default(),
                    distinct_clause: distinct_clause__.unwrap_or_default(),
                    sort_clause: sort_clause__.unwrap_or_default(),
                    limit_offset: limit_offset__,
                    limit_count: limit_count__,
                    limit_option: limit_option__.unwrap_or_default(),
                    row_marks: row_marks__.unwrap_or_default(),
                    set_operations: set_operations__,
                    constraint_deps: constraint_deps__.unwrap_or_default(),
                    with_check_options: with_check_options__.unwrap_or_default(),
                    stmt_location: stmt_location__.unwrap_or_default(),
                    stmt_len: stmt_len__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Query", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for QuerySource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "QUERY_SOURCE_UNDEFINED",
            Self::QsrcOriginal => "QSRC_ORIGINAL",
            Self::QsrcParser => "QSRC_PARSER",
            Self::QsrcInsteadRule => "QSRC_INSTEAD_RULE",
            Self::QsrcQualInsteadRule => "QSRC_QUAL_INSTEAD_RULE",
            Self::QsrcNonInsteadRule => "QSRC_NON_INSTEAD_RULE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for QuerySource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QUERY_SOURCE_UNDEFINED",
            "QSRC_ORIGINAL",
            "QSRC_PARSER",
            "QSRC_INSTEAD_RULE",
            "QSRC_QUAL_INSTEAD_RULE",
            "QSRC_NON_INSTEAD_RULE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "QUERY_SOURCE_UNDEFINED" => Ok(QuerySource::Undefined),
                    "QSRC_ORIGINAL" => Ok(QuerySource::QsrcOriginal),
                    "QSRC_PARSER" => Ok(QuerySource::QsrcParser),
                    "QSRC_INSTEAD_RULE" => Ok(QuerySource::QsrcInsteadRule),
                    "QSRC_QUAL_INSTEAD_RULE" => Ok(QuerySource::QsrcQualInsteadRule),
                    "QSRC_NON_INSTEAD_RULE" => Ok(QuerySource::QsrcNonInsteadRule),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RteKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::RtekindUndefined => "RTEKIND_UNDEFINED",
            Self::RteRelation => "RTE_RELATION",
            Self::RteSubquery => "RTE_SUBQUERY",
            Self::RteJoin => "RTE_JOIN",
            Self::RteFunction => "RTE_FUNCTION",
            Self::RteTablefunc => "RTE_TABLEFUNC",
            Self::RteValues => "RTE_VALUES",
            Self::RteCte => "RTE_CTE",
            Self::RteNamedtuplestore => "RTE_NAMEDTUPLESTORE",
            Self::RteResult => "RTE_RESULT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for RteKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RTEKIND_UNDEFINED",
            "RTE_RELATION",
            "RTE_SUBQUERY",
            "RTE_JOIN",
            "RTE_FUNCTION",
            "RTE_TABLEFUNC",
            "RTE_VALUES",
            "RTE_CTE",
            "RTE_NAMEDTUPLESTORE",
            "RTE_RESULT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RteKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "RTEKIND_UNDEFINED" => Ok(RteKind::RtekindUndefined),
                    "RTE_RELATION" => Ok(RteKind::RteRelation),
                    "RTE_SUBQUERY" => Ok(RteKind::RteSubquery),
                    "RTE_JOIN" => Ok(RteKind::RteJoin),
                    "RTE_FUNCTION" => Ok(RteKind::RteFunction),
                    "RTE_TABLEFUNC" => Ok(RteKind::RteTablefunc),
                    "RTE_VALUES" => Ok(RteKind::RteValues),
                    "RTE_CTE" => Ok(RteKind::RteCte),
                    "RTE_NAMEDTUPLESTORE" => Ok(RteKind::RteNamedtuplestore),
                    "RTE_RESULT" => Ok(RteKind::RteResult),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RtePermissionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relid != 0 {
            len += 1;
        }
        if self.inh {
            len += 1;
        }
        if self.required_perms != 0 {
            len += 1;
        }
        if self.check_as_user != 0 {
            len += 1;
        }
        if !self.selected_cols.is_empty() {
            len += 1;
        }
        if !self.inserted_cols.is_empty() {
            len += 1;
        }
        if !self.updated_cols.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RTEPermissionInfo", len)?;
        if self.relid != 0 {
            struct_ser.serialize_field("relid", &self.relid)?;
        }
        if self.inh {
            struct_ser.serialize_field("inh", &self.inh)?;
        }
        if self.required_perms != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("requiredPerms", ToString::to_string(&self.required_perms).as_str())?;
        }
        if self.check_as_user != 0 {
            struct_ser.serialize_field("checkAsUser", &self.check_as_user)?;
        }
        if !self.selected_cols.is_empty() {
            struct_ser.serialize_field("selectedCols", &self.selected_cols.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if !self.inserted_cols.is_empty() {
            struct_ser.serialize_field("insertedCols", &self.inserted_cols.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if !self.updated_cols.is_empty() {
            struct_ser.serialize_field("updatedCols", &self.updated_cols.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RtePermissionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relid",
            "inh",
            "required_perms",
            "requiredPerms",
            "check_as_user",
            "checkAsUser",
            "selected_cols",
            "selectedCols",
            "inserted_cols",
            "insertedCols",
            "updated_cols",
            "updatedCols",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relid,
            Inh,
            RequiredPerms,
            CheckAsUser,
            SelectedCols,
            InsertedCols,
            UpdatedCols,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relid" => Ok(GeneratedField::Relid),
                            "inh" => Ok(GeneratedField::Inh),
                            "requiredPerms" | "required_perms" => Ok(GeneratedField::RequiredPerms),
                            "checkAsUser" | "check_as_user" => Ok(GeneratedField::CheckAsUser),
                            "selectedCols" | "selected_cols" => Ok(GeneratedField::SelectedCols),
                            "insertedCols" | "inserted_cols" => Ok(GeneratedField::InsertedCols),
                            "updatedCols" | "updated_cols" => Ok(GeneratedField::UpdatedCols),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RtePermissionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RTEPermissionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RtePermissionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relid__ = None;
                let mut inh__ = None;
                let mut required_perms__ = None;
                let mut check_as_user__ = None;
                let mut selected_cols__ = None;
                let mut inserted_cols__ = None;
                let mut updated_cols__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relid => {
                            if relid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relid"));
                            }
                            relid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inh => {
                            if inh__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inh"));
                            }
                            inh__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RequiredPerms => {
                            if required_perms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requiredPerms"));
                            }
                            required_perms__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CheckAsUser => {
                            if check_as_user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkAsUser"));
                            }
                            check_as_user__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SelectedCols => {
                            if selected_cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectedCols"));
                            }
                            selected_cols__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::InsertedCols => {
                            if inserted_cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("insertedCols"));
                            }
                            inserted_cols__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::UpdatedCols => {
                            if updated_cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updatedCols"));
                            }
                            updated_cols__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(RtePermissionInfo {
                    relid: relid__.unwrap_or_default(),
                    inh: inh__.unwrap_or_default(),
                    required_perms: required_perms__.unwrap_or_default(),
                    check_as_user: check_as_user__.unwrap_or_default(),
                    selected_cols: selected_cols__.unwrap_or_default(),
                    inserted_cols: inserted_cols__.unwrap_or_default(),
                    updated_cols: updated_cols__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RTEPermissionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lateral {
            len += 1;
        }
        if self.ordinality {
            len += 1;
        }
        if self.is_rowsfrom {
            len += 1;
        }
        if !self.functions.is_empty() {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        if !self.coldeflist.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeFunction", len)?;
        if self.lateral {
            struct_ser.serialize_field("lateral", &self.lateral)?;
        }
        if self.ordinality {
            struct_ser.serialize_field("ordinality", &self.ordinality)?;
        }
        if self.is_rowsfrom {
            struct_ser.serialize_field("is_rowsfrom", &self.is_rowsfrom)?;
        }
        if !self.functions.is_empty() {
            struct_ser.serialize_field("functions", &self.functions)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        if !self.coldeflist.is_empty() {
            struct_ser.serialize_field("coldeflist", &self.coldeflist)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "lateral",
            "ordinality",
            "is_rowsfrom",
            "functions",
            "alias",
            "coldeflist",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Lateral,
            Ordinality,
            IsRowsfrom,
            Functions,
            Alias,
            Coldeflist,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "lateral" => Ok(GeneratedField::Lateral),
                            "ordinality" => Ok(GeneratedField::Ordinality),
                            "is_rowsfrom" => Ok(GeneratedField::IsRowsfrom),
                            "functions" => Ok(GeneratedField::Functions),
                            "alias" => Ok(GeneratedField::Alias),
                            "coldeflist" => Ok(GeneratedField::Coldeflist),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lateral__ = None;
                let mut ordinality__ = None;
                let mut is_rowsfrom__ = None;
                let mut functions__ = None;
                let mut alias__ = None;
                let mut coldeflist__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Lateral => {
                            if lateral__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lateral"));
                            }
                            lateral__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ordinality => {
                            if ordinality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ordinality"));
                            }
                            ordinality__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsRowsfrom => {
                            if is_rowsfrom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_rowsfrom"));
                            }
                            is_rowsfrom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Functions => {
                            if functions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functions"));
                            }
                            functions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                        GeneratedField::Coldeflist => {
                            if coldeflist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coldeflist"));
                            }
                            coldeflist__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RangeFunction {
                    lateral: lateral__.unwrap_or_default(),
                    ordinality: ordinality__.unwrap_or_default(),
                    is_rowsfrom: is_rowsfrom__.unwrap_or_default(),
                    functions: functions__.unwrap_or_default(),
                    alias: alias__,
                    coldeflist: coldeflist__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeSubselect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lateral {
            len += 1;
        }
        if self.subquery.is_some() {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeSubselect", len)?;
        if self.lateral {
            struct_ser.serialize_field("lateral", &self.lateral)?;
        }
        if let Some(v) = self.subquery.as_ref() {
            struct_ser.serialize_field("subquery", v)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeSubselect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "lateral",
            "subquery",
            "alias",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Lateral,
            Subquery,
            Alias,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "lateral" => Ok(GeneratedField::Lateral),
                            "subquery" => Ok(GeneratedField::Subquery),
                            "alias" => Ok(GeneratedField::Alias),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeSubselect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeSubselect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeSubselect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lateral__ = None;
                let mut subquery__ = None;
                let mut alias__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Lateral => {
                            if lateral__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lateral"));
                            }
                            lateral__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Subquery => {
                            if subquery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subquery"));
                            }
                            subquery__ = map_.next_value()?;
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RangeSubselect {
                    lateral: lateral__.unwrap_or_default(),
                    subquery: subquery__,
                    alias: alias__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeSubselect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTableFunc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lateral {
            len += 1;
        }
        if self.docexpr.is_some() {
            len += 1;
        }
        if self.rowexpr.is_some() {
            len += 1;
        }
        if !self.namespaces.is_empty() {
            len += 1;
        }
        if !self.columns.is_empty() {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTableFunc", len)?;
        if self.lateral {
            struct_ser.serialize_field("lateral", &self.lateral)?;
        }
        if let Some(v) = self.docexpr.as_ref() {
            struct_ser.serialize_field("docexpr", v)?;
        }
        if let Some(v) = self.rowexpr.as_ref() {
            struct_ser.serialize_field("rowexpr", v)?;
        }
        if !self.namespaces.is_empty() {
            struct_ser.serialize_field("namespaces", &self.namespaces)?;
        }
        if !self.columns.is_empty() {
            struct_ser.serialize_field("columns", &self.columns)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTableFunc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "lateral",
            "docexpr",
            "rowexpr",
            "namespaces",
            "columns",
            "alias",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Lateral,
            Docexpr,
            Rowexpr,
            Namespaces,
            Columns,
            Alias,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "lateral" => Ok(GeneratedField::Lateral),
                            "docexpr" => Ok(GeneratedField::Docexpr),
                            "rowexpr" => Ok(GeneratedField::Rowexpr),
                            "namespaces" => Ok(GeneratedField::Namespaces),
                            "columns" => Ok(GeneratedField::Columns),
                            "alias" => Ok(GeneratedField::Alias),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTableFunc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTableFunc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTableFunc, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lateral__ = None;
                let mut docexpr__ = None;
                let mut rowexpr__ = None;
                let mut namespaces__ = None;
                let mut columns__ = None;
                let mut alias__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Lateral => {
                            if lateral__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lateral"));
                            }
                            lateral__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Docexpr => {
                            if docexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("docexpr"));
                            }
                            docexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Rowexpr => {
                            if rowexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rowexpr"));
                            }
                            rowexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Namespaces => {
                            if namespaces__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespaces"));
                            }
                            namespaces__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Columns => {
                            if columns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("columns"));
                            }
                            columns__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeTableFunc {
                    lateral: lateral__.unwrap_or_default(),
                    docexpr: docexpr__,
                    rowexpr: rowexpr__,
                    namespaces: namespaces__.unwrap_or_default(),
                    columns: columns__.unwrap_or_default(),
                    alias: alias__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTableFunc", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTableFuncCol {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.colname.is_empty() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if self.for_ordinality {
            len += 1;
        }
        if self.is_not_null {
            len += 1;
        }
        if self.colexpr.is_some() {
            len += 1;
        }
        if self.coldefexpr.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTableFuncCol", len)?;
        if !self.colname.is_empty() {
            struct_ser.serialize_field("colname", &self.colname)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if self.for_ordinality {
            struct_ser.serialize_field("for_ordinality", &self.for_ordinality)?;
        }
        if self.is_not_null {
            struct_ser.serialize_field("is_not_null", &self.is_not_null)?;
        }
        if let Some(v) = self.colexpr.as_ref() {
            struct_ser.serialize_field("colexpr", v)?;
        }
        if let Some(v) = self.coldefexpr.as_ref() {
            struct_ser.serialize_field("coldefexpr", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTableFuncCol {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "colname",
            "type_name",
            "typeName",
            "for_ordinality",
            "is_not_null",
            "colexpr",
            "coldefexpr",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Colname,
            TypeName,
            ForOrdinality,
            IsNotNull,
            Colexpr,
            Coldefexpr,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "colname" => Ok(GeneratedField::Colname),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "for_ordinality" => Ok(GeneratedField::ForOrdinality),
                            "is_not_null" => Ok(GeneratedField::IsNotNull),
                            "colexpr" => Ok(GeneratedField::Colexpr),
                            "coldefexpr" => Ok(GeneratedField::Coldefexpr),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTableFuncCol;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTableFuncCol")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTableFuncCol, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut colname__ = None;
                let mut type_name__ = None;
                let mut for_ordinality__ = None;
                let mut is_not_null__ = None;
                let mut colexpr__ = None;
                let mut coldefexpr__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Colname => {
                            if colname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colname"));
                            }
                            colname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::ForOrdinality => {
                            if for_ordinality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("for_ordinality"));
                            }
                            for_ordinality__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsNotNull => {
                            if is_not_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_not_null"));
                            }
                            is_not_null__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Colexpr => {
                            if colexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colexpr"));
                            }
                            colexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Coldefexpr => {
                            if coldefexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coldefexpr"));
                            }
                            coldefexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeTableFuncCol {
                    colname: colname__.unwrap_or_default(),
                    type_name: type_name__,
                    for_ordinality: for_ordinality__.unwrap_or_default(),
                    is_not_null: is_not_null__.unwrap_or_default(),
                    colexpr: colexpr__,
                    coldefexpr: coldefexpr__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTableFuncCol", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTableSample {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.method.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.repeatable.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTableSample", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.method.is_empty() {
            struct_ser.serialize_field("method", &self.method)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.repeatable.as_ref() {
            struct_ser.serialize_field("repeatable", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTableSample {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "method",
            "args",
            "repeatable",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Method,
            Args,
            Repeatable,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "method" => Ok(GeneratedField::Method),
                            "args" => Ok(GeneratedField::Args),
                            "repeatable" => Ok(GeneratedField::Repeatable),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTableSample;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTableSample")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTableSample, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut method__ = None;
                let mut args__ = None;
                let mut repeatable__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Method => {
                            if method__.is_some() {
                                return Err(serde::de::Error::duplicate_field("method"));
                            }
                            method__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Repeatable => {
                            if repeatable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("repeatable"));
                            }
                            repeatable__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeTableSample {
                    relation: relation__,
                    method: method__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    repeatable: repeatable__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTableSample", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTblEntry {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rtekind != 0 {
            len += 1;
        }
        if self.relid != 0 {
            len += 1;
        }
        if !self.relkind.is_empty() {
            len += 1;
        }
        if self.rellockmode != 0 {
            len += 1;
        }
        if self.tablesample.is_some() {
            len += 1;
        }
        if self.perminfoindex != 0 {
            len += 1;
        }
        if self.subquery.is_some() {
            len += 1;
        }
        if self.security_barrier {
            len += 1;
        }
        if self.jointype != 0 {
            len += 1;
        }
        if self.joinmergedcols != 0 {
            len += 1;
        }
        if !self.joinaliasvars.is_empty() {
            len += 1;
        }
        if !self.joinleftcols.is_empty() {
            len += 1;
        }
        if !self.joinrightcols.is_empty() {
            len += 1;
        }
        if self.join_using_alias.is_some() {
            len += 1;
        }
        if !self.functions.is_empty() {
            len += 1;
        }
        if self.funcordinality {
            len += 1;
        }
        if self.tablefunc.is_some() {
            len += 1;
        }
        if !self.values_lists.is_empty() {
            len += 1;
        }
        if !self.ctename.is_empty() {
            len += 1;
        }
        if self.ctelevelsup != 0 {
            len += 1;
        }
        if self.self_reference {
            len += 1;
        }
        if !self.coltypes.is_empty() {
            len += 1;
        }
        if !self.coltypmods.is_empty() {
            len += 1;
        }
        if !self.colcollations.is_empty() {
            len += 1;
        }
        if !self.enrname.is_empty() {
            len += 1;
        }
        if self.enrtuples != 0. {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        if self.eref.is_some() {
            len += 1;
        }
        if self.lateral {
            len += 1;
        }
        if self.inh {
            len += 1;
        }
        if self.in_from_cl {
            len += 1;
        }
        if !self.security_quals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTblEntry", len)?;
        if self.rtekind != 0 {
            let v = RteKind::try_from(self.rtekind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.rtekind)))?;
            struct_ser.serialize_field("rtekind", &v)?;
        }
        if self.relid != 0 {
            struct_ser.serialize_field("relid", &self.relid)?;
        }
        if !self.relkind.is_empty() {
            struct_ser.serialize_field("relkind", &self.relkind)?;
        }
        if self.rellockmode != 0 {
            struct_ser.serialize_field("rellockmode", &self.rellockmode)?;
        }
        if let Some(v) = self.tablesample.as_ref() {
            struct_ser.serialize_field("tablesample", v)?;
        }
        if self.perminfoindex != 0 {
            struct_ser.serialize_field("perminfoindex", &self.perminfoindex)?;
        }
        if let Some(v) = self.subquery.as_ref() {
            struct_ser.serialize_field("subquery", v)?;
        }
        if self.security_barrier {
            struct_ser.serialize_field("security_barrier", &self.security_barrier)?;
        }
        if self.jointype != 0 {
            let v = JoinType::try_from(self.jointype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.jointype)))?;
            struct_ser.serialize_field("jointype", &v)?;
        }
        if self.joinmergedcols != 0 {
            struct_ser.serialize_field("joinmergedcols", &self.joinmergedcols)?;
        }
        if !self.joinaliasvars.is_empty() {
            struct_ser.serialize_field("joinaliasvars", &self.joinaliasvars)?;
        }
        if !self.joinleftcols.is_empty() {
            struct_ser.serialize_field("joinleftcols", &self.joinleftcols)?;
        }
        if !self.joinrightcols.is_empty() {
            struct_ser.serialize_field("joinrightcols", &self.joinrightcols)?;
        }
        if let Some(v) = self.join_using_alias.as_ref() {
            struct_ser.serialize_field("join_using_alias", v)?;
        }
        if !self.functions.is_empty() {
            struct_ser.serialize_field("functions", &self.functions)?;
        }
        if self.funcordinality {
            struct_ser.serialize_field("funcordinality", &self.funcordinality)?;
        }
        if let Some(v) = self.tablefunc.as_ref() {
            struct_ser.serialize_field("tablefunc", v)?;
        }
        if !self.values_lists.is_empty() {
            struct_ser.serialize_field("values_lists", &self.values_lists)?;
        }
        if !self.ctename.is_empty() {
            struct_ser.serialize_field("ctename", &self.ctename)?;
        }
        if self.ctelevelsup != 0 {
            struct_ser.serialize_field("ctelevelsup", &self.ctelevelsup)?;
        }
        if self.self_reference {
            struct_ser.serialize_field("self_reference", &self.self_reference)?;
        }
        if !self.coltypes.is_empty() {
            struct_ser.serialize_field("coltypes", &self.coltypes)?;
        }
        if !self.coltypmods.is_empty() {
            struct_ser.serialize_field("coltypmods", &self.coltypmods)?;
        }
        if !self.colcollations.is_empty() {
            struct_ser.serialize_field("colcollations", &self.colcollations)?;
        }
        if !self.enrname.is_empty() {
            struct_ser.serialize_field("enrname", &self.enrname)?;
        }
        if self.enrtuples != 0. {
            struct_ser.serialize_field("enrtuples", &self.enrtuples)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        if let Some(v) = self.eref.as_ref() {
            struct_ser.serialize_field("eref", v)?;
        }
        if self.lateral {
            struct_ser.serialize_field("lateral", &self.lateral)?;
        }
        if self.inh {
            struct_ser.serialize_field("inh", &self.inh)?;
        }
        if self.in_from_cl {
            struct_ser.serialize_field("inFromCl", &self.in_from_cl)?;
        }
        if !self.security_quals.is_empty() {
            struct_ser.serialize_field("securityQuals", &self.security_quals)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTblEntry {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rtekind",
            "relid",
            "relkind",
            "rellockmode",
            "tablesample",
            "perminfoindex",
            "subquery",
            "security_barrier",
            "jointype",
            "joinmergedcols",
            "joinaliasvars",
            "joinleftcols",
            "joinrightcols",
            "join_using_alias",
            "functions",
            "funcordinality",
            "tablefunc",
            "values_lists",
            "ctename",
            "ctelevelsup",
            "self_reference",
            "coltypes",
            "coltypmods",
            "colcollations",
            "enrname",
            "enrtuples",
            "alias",
            "eref",
            "lateral",
            "inh",
            "in_from_cl",
            "inFromCl",
            "security_quals",
            "securityQuals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rtekind,
            Relid,
            Relkind,
            Rellockmode,
            Tablesample,
            Perminfoindex,
            Subquery,
            SecurityBarrier,
            Jointype,
            Joinmergedcols,
            Joinaliasvars,
            Joinleftcols,
            Joinrightcols,
            JoinUsingAlias,
            Functions,
            Funcordinality,
            Tablefunc,
            ValuesLists,
            Ctename,
            Ctelevelsup,
            SelfReference,
            Coltypes,
            Coltypmods,
            Colcollations,
            Enrname,
            Enrtuples,
            Alias,
            Eref,
            Lateral,
            Inh,
            InFromCl,
            SecurityQuals,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rtekind" => Ok(GeneratedField::Rtekind),
                            "relid" => Ok(GeneratedField::Relid),
                            "relkind" => Ok(GeneratedField::Relkind),
                            "rellockmode" => Ok(GeneratedField::Rellockmode),
                            "tablesample" => Ok(GeneratedField::Tablesample),
                            "perminfoindex" => Ok(GeneratedField::Perminfoindex),
                            "subquery" => Ok(GeneratedField::Subquery),
                            "security_barrier" => Ok(GeneratedField::SecurityBarrier),
                            "jointype" => Ok(GeneratedField::Jointype),
                            "joinmergedcols" => Ok(GeneratedField::Joinmergedcols),
                            "joinaliasvars" => Ok(GeneratedField::Joinaliasvars),
                            "joinleftcols" => Ok(GeneratedField::Joinleftcols),
                            "joinrightcols" => Ok(GeneratedField::Joinrightcols),
                            "join_using_alias" => Ok(GeneratedField::JoinUsingAlias),
                            "functions" => Ok(GeneratedField::Functions),
                            "funcordinality" => Ok(GeneratedField::Funcordinality),
                            "tablefunc" => Ok(GeneratedField::Tablefunc),
                            "values_lists" => Ok(GeneratedField::ValuesLists),
                            "ctename" => Ok(GeneratedField::Ctename),
                            "ctelevelsup" => Ok(GeneratedField::Ctelevelsup),
                            "self_reference" => Ok(GeneratedField::SelfReference),
                            "coltypes" => Ok(GeneratedField::Coltypes),
                            "coltypmods" => Ok(GeneratedField::Coltypmods),
                            "colcollations" => Ok(GeneratedField::Colcollations),
                            "enrname" => Ok(GeneratedField::Enrname),
                            "enrtuples" => Ok(GeneratedField::Enrtuples),
                            "alias" => Ok(GeneratedField::Alias),
                            "eref" => Ok(GeneratedField::Eref),
                            "lateral" => Ok(GeneratedField::Lateral),
                            "inh" => Ok(GeneratedField::Inh),
                            "inFromCl" | "in_from_cl" => Ok(GeneratedField::InFromCl),
                            "securityQuals" | "security_quals" => Ok(GeneratedField::SecurityQuals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTblEntry;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTblEntry")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTblEntry, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rtekind__ = None;
                let mut relid__ = None;
                let mut relkind__ = None;
                let mut rellockmode__ = None;
                let mut tablesample__ = None;
                let mut perminfoindex__ = None;
                let mut subquery__ = None;
                let mut security_barrier__ = None;
                let mut jointype__ = None;
                let mut joinmergedcols__ = None;
                let mut joinaliasvars__ = None;
                let mut joinleftcols__ = None;
                let mut joinrightcols__ = None;
                let mut join_using_alias__ = None;
                let mut functions__ = None;
                let mut funcordinality__ = None;
                let mut tablefunc__ = None;
                let mut values_lists__ = None;
                let mut ctename__ = None;
                let mut ctelevelsup__ = None;
                let mut self_reference__ = None;
                let mut coltypes__ = None;
                let mut coltypmods__ = None;
                let mut colcollations__ = None;
                let mut enrname__ = None;
                let mut enrtuples__ = None;
                let mut alias__ = None;
                let mut eref__ = None;
                let mut lateral__ = None;
                let mut inh__ = None;
                let mut in_from_cl__ = None;
                let mut security_quals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rtekind => {
                            if rtekind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rtekind"));
                            }
                            rtekind__ = Some(map_.next_value::<RteKind>()? as i32);
                        }
                        GeneratedField::Relid => {
                            if relid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relid"));
                            }
                            relid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Relkind => {
                            if relkind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relkind"));
                            }
                            relkind__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rellockmode => {
                            if rellockmode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rellockmode"));
                            }
                            rellockmode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Tablesample => {
                            if tablesample__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablesample"));
                            }
                            tablesample__ = map_.next_value()?;
                        }
                        GeneratedField::Perminfoindex => {
                            if perminfoindex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("perminfoindex"));
                            }
                            perminfoindex__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Subquery => {
                            if subquery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subquery"));
                            }
                            subquery__ = map_.next_value()?;
                        }
                        GeneratedField::SecurityBarrier => {
                            if security_barrier__.is_some() {
                                return Err(serde::de::Error::duplicate_field("security_barrier"));
                            }
                            security_barrier__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Jointype => {
                            if jointype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jointype"));
                            }
                            jointype__ = Some(map_.next_value::<JoinType>()? as i32);
                        }
                        GeneratedField::Joinmergedcols => {
                            if joinmergedcols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("joinmergedcols"));
                            }
                            joinmergedcols__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Joinaliasvars => {
                            if joinaliasvars__.is_some() {
                                return Err(serde::de::Error::duplicate_field("joinaliasvars"));
                            }
                            joinaliasvars__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Joinleftcols => {
                            if joinleftcols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("joinleftcols"));
                            }
                            joinleftcols__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Joinrightcols => {
                            if joinrightcols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("joinrightcols"));
                            }
                            joinrightcols__ = Some(map_.next_value()?);
                        }
                        GeneratedField::JoinUsingAlias => {
                            if join_using_alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("join_using_alias"));
                            }
                            join_using_alias__ = map_.next_value()?;
                        }
                        GeneratedField::Functions => {
                            if functions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functions"));
                            }
                            functions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcordinality => {
                            if funcordinality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcordinality"));
                            }
                            funcordinality__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Tablefunc => {
                            if tablefunc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tablefunc"));
                            }
                            tablefunc__ = map_.next_value()?;
                        }
                        GeneratedField::ValuesLists => {
                            if values_lists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values_lists"));
                            }
                            values_lists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctename => {
                            if ctename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctename"));
                            }
                            ctename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ctelevelsup => {
                            if ctelevelsup__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctelevelsup"));
                            }
                            ctelevelsup__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SelfReference => {
                            if self_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("self_reference"));
                            }
                            self_reference__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Coltypes => {
                            if coltypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coltypes"));
                            }
                            coltypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Coltypmods => {
                            if coltypmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coltypmods"));
                            }
                            coltypmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Colcollations => {
                            if colcollations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colcollations"));
                            }
                            colcollations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Enrname => {
                            if enrname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enrname"));
                            }
                            enrname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Enrtuples => {
                            if enrtuples__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enrtuples"));
                            }
                            enrtuples__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                        GeneratedField::Eref => {
                            if eref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eref"));
                            }
                            eref__ = map_.next_value()?;
                        }
                        GeneratedField::Lateral => {
                            if lateral__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lateral"));
                            }
                            lateral__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Inh => {
                            if inh__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inh"));
                            }
                            inh__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InFromCl => {
                            if in_from_cl__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inFromCl"));
                            }
                            in_from_cl__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SecurityQuals => {
                            if security_quals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("securityQuals"));
                            }
                            security_quals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RangeTblEntry {
                    rtekind: rtekind__.unwrap_or_default(),
                    relid: relid__.unwrap_or_default(),
                    relkind: relkind__.unwrap_or_default(),
                    rellockmode: rellockmode__.unwrap_or_default(),
                    tablesample: tablesample__,
                    perminfoindex: perminfoindex__.unwrap_or_default(),
                    subquery: subquery__,
                    security_barrier: security_barrier__.unwrap_or_default(),
                    jointype: jointype__.unwrap_or_default(),
                    joinmergedcols: joinmergedcols__.unwrap_or_default(),
                    joinaliasvars: joinaliasvars__.unwrap_or_default(),
                    joinleftcols: joinleftcols__.unwrap_or_default(),
                    joinrightcols: joinrightcols__.unwrap_or_default(),
                    join_using_alias: join_using_alias__,
                    functions: functions__.unwrap_or_default(),
                    funcordinality: funcordinality__.unwrap_or_default(),
                    tablefunc: tablefunc__,
                    values_lists: values_lists__.unwrap_or_default(),
                    ctename: ctename__.unwrap_or_default(),
                    ctelevelsup: ctelevelsup__.unwrap_or_default(),
                    self_reference: self_reference__.unwrap_or_default(),
                    coltypes: coltypes__.unwrap_or_default(),
                    coltypmods: coltypmods__.unwrap_or_default(),
                    colcollations: colcollations__.unwrap_or_default(),
                    enrname: enrname__.unwrap_or_default(),
                    enrtuples: enrtuples__.unwrap_or_default(),
                    alias: alias__,
                    eref: eref__,
                    lateral: lateral__.unwrap_or_default(),
                    inh: inh__.unwrap_or_default(),
                    in_from_cl: in_from_cl__.unwrap_or_default(),
                    security_quals: security_quals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTblEntry", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTblFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.funcexpr.is_some() {
            len += 1;
        }
        if self.funccolcount != 0 {
            len += 1;
        }
        if !self.funccolnames.is_empty() {
            len += 1;
        }
        if !self.funccoltypes.is_empty() {
            len += 1;
        }
        if !self.funccoltypmods.is_empty() {
            len += 1;
        }
        if !self.funccolcollations.is_empty() {
            len += 1;
        }
        if !self.funcparams.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTblFunction", len)?;
        if let Some(v) = self.funcexpr.as_ref() {
            struct_ser.serialize_field("funcexpr", v)?;
        }
        if self.funccolcount != 0 {
            struct_ser.serialize_field("funccolcount", &self.funccolcount)?;
        }
        if !self.funccolnames.is_empty() {
            struct_ser.serialize_field("funccolnames", &self.funccolnames)?;
        }
        if !self.funccoltypes.is_empty() {
            struct_ser.serialize_field("funccoltypes", &self.funccoltypes)?;
        }
        if !self.funccoltypmods.is_empty() {
            struct_ser.serialize_field("funccoltypmods", &self.funccoltypmods)?;
        }
        if !self.funccolcollations.is_empty() {
            struct_ser.serialize_field("funccolcollations", &self.funccolcollations)?;
        }
        if !self.funcparams.is_empty() {
            struct_ser.serialize_field("funcparams", &self.funcparams.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTblFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "funcexpr",
            "funccolcount",
            "funccolnames",
            "funccoltypes",
            "funccoltypmods",
            "funccolcollations",
            "funcparams",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Funcexpr,
            Funccolcount,
            Funccolnames,
            Funccoltypes,
            Funccoltypmods,
            Funccolcollations,
            Funcparams,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "funcexpr" => Ok(GeneratedField::Funcexpr),
                            "funccolcount" => Ok(GeneratedField::Funccolcount),
                            "funccolnames" => Ok(GeneratedField::Funccolnames),
                            "funccoltypes" => Ok(GeneratedField::Funccoltypes),
                            "funccoltypmods" => Ok(GeneratedField::Funccoltypmods),
                            "funccolcollations" => Ok(GeneratedField::Funccolcollations),
                            "funcparams" => Ok(GeneratedField::Funcparams),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTblFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTblFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTblFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut funcexpr__ = None;
                let mut funccolcount__ = None;
                let mut funccolnames__ = None;
                let mut funccoltypes__ = None;
                let mut funccoltypmods__ = None;
                let mut funccolcollations__ = None;
                let mut funcparams__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Funcexpr => {
                            if funcexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcexpr"));
                            }
                            funcexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Funccolcount => {
                            if funccolcount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccolcount"));
                            }
                            funccolcount__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Funccolnames => {
                            if funccolnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccolnames"));
                            }
                            funccolnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funccoltypes => {
                            if funccoltypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccoltypes"));
                            }
                            funccoltypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funccoltypmods => {
                            if funccoltypmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccoltypmods"));
                            }
                            funccoltypmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funccolcollations => {
                            if funccolcollations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funccolcollations"));
                            }
                            funccolcollations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funcparams => {
                            if funcparams__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funcparams"));
                            }
                            funcparams__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(RangeTblFunction {
                    funcexpr: funcexpr__,
                    funccolcount: funccolcount__.unwrap_or_default(),
                    funccolnames: funccolnames__.unwrap_or_default(),
                    funccoltypes: funccoltypes__.unwrap_or_default(),
                    funccoltypmods: funccoltypmods__.unwrap_or_default(),
                    funccolcollations: funccolcollations__.unwrap_or_default(),
                    funcparams: funcparams__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTblFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeTblRef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rtindex != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeTblRef", len)?;
        if self.rtindex != 0 {
            struct_ser.serialize_field("rtindex", &self.rtindex)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeTblRef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rtindex",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rtindex,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rtindex" => Ok(GeneratedField::Rtindex),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeTblRef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeTblRef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeTblRef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rtindex__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rtindex => {
                            if rtindex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rtindex"));
                            }
                            rtindex__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeTblRef {
                    rtindex: rtindex__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeTblRef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeVar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.catalogname.is_empty() {
            len += 1;
        }
        if !self.schemaname.is_empty() {
            len += 1;
        }
        if !self.relname.is_empty() {
            len += 1;
        }
        if self.inh {
            len += 1;
        }
        if !self.relpersistence.is_empty() {
            len += 1;
        }
        if self.alias.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RangeVar", len)?;
        if !self.catalogname.is_empty() {
            struct_ser.serialize_field("catalogname", &self.catalogname)?;
        }
        if !self.schemaname.is_empty() {
            struct_ser.serialize_field("schemaname", &self.schemaname)?;
        }
        if !self.relname.is_empty() {
            struct_ser.serialize_field("relname", &self.relname)?;
        }
        if self.inh {
            struct_ser.serialize_field("inh", &self.inh)?;
        }
        if !self.relpersistence.is_empty() {
            struct_ser.serialize_field("relpersistence", &self.relpersistence)?;
        }
        if let Some(v) = self.alias.as_ref() {
            struct_ser.serialize_field("alias", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeVar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "catalogname",
            "schemaname",
            "relname",
            "inh",
            "relpersistence",
            "alias",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Catalogname,
            Schemaname,
            Relname,
            Inh,
            Relpersistence,
            Alias,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "catalogname" => Ok(GeneratedField::Catalogname),
                            "schemaname" => Ok(GeneratedField::Schemaname),
                            "relname" => Ok(GeneratedField::Relname),
                            "inh" => Ok(GeneratedField::Inh),
                            "relpersistence" => Ok(GeneratedField::Relpersistence),
                            "alias" => Ok(GeneratedField::Alias),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeVar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RangeVar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeVar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut catalogname__ = None;
                let mut schemaname__ = None;
                let mut relname__ = None;
                let mut inh__ = None;
                let mut relpersistence__ = None;
                let mut alias__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Catalogname => {
                            if catalogname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("catalogname"));
                            }
                            catalogname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Schemaname => {
                            if schemaname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schemaname"));
                            }
                            schemaname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relname => {
                            if relname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relname"));
                            }
                            relname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Inh => {
                            if inh__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inh"));
                            }
                            inh__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relpersistence => {
                            if relpersistence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relpersistence"));
                            }
                            relpersistence__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeVar {
                    catalogname: catalogname__.unwrap_or_default(),
                    schemaname: schemaname__.unwrap_or_default(),
                    relname: relname__.unwrap_or_default(),
                    inh: inh__.unwrap_or_default(),
                    relpersistence: relpersistence__.unwrap_or_default(),
                    alias: alias__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RangeVar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RawStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stmt.is_some() {
            len += 1;
        }
        if self.stmt_location != 0 {
            len += 1;
        }
        if self.stmt_len != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RawStmt", len)?;
        if let Some(v) = self.stmt.as_ref() {
            struct_ser.serialize_field("stmt", v)?;
        }
        if self.stmt_location != 0 {
            struct_ser.serialize_field("stmt_location", &self.stmt_location)?;
        }
        if self.stmt_len != 0 {
            struct_ser.serialize_field("stmt_len", &self.stmt_len)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RawStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stmt",
            "stmt_location",
            "stmt_len",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Stmt,
            StmtLocation,
            StmtLen,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stmt" => Ok(GeneratedField::Stmt),
                            "stmt_location" => Ok(GeneratedField::StmtLocation),
                            "stmt_len" => Ok(GeneratedField::StmtLen),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RawStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RawStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RawStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stmt__ = None;
                let mut stmt_location__ = None;
                let mut stmt_len__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Stmt => {
                            if stmt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt"));
                            }
                            stmt__ = map_.next_value()?;
                        }
                        GeneratedField::StmtLocation => {
                            if stmt_location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt_location"));
                            }
                            stmt_location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StmtLen => {
                            if stmt_len__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stmt_len"));
                            }
                            stmt_len__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RawStmt {
                    stmt: stmt__,
                    stmt_location: stmt_location__.unwrap_or_default(),
                    stmt_len: stmt_len__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RawStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReassignOwnedStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.roles.is_empty() {
            len += 1;
        }
        if self.newrole.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ReassignOwnedStmt", len)?;
        if !self.roles.is_empty() {
            struct_ser.serialize_field("roles", &self.roles)?;
        }
        if let Some(v) = self.newrole.as_ref() {
            struct_ser.serialize_field("newrole", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReassignOwnedStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "roles",
            "newrole",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Roles,
            Newrole,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "roles" => Ok(GeneratedField::Roles),
                            "newrole" => Ok(GeneratedField::Newrole),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReassignOwnedStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ReassignOwnedStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReassignOwnedStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut roles__ = None;
                let mut newrole__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Roles => {
                            if roles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roles"));
                            }
                            roles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Newrole => {
                            if newrole__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newrole"));
                            }
                            newrole__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ReassignOwnedStmt {
                    roles: roles__.unwrap_or_default(),
                    newrole: newrole__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ReassignOwnedStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RefreshMatViewStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.concurrent {
            len += 1;
        }
        if self.skip_data {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RefreshMatViewStmt", len)?;
        if self.concurrent {
            struct_ser.serialize_field("concurrent", &self.concurrent)?;
        }
        if self.skip_data {
            struct_ser.serialize_field("skipData", &self.skip_data)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RefreshMatViewStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "concurrent",
            "skip_data",
            "skipData",
            "relation",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Concurrent,
            SkipData,
            Relation,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "concurrent" => Ok(GeneratedField::Concurrent),
                            "skipData" | "skip_data" => Ok(GeneratedField::SkipData),
                            "relation" => Ok(GeneratedField::Relation),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RefreshMatViewStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RefreshMatViewStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RefreshMatViewStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut concurrent__ = None;
                let mut skip_data__ = None;
                let mut relation__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Concurrent => {
                            if concurrent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("concurrent"));
                            }
                            concurrent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SkipData => {
                            if skip_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skipData"));
                            }
                            skip_data__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RefreshMatViewStmt {
                    concurrent: concurrent__.unwrap_or_default(),
                    skip_data: skip_data__.unwrap_or_default(),
                    relation: relation__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RefreshMatViewStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReindexObjectType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "REINDEX_OBJECT_TYPE_UNDEFINED",
            Self::ReindexObjectIndex => "REINDEX_OBJECT_INDEX",
            Self::ReindexObjectTable => "REINDEX_OBJECT_TABLE",
            Self::ReindexObjectSchema => "REINDEX_OBJECT_SCHEMA",
            Self::ReindexObjectSystem => "REINDEX_OBJECT_SYSTEM",
            Self::ReindexObjectDatabase => "REINDEX_OBJECT_DATABASE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ReindexObjectType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REINDEX_OBJECT_TYPE_UNDEFINED",
            "REINDEX_OBJECT_INDEX",
            "REINDEX_OBJECT_TABLE",
            "REINDEX_OBJECT_SCHEMA",
            "REINDEX_OBJECT_SYSTEM",
            "REINDEX_OBJECT_DATABASE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReindexObjectType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REINDEX_OBJECT_TYPE_UNDEFINED" => Ok(ReindexObjectType::Undefined),
                    "REINDEX_OBJECT_INDEX" => Ok(ReindexObjectType::ReindexObjectIndex),
                    "REINDEX_OBJECT_TABLE" => Ok(ReindexObjectType::ReindexObjectTable),
                    "REINDEX_OBJECT_SCHEMA" => Ok(ReindexObjectType::ReindexObjectSchema),
                    "REINDEX_OBJECT_SYSTEM" => Ok(ReindexObjectType::ReindexObjectSystem),
                    "REINDEX_OBJECT_DATABASE" => Ok(ReindexObjectType::ReindexObjectDatabase),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ReindexStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ReindexStmt", len)?;
        if self.kind != 0 {
            let v = ReindexObjectType::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.params.is_empty() {
            struct_ser.serialize_field("params", &self.params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReindexStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "relation",
            "name",
            "params",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Relation,
            Name,
            Params,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "relation" => Ok(GeneratedField::Relation),
                            "name" => Ok(GeneratedField::Name),
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReindexStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ReindexStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReindexStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut relation__ = None;
                let mut name__ = None;
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<ReindexObjectType>()? as i32);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ReindexStmt {
                    kind: kind__.unwrap_or_default(),
                    relation: relation__,
                    name: name__.unwrap_or_default(),
                    params: params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ReindexStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RelabelType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        if self.resulttype != 0 {
            len += 1;
        }
        if self.resulttypmod != 0 {
            len += 1;
        }
        if self.resultcollid != 0 {
            len += 1;
        }
        if self.relabelformat != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RelabelType", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if self.resulttype != 0 {
            struct_ser.serialize_field("resulttype", &self.resulttype)?;
        }
        if self.resulttypmod != 0 {
            struct_ser.serialize_field("resulttypmod", &self.resulttypmod)?;
        }
        if self.resultcollid != 0 {
            struct_ser.serialize_field("resultcollid", &self.resultcollid)?;
        }
        if self.relabelformat != 0 {
            let v = CoercionForm::try_from(self.relabelformat)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.relabelformat)))?;
            struct_ser.serialize_field("relabelformat", &v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RelabelType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "arg",
            "resulttype",
            "resulttypmod",
            "resultcollid",
            "relabelformat",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Arg,
            Resulttype,
            Resulttypmod,
            Resultcollid,
            Relabelformat,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "arg" => Ok(GeneratedField::Arg),
                            "resulttype" => Ok(GeneratedField::Resulttype),
                            "resulttypmod" => Ok(GeneratedField::Resulttypmod),
                            "resultcollid" => Ok(GeneratedField::Resultcollid),
                            "relabelformat" => Ok(GeneratedField::Relabelformat),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RelabelType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RelabelType")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RelabelType, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut arg__ = None;
                let mut resulttype__ = None;
                let mut resulttypmod__ = None;
                let mut resultcollid__ = None;
                let mut relabelformat__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::Resulttype => {
                            if resulttype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttype"));
                            }
                            resulttype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resulttypmod => {
                            if resulttypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resulttypmod"));
                            }
                            resulttypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resultcollid => {
                            if resultcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultcollid"));
                            }
                            resultcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Relabelformat => {
                            if relabelformat__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relabelformat"));
                            }
                            relabelformat__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RelabelType {
                    xpr: xpr__,
                    arg: arg__,
                    resulttype: resulttype__.unwrap_or_default(),
                    resulttypmod: resulttypmod__.unwrap_or_default(),
                    resultcollid: resultcollid__.unwrap_or_default(),
                    relabelformat: relabelformat__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RelabelType", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RenameStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rename_type != 0 {
            len += 1;
        }
        if self.relation_type != 0 {
            len += 1;
        }
        if self.relation.is_some() {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if !self.subname.is_empty() {
            len += 1;
        }
        if !self.newname.is_empty() {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        if self.missing_ok {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RenameStmt", len)?;
        if self.rename_type != 0 {
            let v = ObjectType::try_from(self.rename_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.rename_type)))?;
            struct_ser.serialize_field("renameType", &v)?;
        }
        if self.relation_type != 0 {
            let v = ObjectType::try_from(self.relation_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.relation_type)))?;
            struct_ser.serialize_field("relationType", &v)?;
        }
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if !self.subname.is_empty() {
            struct_ser.serialize_field("subname", &self.subname)?;
        }
        if !self.newname.is_empty() {
            struct_ser.serialize_field("newname", &self.newname)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        if self.missing_ok {
            struct_ser.serialize_field("missing_ok", &self.missing_ok)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RenameStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rename_type",
            "renameType",
            "relation_type",
            "relationType",
            "relation",
            "object",
            "subname",
            "newname",
            "behavior",
            "missing_ok",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RenameType,
            RelationType,
            Relation,
            Object,
            Subname,
            Newname,
            Behavior,
            MissingOk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "renameType" | "rename_type" => Ok(GeneratedField::RenameType),
                            "relationType" | "relation_type" => Ok(GeneratedField::RelationType),
                            "relation" => Ok(GeneratedField::Relation),
                            "object" => Ok(GeneratedField::Object),
                            "subname" => Ok(GeneratedField::Subname),
                            "newname" => Ok(GeneratedField::Newname),
                            "behavior" => Ok(GeneratedField::Behavior),
                            "missing_ok" => Ok(GeneratedField::MissingOk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RenameStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RenameStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RenameStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rename_type__ = None;
                let mut relation_type__ = None;
                let mut relation__ = None;
                let mut object__ = None;
                let mut subname__ = None;
                let mut newname__ = None;
                let mut behavior__ = None;
                let mut missing_ok__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RenameType => {
                            if rename_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("renameType"));
                            }
                            rename_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::RelationType => {
                            if relation_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relationType"));
                            }
                            relation_type__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Subname => {
                            if subname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subname"));
                            }
                            subname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Newname => {
                            if newname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newname"));
                            }
                            newname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                        GeneratedField::MissingOk => {
                            if missing_ok__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missing_ok"));
                            }
                            missing_ok__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RenameStmt {
                    rename_type: rename_type__.unwrap_or_default(),
                    relation_type: relation_type__.unwrap_or_default(),
                    relation: relation__,
                    object: object__,
                    subname: subname__.unwrap_or_default(),
                    newname: newname__.unwrap_or_default(),
                    behavior: behavior__.unwrap_or_default(),
                    missing_ok: missing_ok__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RenameStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicaIdentityStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.identity_type.is_empty() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ReplicaIdentityStmt", len)?;
        if !self.identity_type.is_empty() {
            struct_ser.serialize_field("identity_type", &self.identity_type)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicaIdentityStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "identity_type",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IdentityType,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "identity_type" => Ok(GeneratedField::IdentityType),
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicaIdentityStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ReplicaIdentityStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReplicaIdentityStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut identity_type__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IdentityType => {
                            if identity_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("identity_type"));
                            }
                            identity_type__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ReplicaIdentityStmt {
                    identity_type: identity_type__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ReplicaIdentityStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.indirection.is_empty() {
            len += 1;
        }
        if self.val.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ResTarget", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.indirection.is_empty() {
            struct_ser.serialize_field("indirection", &self.indirection)?;
        }
        if let Some(v) = self.val.as_ref() {
            struct_ser.serialize_field("val", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "indirection",
            "val",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Indirection,
            Val,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "indirection" => Ok(GeneratedField::Indirection),
                            "val" => Ok(GeneratedField::Val),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ResTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ResTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut indirection__ = None;
                let mut val__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Indirection => {
                            if indirection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indirection"));
                            }
                            indirection__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Val => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("val"));
                            }
                            val__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ResTarget {
                    name: name__.unwrap_or_default(),
                    indirection: indirection__.unwrap_or_default(),
                    val: val__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ResTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReturnStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.returnval.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ReturnStmt", len)?;
        if let Some(v) = self.returnval.as_ref() {
            struct_ser.serialize_field("returnval", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReturnStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "returnval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Returnval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "returnval" => Ok(GeneratedField::Returnval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReturnStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ReturnStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReturnStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut returnval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Returnval => {
                            if returnval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returnval"));
                            }
                            returnval__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ReturnStmt {
                    returnval: returnval__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ReturnStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RoleSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.roletype != 0 {
            len += 1;
        }
        if !self.rolename.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RoleSpec", len)?;
        if self.roletype != 0 {
            let v = RoleSpecType::try_from(self.roletype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.roletype)))?;
            struct_ser.serialize_field("roletype", &v)?;
        }
        if !self.rolename.is_empty() {
            struct_ser.serialize_field("rolename", &self.rolename)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RoleSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "roletype",
            "rolename",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Roletype,
            Rolename,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "roletype" => Ok(GeneratedField::Roletype),
                            "rolename" => Ok(GeneratedField::Rolename),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RoleSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RoleSpec")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RoleSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut roletype__ = None;
                let mut rolename__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Roletype => {
                            if roletype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roletype"));
                            }
                            roletype__ = Some(map_.next_value::<RoleSpecType>()? as i32);
                        }
                        GeneratedField::Rolename => {
                            if rolename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rolename"));
                            }
                            rolename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RoleSpec {
                    roletype: roletype__.unwrap_or_default(),
                    rolename: rolename__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RoleSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RoleSpecType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ROLE_SPEC_TYPE_UNDEFINED",
            Self::RolespecCstring => "ROLESPEC_CSTRING",
            Self::RolespecCurrentRole => "ROLESPEC_CURRENT_ROLE",
            Self::RolespecCurrentUser => "ROLESPEC_CURRENT_USER",
            Self::RolespecSessionUser => "ROLESPEC_SESSION_USER",
            Self::RolespecPublic => "ROLESPEC_PUBLIC",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for RoleSpecType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ROLE_SPEC_TYPE_UNDEFINED",
            "ROLESPEC_CSTRING",
            "ROLESPEC_CURRENT_ROLE",
            "ROLESPEC_CURRENT_USER",
            "ROLESPEC_SESSION_USER",
            "ROLESPEC_PUBLIC",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RoleSpecType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ROLE_SPEC_TYPE_UNDEFINED" => Ok(RoleSpecType::Undefined),
                    "ROLESPEC_CSTRING" => Ok(RoleSpecType::RolespecCstring),
                    "ROLESPEC_CURRENT_ROLE" => Ok(RoleSpecType::RolespecCurrentRole),
                    "ROLESPEC_CURRENT_USER" => Ok(RoleSpecType::RolespecCurrentUser),
                    "ROLESPEC_SESSION_USER" => Ok(RoleSpecType::RolespecSessionUser),
                    "ROLESPEC_PUBLIC" => Ok(RoleSpecType::RolespecPublic),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RoleStmtType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ROLE_STMT_TYPE_UNDEFINED",
            Self::RolestmtRole => "ROLESTMT_ROLE",
            Self::RolestmtUser => "ROLESTMT_USER",
            Self::RolestmtGroup => "ROLESTMT_GROUP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for RoleStmtType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ROLE_STMT_TYPE_UNDEFINED",
            "ROLESTMT_ROLE",
            "ROLESTMT_USER",
            "ROLESTMT_GROUP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RoleStmtType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ROLE_STMT_TYPE_UNDEFINED" => Ok(RoleStmtType::Undefined),
                    "ROLESTMT_ROLE" => Ok(RoleStmtType::RolestmtRole),
                    "ROLESTMT_USER" => Ok(RoleStmtType::RolestmtUser),
                    "ROLESTMT_GROUP" => Ok(RoleStmtType::RolestmtGroup),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RowCompareExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.rctype != 0 {
            len += 1;
        }
        if !self.opnos.is_empty() {
            len += 1;
        }
        if !self.opfamilies.is_empty() {
            len += 1;
        }
        if !self.inputcollids.is_empty() {
            len += 1;
        }
        if !self.largs.is_empty() {
            len += 1;
        }
        if !self.rargs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RowCompareExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.rctype != 0 {
            let v = RowCompareType::try_from(self.rctype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.rctype)))?;
            struct_ser.serialize_field("rctype", &v)?;
        }
        if !self.opnos.is_empty() {
            struct_ser.serialize_field("opnos", &self.opnos)?;
        }
        if !self.opfamilies.is_empty() {
            struct_ser.serialize_field("opfamilies", &self.opfamilies)?;
        }
        if !self.inputcollids.is_empty() {
            struct_ser.serialize_field("inputcollids", &self.inputcollids)?;
        }
        if !self.largs.is_empty() {
            struct_ser.serialize_field("largs", &self.largs)?;
        }
        if !self.rargs.is_empty() {
            struct_ser.serialize_field("rargs", &self.rargs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RowCompareExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "rctype",
            "opnos",
            "opfamilies",
            "inputcollids",
            "largs",
            "rargs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Rctype,
            Opnos,
            Opfamilies,
            Inputcollids,
            Largs,
            Rargs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "rctype" => Ok(GeneratedField::Rctype),
                            "opnos" => Ok(GeneratedField::Opnos),
                            "opfamilies" => Ok(GeneratedField::Opfamilies),
                            "inputcollids" => Ok(GeneratedField::Inputcollids),
                            "largs" => Ok(GeneratedField::Largs),
                            "rargs" => Ok(GeneratedField::Rargs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RowCompareExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RowCompareExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RowCompareExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut rctype__ = None;
                let mut opnos__ = None;
                let mut opfamilies__ = None;
                let mut inputcollids__ = None;
                let mut largs__ = None;
                let mut rargs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Rctype => {
                            if rctype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rctype"));
                            }
                            rctype__ = Some(map_.next_value::<RowCompareType>()? as i32);
                        }
                        GeneratedField::Opnos => {
                            if opnos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opnos"));
                            }
                            opnos__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Opfamilies => {
                            if opfamilies__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opfamilies"));
                            }
                            opfamilies__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Inputcollids => {
                            if inputcollids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollids"));
                            }
                            inputcollids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Largs => {
                            if largs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("largs"));
                            }
                            largs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rargs => {
                            if rargs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rargs"));
                            }
                            rargs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RowCompareExpr {
                    xpr: xpr__,
                    rctype: rctype__.unwrap_or_default(),
                    opnos: opnos__.unwrap_or_default(),
                    opfamilies: opfamilies__.unwrap_or_default(),
                    inputcollids: inputcollids__.unwrap_or_default(),
                    largs: largs__.unwrap_or_default(),
                    rargs: rargs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RowCompareExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RowCompareType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "ROW_COMPARE_TYPE_UNDEFINED",
            Self::RowcompareLt => "ROWCOMPARE_LT",
            Self::RowcompareLe => "ROWCOMPARE_LE",
            Self::RowcompareEq => "ROWCOMPARE_EQ",
            Self::RowcompareGe => "ROWCOMPARE_GE",
            Self::RowcompareGt => "ROWCOMPARE_GT",
            Self::RowcompareNe => "ROWCOMPARE_NE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for RowCompareType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ROW_COMPARE_TYPE_UNDEFINED",
            "ROWCOMPARE_LT",
            "ROWCOMPARE_LE",
            "ROWCOMPARE_EQ",
            "ROWCOMPARE_GE",
            "ROWCOMPARE_GT",
            "ROWCOMPARE_NE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RowCompareType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ROW_COMPARE_TYPE_UNDEFINED" => Ok(RowCompareType::Undefined),
                    "ROWCOMPARE_LT" => Ok(RowCompareType::RowcompareLt),
                    "ROWCOMPARE_LE" => Ok(RowCompareType::RowcompareLe),
                    "ROWCOMPARE_EQ" => Ok(RowCompareType::RowcompareEq),
                    "ROWCOMPARE_GE" => Ok(RowCompareType::RowcompareGe),
                    "ROWCOMPARE_GT" => Ok(RowCompareType::RowcompareGt),
                    "ROWCOMPARE_NE" => Ok(RowCompareType::RowcompareNe),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RowExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.row_typeid != 0 {
            len += 1;
        }
        if self.row_format != 0 {
            len += 1;
        }
        if !self.colnames.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RowExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.row_typeid != 0 {
            struct_ser.serialize_field("row_typeid", &self.row_typeid)?;
        }
        if self.row_format != 0 {
            let v = CoercionForm::try_from(self.row_format)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.row_format)))?;
            struct_ser.serialize_field("row_format", &v)?;
        }
        if !self.colnames.is_empty() {
            struct_ser.serialize_field("colnames", &self.colnames)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RowExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "args",
            "row_typeid",
            "row_format",
            "colnames",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Args,
            RowTypeid,
            RowFormat,
            Colnames,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "args" => Ok(GeneratedField::Args),
                            "row_typeid" => Ok(GeneratedField::RowTypeid),
                            "row_format" => Ok(GeneratedField::RowFormat),
                            "colnames" => Ok(GeneratedField::Colnames),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RowExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RowExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RowExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut args__ = None;
                let mut row_typeid__ = None;
                let mut row_format__ = None;
                let mut colnames__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RowTypeid => {
                            if row_typeid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("row_typeid"));
                            }
                            row_typeid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::RowFormat => {
                            if row_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("row_format"));
                            }
                            row_format__ = Some(map_.next_value::<CoercionForm>()? as i32);
                        }
                        GeneratedField::Colnames => {
                            if colnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colnames"));
                            }
                            colnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RowExpr {
                    xpr: xpr__,
                    args: args__.unwrap_or_default(),
                    row_typeid: row_typeid__.unwrap_or_default(),
                    row_format: row_format__.unwrap_or_default(),
                    colnames: colnames__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RowExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RowMarkClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rti != 0 {
            len += 1;
        }
        if self.strength != 0 {
            len += 1;
        }
        if self.wait_policy != 0 {
            len += 1;
        }
        if self.pushed_down {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RowMarkClause", len)?;
        if self.rti != 0 {
            struct_ser.serialize_field("rti", &self.rti)?;
        }
        if self.strength != 0 {
            let v = LockClauseStrength::try_from(self.strength)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.strength)))?;
            struct_ser.serialize_field("strength", &v)?;
        }
        if self.wait_policy != 0 {
            let v = LockWaitPolicy::try_from(self.wait_policy)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.wait_policy)))?;
            struct_ser.serialize_field("waitPolicy", &v)?;
        }
        if self.pushed_down {
            struct_ser.serialize_field("pushedDown", &self.pushed_down)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RowMarkClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rti",
            "strength",
            "wait_policy",
            "waitPolicy",
            "pushed_down",
            "pushedDown",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rti,
            Strength,
            WaitPolicy,
            PushedDown,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rti" => Ok(GeneratedField::Rti),
                            "strength" => Ok(GeneratedField::Strength),
                            "waitPolicy" | "wait_policy" => Ok(GeneratedField::WaitPolicy),
                            "pushedDown" | "pushed_down" => Ok(GeneratedField::PushedDown),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RowMarkClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RowMarkClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RowMarkClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rti__ = None;
                let mut strength__ = None;
                let mut wait_policy__ = None;
                let mut pushed_down__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rti => {
                            if rti__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rti"));
                            }
                            rti__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Strength => {
                            if strength__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strength"));
                            }
                            strength__ = Some(map_.next_value::<LockClauseStrength>()? as i32);
                        }
                        GeneratedField::WaitPolicy => {
                            if wait_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("waitPolicy"));
                            }
                            wait_policy__ = Some(map_.next_value::<LockWaitPolicy>()? as i32);
                        }
                        GeneratedField::PushedDown => {
                            if pushed_down__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pushedDown"));
                            }
                            pushed_down__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RowMarkClause {
                    rti: rti__.unwrap_or_default(),
                    strength: strength__.unwrap_or_default(),
                    wait_policy: wait_policy__.unwrap_or_default(),
                    pushed_down: pushed_down__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RowMarkClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RuleStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.rulename.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if self.event != 0 {
            len += 1;
        }
        if self.instead {
            len += 1;
        }
        if !self.actions.is_empty() {
            len += 1;
        }
        if self.replace {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.RuleStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.rulename.is_empty() {
            struct_ser.serialize_field("rulename", &self.rulename)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if self.event != 0 {
            let v = CmdType::try_from(self.event)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.event)))?;
            struct_ser.serialize_field("event", &v)?;
        }
        if self.instead {
            struct_ser.serialize_field("instead", &self.instead)?;
        }
        if !self.actions.is_empty() {
            struct_ser.serialize_field("actions", &self.actions)?;
        }
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RuleStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "rulename",
            "where_clause",
            "whereClause",
            "event",
            "instead",
            "actions",
            "replace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Rulename,
            WhereClause,
            Event,
            Instead,
            Actions,
            Replace,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "rulename" => Ok(GeneratedField::Rulename),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "event" => Ok(GeneratedField::Event),
                            "instead" => Ok(GeneratedField::Instead),
                            "actions" => Ok(GeneratedField::Actions),
                            "replace" => Ok(GeneratedField::Replace),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RuleStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.RuleStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RuleStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut rulename__ = None;
                let mut where_clause__ = None;
                let mut event__ = None;
                let mut instead__ = None;
                let mut actions__ = None;
                let mut replace__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Rulename => {
                            if rulename__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rulename"));
                            }
                            rulename__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Event => {
                            if event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("event"));
                            }
                            event__ = Some(map_.next_value::<CmdType>()? as i32);
                        }
                        GeneratedField::Instead => {
                            if instead__.is_some() {
                                return Err(serde::de::Error::duplicate_field("instead"));
                            }
                            instead__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Actions => {
                            if actions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("actions"));
                            }
                            actions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RuleStmt {
                    relation: relation__,
                    rulename: rulename__.unwrap_or_default(),
                    where_clause: where_clause__,
                    event: event__.unwrap_or_default(),
                    instead: instead__.unwrap_or_default(),
                    actions: actions__.unwrap_or_default(),
                    replace: replace__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.RuleStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SqlValueFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.typmod != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SQLValueFunction", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.op != 0 {
            let v = SqlValueFunctionOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if self.r#type != 0 {
            struct_ser.serialize_field("type", &self.r#type)?;
        }
        if self.typmod != 0 {
            struct_ser.serialize_field("typmod", &self.typmod)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SqlValueFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "op",
            "type",
            "typmod",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Op,
            Type,
            Typmod,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "op" => Ok(GeneratedField::Op),
                            "type" => Ok(GeneratedField::Type),
                            "typmod" => Ok(GeneratedField::Typmod),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SqlValueFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SQLValueFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SqlValueFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut op__ = None;
                let mut r#type__ = None;
                let mut typmod__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<SqlValueFunctionOp>()? as i32);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Typmod => {
                            if typmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typmod"));
                            }
                            typmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SqlValueFunction {
                    xpr: xpr__,
                    op: op__.unwrap_or_default(),
                    r#type: r#type__.unwrap_or_default(),
                    typmod: typmod__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SQLValueFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SqlValueFunctionOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SqlvalueFunctionOpUndefined => "SQLVALUE_FUNCTION_OP_UNDEFINED",
            Self::SvfopCurrentDate => "SVFOP_CURRENT_DATE",
            Self::SvfopCurrentTime => "SVFOP_CURRENT_TIME",
            Self::SvfopCurrentTimeN => "SVFOP_CURRENT_TIME_N",
            Self::SvfopCurrentTimestamp => "SVFOP_CURRENT_TIMESTAMP",
            Self::SvfopCurrentTimestampN => "SVFOP_CURRENT_TIMESTAMP_N",
            Self::SvfopLocaltime => "SVFOP_LOCALTIME",
            Self::SvfopLocaltimeN => "SVFOP_LOCALTIME_N",
            Self::SvfopLocaltimestamp => "SVFOP_LOCALTIMESTAMP",
            Self::SvfopLocaltimestampN => "SVFOP_LOCALTIMESTAMP_N",
            Self::SvfopCurrentRole => "SVFOP_CURRENT_ROLE",
            Self::SvfopCurrentUser => "SVFOP_CURRENT_USER",
            Self::SvfopUser => "SVFOP_USER",
            Self::SvfopSessionUser => "SVFOP_SESSION_USER",
            Self::SvfopCurrentCatalog => "SVFOP_CURRENT_CATALOG",
            Self::SvfopCurrentSchema => "SVFOP_CURRENT_SCHEMA",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SqlValueFunctionOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SQLVALUE_FUNCTION_OP_UNDEFINED",
            "SVFOP_CURRENT_DATE",
            "SVFOP_CURRENT_TIME",
            "SVFOP_CURRENT_TIME_N",
            "SVFOP_CURRENT_TIMESTAMP",
            "SVFOP_CURRENT_TIMESTAMP_N",
            "SVFOP_LOCALTIME",
            "SVFOP_LOCALTIME_N",
            "SVFOP_LOCALTIMESTAMP",
            "SVFOP_LOCALTIMESTAMP_N",
            "SVFOP_CURRENT_ROLE",
            "SVFOP_CURRENT_USER",
            "SVFOP_USER",
            "SVFOP_SESSION_USER",
            "SVFOP_CURRENT_CATALOG",
            "SVFOP_CURRENT_SCHEMA",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SqlValueFunctionOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SQLVALUE_FUNCTION_OP_UNDEFINED" => Ok(SqlValueFunctionOp::SqlvalueFunctionOpUndefined),
                    "SVFOP_CURRENT_DATE" => Ok(SqlValueFunctionOp::SvfopCurrentDate),
                    "SVFOP_CURRENT_TIME" => Ok(SqlValueFunctionOp::SvfopCurrentTime),
                    "SVFOP_CURRENT_TIME_N" => Ok(SqlValueFunctionOp::SvfopCurrentTimeN),
                    "SVFOP_CURRENT_TIMESTAMP" => Ok(SqlValueFunctionOp::SvfopCurrentTimestamp),
                    "SVFOP_CURRENT_TIMESTAMP_N" => Ok(SqlValueFunctionOp::SvfopCurrentTimestampN),
                    "SVFOP_LOCALTIME" => Ok(SqlValueFunctionOp::SvfopLocaltime),
                    "SVFOP_LOCALTIME_N" => Ok(SqlValueFunctionOp::SvfopLocaltimeN),
                    "SVFOP_LOCALTIMESTAMP" => Ok(SqlValueFunctionOp::SvfopLocaltimestamp),
                    "SVFOP_LOCALTIMESTAMP_N" => Ok(SqlValueFunctionOp::SvfopLocaltimestampN),
                    "SVFOP_CURRENT_ROLE" => Ok(SqlValueFunctionOp::SvfopCurrentRole),
                    "SVFOP_CURRENT_USER" => Ok(SqlValueFunctionOp::SvfopCurrentUser),
                    "SVFOP_USER" => Ok(SqlValueFunctionOp::SvfopUser),
                    "SVFOP_SESSION_USER" => Ok(SqlValueFunctionOp::SvfopSessionUser),
                    "SVFOP_CURRENT_CATALOG" => Ok(SqlValueFunctionOp::SvfopCurrentCatalog),
                    "SVFOP_CURRENT_SCHEMA" => Ok(SqlValueFunctionOp::SvfopCurrentSchema),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ScalarArrayOpExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.opno != 0 {
            len += 1;
        }
        if self.use_or {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ScalarArrayOpExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.opno != 0 {
            struct_ser.serialize_field("opno", &self.opno)?;
        }
        if self.use_or {
            struct_ser.serialize_field("useOr", &self.use_or)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScalarArrayOpExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "opno",
            "use_or",
            "useOr",
            "inputcollid",
            "args",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Opno,
            UseOr,
            Inputcollid,
            Args,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "opno" => Ok(GeneratedField::Opno),
                            "useOr" | "use_or" => Ok(GeneratedField::UseOr),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScalarArrayOpExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ScalarArrayOpExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScalarArrayOpExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut opno__ = None;
                let mut use_or__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Opno => {
                            if opno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opno"));
                            }
                            opno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::UseOr => {
                            if use_or__.is_some() {
                                return Err(serde::de::Error::duplicate_field("useOr"));
                            }
                            use_or__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ScalarArrayOpExpr {
                    xpr: xpr__,
                    opno: opno__.unwrap_or_default(),
                    use_or: use_or__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ScalarArrayOpExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScanResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version != 0 {
            len += 1;
        }
        if !self.tokens.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ScanResult", len)?;
        if self.version != 0 {
            struct_ser.serialize_field("version", &self.version)?;
        }
        if !self.tokens.is_empty() {
            struct_ser.serialize_field("tokens", &self.tokens)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScanResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "tokens",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            Tokens,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "tokens" => Ok(GeneratedField::Tokens),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScanResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ScanResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScanResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut tokens__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Tokens => {
                            if tokens__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tokens"));
                            }
                            tokens__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ScanResult {
                    version: version__.unwrap_or_default(),
                    tokens: tokens__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ScanResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScanToken {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.start != 0 {
            len += 1;
        }
        if self.end != 0 {
            len += 1;
        }
        if self.token != 0 {
            len += 1;
        }
        if self.keyword_kind != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ScanToken", len)?;
        if self.start != 0 {
            struct_ser.serialize_field("start", &self.start)?;
        }
        if self.end != 0 {
            struct_ser.serialize_field("end", &self.end)?;
        }
        if self.token != 0 {
            let v = Token::try_from(self.token)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.token)))?;
            struct_ser.serialize_field("token", &v)?;
        }
        if self.keyword_kind != 0 {
            let v = KeywordKind::try_from(self.keyword_kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.keyword_kind)))?;
            struct_ser.serialize_field("keywordKind", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScanToken {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "start",
            "end",
            "token",
            "keyword_kind",
            "keywordKind",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Start,
            End,
            Token,
            KeywordKind,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "start" => Ok(GeneratedField::Start),
                            "end" => Ok(GeneratedField::End),
                            "token" => Ok(GeneratedField::Token),
                            "keywordKind" | "keyword_kind" => Ok(GeneratedField::KeywordKind),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScanToken;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ScanToken")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScanToken, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start__ = None;
                let mut end__ = None;
                let mut token__ = None;
                let mut keyword_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Start => {
                            if start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("start"));
                            }
                            start__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::End => {
                            if end__.is_some() {
                                return Err(serde::de::Error::duplicate_field("end"));
                            }
                            end__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("token"));
                            }
                            token__ = Some(map_.next_value::<Token>()? as i32);
                        }
                        GeneratedField::KeywordKind => {
                            if keyword_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keywordKind"));
                            }
                            keyword_kind__ = Some(map_.next_value::<KeywordKind>()? as i32);
                        }
                    }
                }
                Ok(ScanToken {
                    start: start__.unwrap_or_default(),
                    end: end__.unwrap_or_default(),
                    token: token__.unwrap_or_default(),
                    keyword_kind: keyword_kind__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ScanToken", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecLabelStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.objtype != 0 {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        if !self.provider.is_empty() {
            len += 1;
        }
        if !self.label.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SecLabelStmt", len)?;
        if self.objtype != 0 {
            let v = ObjectType::try_from(self.objtype)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.objtype)))?;
            struct_ser.serialize_field("objtype", &v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        if !self.provider.is_empty() {
            struct_ser.serialize_field("provider", &self.provider)?;
        }
        if !self.label.is_empty() {
            struct_ser.serialize_field("label", &self.label)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecLabelStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objtype",
            "object",
            "provider",
            "label",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objtype,
            Object,
            Provider,
            Label,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objtype" => Ok(GeneratedField::Objtype),
                            "object" => Ok(GeneratedField::Object),
                            "provider" => Ok(GeneratedField::Provider),
                            "label" => Ok(GeneratedField::Label),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecLabelStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SecLabelStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SecLabelStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objtype__ = None;
                let mut object__ = None;
                let mut provider__ = None;
                let mut label__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objtype => {
                            if objtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objtype"));
                            }
                            objtype__ = Some(map_.next_value::<ObjectType>()? as i32);
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::Provider => {
                            if provider__.is_some() {
                                return Err(serde::de::Error::duplicate_field("provider"));
                            }
                            provider__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SecLabelStmt {
                    objtype: objtype__.unwrap_or_default(),
                    object: object__,
                    provider: provider__.unwrap_or_default(),
                    label: label__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SecLabelStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SelectStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.distinct_clause.is_empty() {
            len += 1;
        }
        if self.into_clause.is_some() {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if !self.from_clause.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.group_clause.is_empty() {
            len += 1;
        }
        if self.group_distinct {
            len += 1;
        }
        if self.having_clause.is_some() {
            len += 1;
        }
        if !self.window_clause.is_empty() {
            len += 1;
        }
        if !self.values_lists.is_empty() {
            len += 1;
        }
        if !self.sort_clause.is_empty() {
            len += 1;
        }
        if self.limit_offset.is_some() {
            len += 1;
        }
        if self.limit_count.is_some() {
            len += 1;
        }
        if self.limit_option != 0 {
            len += 1;
        }
        if !self.locking_clause.is_empty() {
            len += 1;
        }
        if self.with_clause.is_some() {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if self.all {
            len += 1;
        }
        if self.larg.is_some() {
            len += 1;
        }
        if self.rarg.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SelectStmt", len)?;
        if !self.distinct_clause.is_empty() {
            struct_ser.serialize_field("distinctClause", &self.distinct_clause)?;
        }
        if let Some(v) = self.into_clause.as_ref() {
            struct_ser.serialize_field("intoClause", v)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if !self.from_clause.is_empty() {
            struct_ser.serialize_field("fromClause", &self.from_clause)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.group_clause.is_empty() {
            struct_ser.serialize_field("groupClause", &self.group_clause)?;
        }
        if self.group_distinct {
            struct_ser.serialize_field("groupDistinct", &self.group_distinct)?;
        }
        if let Some(v) = self.having_clause.as_ref() {
            struct_ser.serialize_field("havingClause", v)?;
        }
        if !self.window_clause.is_empty() {
            struct_ser.serialize_field("windowClause", &self.window_clause)?;
        }
        if !self.values_lists.is_empty() {
            struct_ser.serialize_field("valuesLists", &self.values_lists)?;
        }
        if !self.sort_clause.is_empty() {
            struct_ser.serialize_field("sortClause", &self.sort_clause)?;
        }
        if let Some(v) = self.limit_offset.as_ref() {
            struct_ser.serialize_field("limitOffset", v)?;
        }
        if let Some(v) = self.limit_count.as_ref() {
            struct_ser.serialize_field("limitCount", v)?;
        }
        if self.limit_option != 0 {
            let v = LimitOption::try_from(self.limit_option)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.limit_option)))?;
            struct_ser.serialize_field("limitOption", &v)?;
        }
        if !self.locking_clause.is_empty() {
            struct_ser.serialize_field("lockingClause", &self.locking_clause)?;
        }
        if let Some(v) = self.with_clause.as_ref() {
            struct_ser.serialize_field("withClause", v)?;
        }
        if self.op != 0 {
            let v = SetOperation::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if self.all {
            struct_ser.serialize_field("all", &self.all)?;
        }
        if let Some(v) = self.larg.as_ref() {
            struct_ser.serialize_field("larg", v)?;
        }
        if let Some(v) = self.rarg.as_ref() {
            struct_ser.serialize_field("rarg", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SelectStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "distinct_clause",
            "distinctClause",
            "into_clause",
            "intoClause",
            "target_list",
            "targetList",
            "from_clause",
            "fromClause",
            "where_clause",
            "whereClause",
            "group_clause",
            "groupClause",
            "group_distinct",
            "groupDistinct",
            "having_clause",
            "havingClause",
            "window_clause",
            "windowClause",
            "values_lists",
            "valuesLists",
            "sort_clause",
            "sortClause",
            "limit_offset",
            "limitOffset",
            "limit_count",
            "limitCount",
            "limit_option",
            "limitOption",
            "locking_clause",
            "lockingClause",
            "with_clause",
            "withClause",
            "op",
            "all",
            "larg",
            "rarg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DistinctClause,
            IntoClause,
            TargetList,
            FromClause,
            WhereClause,
            GroupClause,
            GroupDistinct,
            HavingClause,
            WindowClause,
            ValuesLists,
            SortClause,
            LimitOffset,
            LimitCount,
            LimitOption,
            LockingClause,
            WithClause,
            Op,
            All,
            Larg,
            Rarg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "distinctClause" | "distinct_clause" => Ok(GeneratedField::DistinctClause),
                            "intoClause" | "into_clause" => Ok(GeneratedField::IntoClause),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "fromClause" | "from_clause" => Ok(GeneratedField::FromClause),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "groupClause" | "group_clause" => Ok(GeneratedField::GroupClause),
                            "groupDistinct" | "group_distinct" => Ok(GeneratedField::GroupDistinct),
                            "havingClause" | "having_clause" => Ok(GeneratedField::HavingClause),
                            "windowClause" | "window_clause" => Ok(GeneratedField::WindowClause),
                            "valuesLists" | "values_lists" => Ok(GeneratedField::ValuesLists),
                            "sortClause" | "sort_clause" => Ok(GeneratedField::SortClause),
                            "limitOffset" | "limit_offset" => Ok(GeneratedField::LimitOffset),
                            "limitCount" | "limit_count" => Ok(GeneratedField::LimitCount),
                            "limitOption" | "limit_option" => Ok(GeneratedField::LimitOption),
                            "lockingClause" | "locking_clause" => Ok(GeneratedField::LockingClause),
                            "withClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            "op" => Ok(GeneratedField::Op),
                            "all" => Ok(GeneratedField::All),
                            "larg" => Ok(GeneratedField::Larg),
                            "rarg" => Ok(GeneratedField::Rarg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SelectStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SelectStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SelectStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut distinct_clause__ = None;
                let mut into_clause__ = None;
                let mut target_list__ = None;
                let mut from_clause__ = None;
                let mut where_clause__ = None;
                let mut group_clause__ = None;
                let mut group_distinct__ = None;
                let mut having_clause__ = None;
                let mut window_clause__ = None;
                let mut values_lists__ = None;
                let mut sort_clause__ = None;
                let mut limit_offset__ = None;
                let mut limit_count__ = None;
                let mut limit_option__ = None;
                let mut locking_clause__ = None;
                let mut with_clause__ = None;
                let mut op__ = None;
                let mut all__ = None;
                let mut larg__ = None;
                let mut rarg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DistinctClause => {
                            if distinct_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distinctClause"));
                            }
                            distinct_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IntoClause => {
                            if into_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intoClause"));
                            }
                            into_clause__ = map_.next_value()?;
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FromClause => {
                            if from_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fromClause"));
                            }
                            from_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::GroupClause => {
                            if group_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupClause"));
                            }
                            group_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupDistinct => {
                            if group_distinct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupDistinct"));
                            }
                            group_distinct__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HavingClause => {
                            if having_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("havingClause"));
                            }
                            having_clause__ = map_.next_value()?;
                        }
                        GeneratedField::WindowClause => {
                            if window_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowClause"));
                            }
                            window_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ValuesLists => {
                            if values_lists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("valuesLists"));
                            }
                            values_lists__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SortClause => {
                            if sort_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sortClause"));
                            }
                            sort_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitOffset => {
                            if limit_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOffset"));
                            }
                            limit_offset__ = map_.next_value()?;
                        }
                        GeneratedField::LimitCount => {
                            if limit_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitCount"));
                            }
                            limit_count__ = map_.next_value()?;
                        }
                        GeneratedField::LimitOption => {
                            if limit_option__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOption"));
                            }
                            limit_option__ = Some(map_.next_value::<LimitOption>()? as i32);
                        }
                        GeneratedField::LockingClause => {
                            if locking_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lockingClause"));
                            }
                            locking_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithClause => {
                            if with_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withClause"));
                            }
                            with_clause__ = map_.next_value()?;
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<SetOperation>()? as i32);
                        }
                        GeneratedField::All => {
                            if all__.is_some() {
                                return Err(serde::de::Error::duplicate_field("all"));
                            }
                            all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Larg => {
                            if larg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("larg"));
                            }
                            larg__ = map_.next_value()?;
                        }
                        GeneratedField::Rarg => {
                            if rarg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rarg"));
                            }
                            rarg__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SelectStmt {
                    distinct_clause: distinct_clause__.unwrap_or_default(),
                    into_clause: into_clause__,
                    target_list: target_list__.unwrap_or_default(),
                    from_clause: from_clause__.unwrap_or_default(),
                    where_clause: where_clause__,
                    group_clause: group_clause__.unwrap_or_default(),
                    group_distinct: group_distinct__.unwrap_or_default(),
                    having_clause: having_clause__,
                    window_clause: window_clause__.unwrap_or_default(),
                    values_lists: values_lists__.unwrap_or_default(),
                    sort_clause: sort_clause__.unwrap_or_default(),
                    limit_offset: limit_offset__,
                    limit_count: limit_count__,
                    limit_option: limit_option__.unwrap_or_default(),
                    locking_clause: locking_clause__.unwrap_or_default(),
                    with_clause: with_clause__,
                    op: op__.unwrap_or_default(),
                    all: all__.unwrap_or_default(),
                    larg: larg__,
                    rarg: rarg__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SelectStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetOpCmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SET_OP_CMD_UNDEFINED",
            Self::SetopcmdIntersect => "SETOPCMD_INTERSECT",
            Self::SetopcmdIntersectAll => "SETOPCMD_INTERSECT_ALL",
            Self::SetopcmdExcept => "SETOPCMD_EXCEPT",
            Self::SetopcmdExceptAll => "SETOPCMD_EXCEPT_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SetOpCmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_OP_CMD_UNDEFINED",
            "SETOPCMD_INTERSECT",
            "SETOPCMD_INTERSECT_ALL",
            "SETOPCMD_EXCEPT",
            "SETOPCMD_EXCEPT_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetOpCmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_OP_CMD_UNDEFINED" => Ok(SetOpCmd::Undefined),
                    "SETOPCMD_INTERSECT" => Ok(SetOpCmd::SetopcmdIntersect),
                    "SETOPCMD_INTERSECT_ALL" => Ok(SetOpCmd::SetopcmdIntersectAll),
                    "SETOPCMD_EXCEPT" => Ok(SetOpCmd::SetopcmdExcept),
                    "SETOPCMD_EXCEPT_ALL" => Ok(SetOpCmd::SetopcmdExceptAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SetOpStrategy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SET_OP_STRATEGY_UNDEFINED",
            Self::SetopSorted => "SETOP_SORTED",
            Self::SetopHashed => "SETOP_HASHED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SetOpStrategy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_OP_STRATEGY_UNDEFINED",
            "SETOP_SORTED",
            "SETOP_HASHED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetOpStrategy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_OP_STRATEGY_UNDEFINED" => Ok(SetOpStrategy::Undefined),
                    "SETOP_SORTED" => Ok(SetOpStrategy::SetopSorted),
                    "SETOP_HASHED" => Ok(SetOpStrategy::SetopHashed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SetOperation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SET_OPERATION_UNDEFINED",
            Self::SetopNone => "SETOP_NONE",
            Self::SetopUnion => "SETOP_UNION",
            Self::SetopIntersect => "SETOP_INTERSECT",
            Self::SetopExcept => "SETOP_EXCEPT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SetOperation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_OPERATION_UNDEFINED",
            "SETOP_NONE",
            "SETOP_UNION",
            "SETOP_INTERSECT",
            "SETOP_EXCEPT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetOperation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_OPERATION_UNDEFINED" => Ok(SetOperation::Undefined),
                    "SETOP_NONE" => Ok(SetOperation::SetopNone),
                    "SETOP_UNION" => Ok(SetOperation::SetopUnion),
                    "SETOP_INTERSECT" => Ok(SetOperation::SetopIntersect),
                    "SETOP_EXCEPT" => Ok(SetOperation::SetopExcept),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SetOperationStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.op != 0 {
            len += 1;
        }
        if self.all {
            len += 1;
        }
        if self.larg.is_some() {
            len += 1;
        }
        if self.rarg.is_some() {
            len += 1;
        }
        if !self.col_types.is_empty() {
            len += 1;
        }
        if !self.col_typmods.is_empty() {
            len += 1;
        }
        if !self.col_collations.is_empty() {
            len += 1;
        }
        if !self.group_clauses.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SetOperationStmt", len)?;
        if self.op != 0 {
            let v = SetOperation::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if self.all {
            struct_ser.serialize_field("all", &self.all)?;
        }
        if let Some(v) = self.larg.as_ref() {
            struct_ser.serialize_field("larg", v)?;
        }
        if let Some(v) = self.rarg.as_ref() {
            struct_ser.serialize_field("rarg", v)?;
        }
        if !self.col_types.is_empty() {
            struct_ser.serialize_field("colTypes", &self.col_types)?;
        }
        if !self.col_typmods.is_empty() {
            struct_ser.serialize_field("colTypmods", &self.col_typmods)?;
        }
        if !self.col_collations.is_empty() {
            struct_ser.serialize_field("colCollations", &self.col_collations)?;
        }
        if !self.group_clauses.is_empty() {
            struct_ser.serialize_field("groupClauses", &self.group_clauses)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetOperationStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "op",
            "all",
            "larg",
            "rarg",
            "col_types",
            "colTypes",
            "col_typmods",
            "colTypmods",
            "col_collations",
            "colCollations",
            "group_clauses",
            "groupClauses",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Op,
            All,
            Larg,
            Rarg,
            ColTypes,
            ColTypmods,
            ColCollations,
            GroupClauses,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "op" => Ok(GeneratedField::Op),
                            "all" => Ok(GeneratedField::All),
                            "larg" => Ok(GeneratedField::Larg),
                            "rarg" => Ok(GeneratedField::Rarg),
                            "colTypes" | "col_types" => Ok(GeneratedField::ColTypes),
                            "colTypmods" | "col_typmods" => Ok(GeneratedField::ColTypmods),
                            "colCollations" | "col_collations" => Ok(GeneratedField::ColCollations),
                            "groupClauses" | "group_clauses" => Ok(GeneratedField::GroupClauses),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetOperationStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SetOperationStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetOperationStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op__ = None;
                let mut all__ = None;
                let mut larg__ = None;
                let mut rarg__ = None;
                let mut col_types__ = None;
                let mut col_typmods__ = None;
                let mut col_collations__ = None;
                let mut group_clauses__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<SetOperation>()? as i32);
                        }
                        GeneratedField::All => {
                            if all__.is_some() {
                                return Err(serde::de::Error::duplicate_field("all"));
                            }
                            all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Larg => {
                            if larg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("larg"));
                            }
                            larg__ = map_.next_value()?;
                        }
                        GeneratedField::Rarg => {
                            if rarg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rarg"));
                            }
                            rarg__ = map_.next_value()?;
                        }
                        GeneratedField::ColTypes => {
                            if col_types__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colTypes"));
                            }
                            col_types__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ColTypmods => {
                            if col_typmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colTypmods"));
                            }
                            col_typmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ColCollations => {
                            if col_collations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colCollations"));
                            }
                            col_collations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupClauses => {
                            if group_clauses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupClauses"));
                            }
                            group_clauses__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SetOperationStmt {
                    op: op__.unwrap_or_default(),
                    all: all__.unwrap_or_default(),
                    larg: larg__,
                    rarg: rarg__,
                    col_types: col_types__.unwrap_or_default(),
                    col_typmods: col_typmods__.unwrap_or_default(),
                    col_collations: col_collations__.unwrap_or_default(),
                    group_clauses: group_clauses__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SetOperationStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetQuantifier {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SET_QUANTIFIER_UNDEFINED",
            Self::Default => "SET_QUANTIFIER_DEFAULT",
            Self::All => "SET_QUANTIFIER_ALL",
            Self::Distinct => "SET_QUANTIFIER_DISTINCT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SetQuantifier {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_QUANTIFIER_UNDEFINED",
            "SET_QUANTIFIER_DEFAULT",
            "SET_QUANTIFIER_ALL",
            "SET_QUANTIFIER_DISTINCT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetQuantifier;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_QUANTIFIER_UNDEFINED" => Ok(SetQuantifier::Undefined),
                    "SET_QUANTIFIER_DEFAULT" => Ok(SetQuantifier::Default),
                    "SET_QUANTIFIER_ALL" => Ok(SetQuantifier::All),
                    "SET_QUANTIFIER_DISTINCT" => Ok(SetQuantifier::Distinct),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SetToDefault {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.type_id != 0 {
            len += 1;
        }
        if self.type_mod != 0 {
            len += 1;
        }
        if self.collation != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SetToDefault", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.type_id != 0 {
            struct_ser.serialize_field("typeId", &self.type_id)?;
        }
        if self.type_mod != 0 {
            struct_ser.serialize_field("typeMod", &self.type_mod)?;
        }
        if self.collation != 0 {
            struct_ser.serialize_field("collation", &self.collation)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetToDefault {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "type_id",
            "typeId",
            "type_mod",
            "typeMod",
            "collation",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            TypeId,
            TypeMod,
            Collation,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "typeId" | "type_id" => Ok(GeneratedField::TypeId),
                            "typeMod" | "type_mod" => Ok(GeneratedField::TypeMod),
                            "collation" => Ok(GeneratedField::Collation),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetToDefault;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SetToDefault")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetToDefault, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut type_id__ = None;
                let mut type_mod__ = None;
                let mut collation__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::TypeId => {
                            if type_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeId"));
                            }
                            type_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeMod => {
                            if type_mod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeMod"));
                            }
                            type_mod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Collation => {
                            if collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("collation"));
                            }
                            collation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SetToDefault {
                    xpr: xpr__,
                    type_id: type_id__.unwrap_or_default(),
                    type_mod: type_mod__.unwrap_or_default(),
                    collation: collation__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SetToDefault", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SortBy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.node.is_some() {
            len += 1;
        }
        if self.sortby_dir != 0 {
            len += 1;
        }
        if self.sortby_nulls != 0 {
            len += 1;
        }
        if !self.use_op.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SortBy", len)?;
        if let Some(v) = self.node.as_ref() {
            struct_ser.serialize_field("node", v)?;
        }
        if self.sortby_dir != 0 {
            let v = SortByDir::try_from(self.sortby_dir)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sortby_dir)))?;
            struct_ser.serialize_field("sortby_dir", &v)?;
        }
        if self.sortby_nulls != 0 {
            let v = SortByNulls::try_from(self.sortby_nulls)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sortby_nulls)))?;
            struct_ser.serialize_field("sortby_nulls", &v)?;
        }
        if !self.use_op.is_empty() {
            struct_ser.serialize_field("useOp", &self.use_op)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SortBy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "node",
            "sortby_dir",
            "sortby_nulls",
            "use_op",
            "useOp",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Node,
            SortbyDir,
            SortbyNulls,
            UseOp,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "node" => Ok(GeneratedField::Node),
                            "sortby_dir" => Ok(GeneratedField::SortbyDir),
                            "sortby_nulls" => Ok(GeneratedField::SortbyNulls),
                            "useOp" | "use_op" => Ok(GeneratedField::UseOp),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortBy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SortBy")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SortBy, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut node__ = None;
                let mut sortby_dir__ = None;
                let mut sortby_nulls__ = None;
                let mut use_op__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Node => {
                            if node__.is_some() {
                                return Err(serde::de::Error::duplicate_field("node"));
                            }
                            node__ = map_.next_value()?;
                        }
                        GeneratedField::SortbyDir => {
                            if sortby_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sortby_dir"));
                            }
                            sortby_dir__ = Some(map_.next_value::<SortByDir>()? as i32);
                        }
                        GeneratedField::SortbyNulls => {
                            if sortby_nulls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sortby_nulls"));
                            }
                            sortby_nulls__ = Some(map_.next_value::<SortByNulls>()? as i32);
                        }
                        GeneratedField::UseOp => {
                            if use_op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("useOp"));
                            }
                            use_op__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SortBy {
                    node: node__,
                    sortby_dir: sortby_dir__.unwrap_or_default(),
                    sortby_nulls: sortby_nulls__.unwrap_or_default(),
                    use_op: use_op__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SortBy", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SortByDir {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SORT_BY_DIR_UNDEFINED",
            Self::SortbyDefault => "SORTBY_DEFAULT",
            Self::SortbyAsc => "SORTBY_ASC",
            Self::SortbyDesc => "SORTBY_DESC",
            Self::SortbyUsing => "SORTBY_USING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SortByDir {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SORT_BY_DIR_UNDEFINED",
            "SORTBY_DEFAULT",
            "SORTBY_ASC",
            "SORTBY_DESC",
            "SORTBY_USING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortByDir;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SORT_BY_DIR_UNDEFINED" => Ok(SortByDir::Undefined),
                    "SORTBY_DEFAULT" => Ok(SortByDir::SortbyDefault),
                    "SORTBY_ASC" => Ok(SortByDir::SortbyAsc),
                    "SORTBY_DESC" => Ok(SortByDir::SortbyDesc),
                    "SORTBY_USING" => Ok(SortByDir::SortbyUsing),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SortByNulls {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SORT_BY_NULLS_UNDEFINED",
            Self::SortbyNullsDefault => "SORTBY_NULLS_DEFAULT",
            Self::SortbyNullsFirst => "SORTBY_NULLS_FIRST",
            Self::SortbyNullsLast => "SORTBY_NULLS_LAST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SortByNulls {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SORT_BY_NULLS_UNDEFINED",
            "SORTBY_NULLS_DEFAULT",
            "SORTBY_NULLS_FIRST",
            "SORTBY_NULLS_LAST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortByNulls;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SORT_BY_NULLS_UNDEFINED" => Ok(SortByNulls::Undefined),
                    "SORTBY_NULLS_DEFAULT" => Ok(SortByNulls::SortbyNullsDefault),
                    "SORTBY_NULLS_FIRST" => Ok(SortByNulls::SortbyNullsFirst),
                    "SORTBY_NULLS_LAST" => Ok(SortByNulls::SortbyNullsLast),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SortGroupClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tle_sort_group_ref != 0 {
            len += 1;
        }
        if self.eqop != 0 {
            len += 1;
        }
        if self.sortop != 0 {
            len += 1;
        }
        if self.nulls_first {
            len += 1;
        }
        if self.hashable {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SortGroupClause", len)?;
        if self.tle_sort_group_ref != 0 {
            struct_ser.serialize_field("tleSortGroupRef", &self.tle_sort_group_ref)?;
        }
        if self.eqop != 0 {
            struct_ser.serialize_field("eqop", &self.eqop)?;
        }
        if self.sortop != 0 {
            struct_ser.serialize_field("sortop", &self.sortop)?;
        }
        if self.nulls_first {
            struct_ser.serialize_field("nulls_first", &self.nulls_first)?;
        }
        if self.hashable {
            struct_ser.serialize_field("hashable", &self.hashable)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SortGroupClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tle_sort_group_ref",
            "tleSortGroupRef",
            "eqop",
            "sortop",
            "nulls_first",
            "hashable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TleSortGroupRef,
            Eqop,
            Sortop,
            NullsFirst,
            Hashable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tleSortGroupRef" | "tle_sort_group_ref" => Ok(GeneratedField::TleSortGroupRef),
                            "eqop" => Ok(GeneratedField::Eqop),
                            "sortop" => Ok(GeneratedField::Sortop),
                            "nulls_first" => Ok(GeneratedField::NullsFirst),
                            "hashable" => Ok(GeneratedField::Hashable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortGroupClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SortGroupClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SortGroupClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tle_sort_group_ref__ = None;
                let mut eqop__ = None;
                let mut sortop__ = None;
                let mut nulls_first__ = None;
                let mut hashable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TleSortGroupRef => {
                            if tle_sort_group_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tleSortGroupRef"));
                            }
                            tle_sort_group_ref__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Eqop => {
                            if eqop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eqop"));
                            }
                            eqop__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Sortop => {
                            if sortop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sortop"));
                            }
                            sortop__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::NullsFirst => {
                            if nulls_first__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nulls_first"));
                            }
                            nulls_first__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Hashable => {
                            if hashable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hashable"));
                            }
                            hashable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SortGroupClause {
                    tle_sort_group_ref: tle_sort_group_ref__.unwrap_or_default(),
                    eqop: eqop__.unwrap_or_default(),
                    sortop: sortop__.unwrap_or_default(),
                    nulls_first: nulls_first__.unwrap_or_default(),
                    hashable: hashable__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SortGroupClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StatsElem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.StatsElem", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StatsElem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "expr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Expr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "expr" => Ok(GeneratedField::Expr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StatsElem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.StatsElem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StatsElem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut expr__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                    }
                }
                Ok(StatsElem {
                    name: name__.unwrap_or_default(),
                    expr: expr__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.StatsElem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for String {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sval.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.String", len)?;
        if !self.sval.is_empty() {
            struct_ser.serialize_field("sval", &self.sval)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for String {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sval,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sval" => Ok(GeneratedField::Sval),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = String;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.String")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<String, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sval => {
                            if sval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sval"));
                            }
                            sval__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(String {
                    sval: sval__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.String", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SubLink {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.sub_link_type != 0 {
            len += 1;
        }
        if self.sub_link_id != 0 {
            len += 1;
        }
        if self.testexpr.is_some() {
            len += 1;
        }
        if !self.oper_name.is_empty() {
            len += 1;
        }
        if self.subselect.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SubLink", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.sub_link_type != 0 {
            let v = SubLinkType::try_from(self.sub_link_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sub_link_type)))?;
            struct_ser.serialize_field("subLinkType", &v)?;
        }
        if self.sub_link_id != 0 {
            struct_ser.serialize_field("subLinkId", &self.sub_link_id)?;
        }
        if let Some(v) = self.testexpr.as_ref() {
            struct_ser.serialize_field("testexpr", v)?;
        }
        if !self.oper_name.is_empty() {
            struct_ser.serialize_field("operName", &self.oper_name)?;
        }
        if let Some(v) = self.subselect.as_ref() {
            struct_ser.serialize_field("subselect", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SubLink {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "sub_link_type",
            "subLinkType",
            "sub_link_id",
            "subLinkId",
            "testexpr",
            "oper_name",
            "operName",
            "subselect",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            SubLinkType,
            SubLinkId,
            Testexpr,
            OperName,
            Subselect,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "subLinkType" | "sub_link_type" => Ok(GeneratedField::SubLinkType),
                            "subLinkId" | "sub_link_id" => Ok(GeneratedField::SubLinkId),
                            "testexpr" => Ok(GeneratedField::Testexpr),
                            "operName" | "oper_name" => Ok(GeneratedField::OperName),
                            "subselect" => Ok(GeneratedField::Subselect),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubLink;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SubLink")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubLink, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut sub_link_type__ = None;
                let mut sub_link_id__ = None;
                let mut testexpr__ = None;
                let mut oper_name__ = None;
                let mut subselect__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::SubLinkType => {
                            if sub_link_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subLinkType"));
                            }
                            sub_link_type__ = Some(map_.next_value::<SubLinkType>()? as i32);
                        }
                        GeneratedField::SubLinkId => {
                            if sub_link_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subLinkId"));
                            }
                            sub_link_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Testexpr => {
                            if testexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("testexpr"));
                            }
                            testexpr__ = map_.next_value()?;
                        }
                        GeneratedField::OperName => {
                            if oper_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operName"));
                            }
                            oper_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Subselect => {
                            if subselect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subselect"));
                            }
                            subselect__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SubLink {
                    xpr: xpr__,
                    sub_link_type: sub_link_type__.unwrap_or_default(),
                    sub_link_id: sub_link_id__.unwrap_or_default(),
                    testexpr: testexpr__,
                    oper_name: oper_name__.unwrap_or_default(),
                    subselect: subselect__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SubLink", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SubLinkType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "SUB_LINK_TYPE_UNDEFINED",
            Self::ExistsSublink => "EXISTS_SUBLINK",
            Self::AllSublink => "ALL_SUBLINK",
            Self::AnySublink => "ANY_SUBLINK",
            Self::RowcompareSublink => "ROWCOMPARE_SUBLINK",
            Self::ExprSublink => "EXPR_SUBLINK",
            Self::MultiexprSublink => "MULTIEXPR_SUBLINK",
            Self::ArraySublink => "ARRAY_SUBLINK",
            Self::CteSublink => "CTE_SUBLINK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SubLinkType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUB_LINK_TYPE_UNDEFINED",
            "EXISTS_SUBLINK",
            "ALL_SUBLINK",
            "ANY_SUBLINK",
            "ROWCOMPARE_SUBLINK",
            "EXPR_SUBLINK",
            "MULTIEXPR_SUBLINK",
            "ARRAY_SUBLINK",
            "CTE_SUBLINK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubLinkType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUB_LINK_TYPE_UNDEFINED" => Ok(SubLinkType::Undefined),
                    "EXISTS_SUBLINK" => Ok(SubLinkType::ExistsSublink),
                    "ALL_SUBLINK" => Ok(SubLinkType::AllSublink),
                    "ANY_SUBLINK" => Ok(SubLinkType::AnySublink),
                    "ROWCOMPARE_SUBLINK" => Ok(SubLinkType::RowcompareSublink),
                    "EXPR_SUBLINK" => Ok(SubLinkType::ExprSublink),
                    "MULTIEXPR_SUBLINK" => Ok(SubLinkType::MultiexprSublink),
                    "ARRAY_SUBLINK" => Ok(SubLinkType::ArraySublink),
                    "CTE_SUBLINK" => Ok(SubLinkType::CteSublink),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SubPlan {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.sub_link_type != 0 {
            len += 1;
        }
        if self.testexpr.is_some() {
            len += 1;
        }
        if !self.param_ids.is_empty() {
            len += 1;
        }
        if self.plan_id != 0 {
            len += 1;
        }
        if !self.plan_name.is_empty() {
            len += 1;
        }
        if self.first_col_type != 0 {
            len += 1;
        }
        if self.first_col_typmod != 0 {
            len += 1;
        }
        if self.first_col_collation != 0 {
            len += 1;
        }
        if self.use_hash_table {
            len += 1;
        }
        if self.unknown_eq_false {
            len += 1;
        }
        if self.parallel_safe {
            len += 1;
        }
        if !self.set_param.is_empty() {
            len += 1;
        }
        if !self.par_param.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.startup_cost != 0. {
            len += 1;
        }
        if self.per_call_cost != 0. {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SubPlan", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.sub_link_type != 0 {
            let v = SubLinkType::try_from(self.sub_link_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sub_link_type)))?;
            struct_ser.serialize_field("subLinkType", &v)?;
        }
        if let Some(v) = self.testexpr.as_ref() {
            struct_ser.serialize_field("testexpr", v)?;
        }
        if !self.param_ids.is_empty() {
            struct_ser.serialize_field("paramIds", &self.param_ids)?;
        }
        if self.plan_id != 0 {
            struct_ser.serialize_field("plan_id", &self.plan_id)?;
        }
        if !self.plan_name.is_empty() {
            struct_ser.serialize_field("plan_name", &self.plan_name)?;
        }
        if self.first_col_type != 0 {
            struct_ser.serialize_field("firstColType", &self.first_col_type)?;
        }
        if self.first_col_typmod != 0 {
            struct_ser.serialize_field("firstColTypmod", &self.first_col_typmod)?;
        }
        if self.first_col_collation != 0 {
            struct_ser.serialize_field("firstColCollation", &self.first_col_collation)?;
        }
        if self.use_hash_table {
            struct_ser.serialize_field("useHashTable", &self.use_hash_table)?;
        }
        if self.unknown_eq_false {
            struct_ser.serialize_field("unknownEqFalse", &self.unknown_eq_false)?;
        }
        if self.parallel_safe {
            struct_ser.serialize_field("parallel_safe", &self.parallel_safe)?;
        }
        if !self.set_param.is_empty() {
            struct_ser.serialize_field("setParam", &self.set_param)?;
        }
        if !self.par_param.is_empty() {
            struct_ser.serialize_field("parParam", &self.par_param)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.startup_cost != 0. {
            struct_ser.serialize_field("startup_cost", &self.startup_cost)?;
        }
        if self.per_call_cost != 0. {
            struct_ser.serialize_field("per_call_cost", &self.per_call_cost)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SubPlan {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "sub_link_type",
            "subLinkType",
            "testexpr",
            "param_ids",
            "paramIds",
            "plan_id",
            "plan_name",
            "first_col_type",
            "firstColType",
            "first_col_typmod",
            "firstColTypmod",
            "first_col_collation",
            "firstColCollation",
            "use_hash_table",
            "useHashTable",
            "unknown_eq_false",
            "unknownEqFalse",
            "parallel_safe",
            "set_param",
            "setParam",
            "par_param",
            "parParam",
            "args",
            "startup_cost",
            "per_call_cost",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            SubLinkType,
            Testexpr,
            ParamIds,
            PlanId,
            PlanName,
            FirstColType,
            FirstColTypmod,
            FirstColCollation,
            UseHashTable,
            UnknownEqFalse,
            ParallelSafe,
            SetParam,
            ParParam,
            Args,
            StartupCost,
            PerCallCost,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "subLinkType" | "sub_link_type" => Ok(GeneratedField::SubLinkType),
                            "testexpr" => Ok(GeneratedField::Testexpr),
                            "paramIds" | "param_ids" => Ok(GeneratedField::ParamIds),
                            "plan_id" => Ok(GeneratedField::PlanId),
                            "plan_name" => Ok(GeneratedField::PlanName),
                            "firstColType" | "first_col_type" => Ok(GeneratedField::FirstColType),
                            "firstColTypmod" | "first_col_typmod" => Ok(GeneratedField::FirstColTypmod),
                            "firstColCollation" | "first_col_collation" => Ok(GeneratedField::FirstColCollation),
                            "useHashTable" | "use_hash_table" => Ok(GeneratedField::UseHashTable),
                            "unknownEqFalse" | "unknown_eq_false" => Ok(GeneratedField::UnknownEqFalse),
                            "parallel_safe" => Ok(GeneratedField::ParallelSafe),
                            "setParam" | "set_param" => Ok(GeneratedField::SetParam),
                            "parParam" | "par_param" => Ok(GeneratedField::ParParam),
                            "args" => Ok(GeneratedField::Args),
                            "startup_cost" => Ok(GeneratedField::StartupCost),
                            "per_call_cost" => Ok(GeneratedField::PerCallCost),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubPlan;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SubPlan")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubPlan, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut sub_link_type__ = None;
                let mut testexpr__ = None;
                let mut param_ids__ = None;
                let mut plan_id__ = None;
                let mut plan_name__ = None;
                let mut first_col_type__ = None;
                let mut first_col_typmod__ = None;
                let mut first_col_collation__ = None;
                let mut use_hash_table__ = None;
                let mut unknown_eq_false__ = None;
                let mut parallel_safe__ = None;
                let mut set_param__ = None;
                let mut par_param__ = None;
                let mut args__ = None;
                let mut startup_cost__ = None;
                let mut per_call_cost__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::SubLinkType => {
                            if sub_link_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subLinkType"));
                            }
                            sub_link_type__ = Some(map_.next_value::<SubLinkType>()? as i32);
                        }
                        GeneratedField::Testexpr => {
                            if testexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("testexpr"));
                            }
                            testexpr__ = map_.next_value()?;
                        }
                        GeneratedField::ParamIds => {
                            if param_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paramIds"));
                            }
                            param_ids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PlanId => {
                            if plan_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plan_id"));
                            }
                            plan_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PlanName => {
                            if plan_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("plan_name"));
                            }
                            plan_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FirstColType => {
                            if first_col_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firstColType"));
                            }
                            first_col_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::FirstColTypmod => {
                            if first_col_typmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firstColTypmod"));
                            }
                            first_col_typmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::FirstColCollation => {
                            if first_col_collation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firstColCollation"));
                            }
                            first_col_collation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::UseHashTable => {
                            if use_hash_table__.is_some() {
                                return Err(serde::de::Error::duplicate_field("useHashTable"));
                            }
                            use_hash_table__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UnknownEqFalse => {
                            if unknown_eq_false__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unknownEqFalse"));
                            }
                            unknown_eq_false__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ParallelSafe => {
                            if parallel_safe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parallel_safe"));
                            }
                            parallel_safe__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SetParam => {
                            if set_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setParam"));
                            }
                            set_param__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ParParam => {
                            if par_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parParam"));
                            }
                            par_param__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StartupCost => {
                            if startup_cost__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startup_cost"));
                            }
                            startup_cost__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PerCallCost => {
                            if per_call_cost__.is_some() {
                                return Err(serde::de::Error::duplicate_field("per_call_cost"));
                            }
                            per_call_cost__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SubPlan {
                    xpr: xpr__,
                    sub_link_type: sub_link_type__.unwrap_or_default(),
                    testexpr: testexpr__,
                    param_ids: param_ids__.unwrap_or_default(),
                    plan_id: plan_id__.unwrap_or_default(),
                    plan_name: plan_name__.unwrap_or_default(),
                    first_col_type: first_col_type__.unwrap_or_default(),
                    first_col_typmod: first_col_typmod__.unwrap_or_default(),
                    first_col_collation: first_col_collation__.unwrap_or_default(),
                    use_hash_table: use_hash_table__.unwrap_or_default(),
                    unknown_eq_false: unknown_eq_false__.unwrap_or_default(),
                    parallel_safe: parallel_safe__.unwrap_or_default(),
                    set_param: set_param__.unwrap_or_default(),
                    par_param: par_param__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    startup_cost: startup_cost__.unwrap_or_default(),
                    per_call_cost: per_call_cost__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SubPlan", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SubscriptingRef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.refcontainertype != 0 {
            len += 1;
        }
        if self.refelemtype != 0 {
            len += 1;
        }
        if self.refrestype != 0 {
            len += 1;
        }
        if self.reftypmod != 0 {
            len += 1;
        }
        if self.refcollid != 0 {
            len += 1;
        }
        if !self.refupperindexpr.is_empty() {
            len += 1;
        }
        if !self.reflowerindexpr.is_empty() {
            len += 1;
        }
        if self.refexpr.is_some() {
            len += 1;
        }
        if self.refassgnexpr.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.SubscriptingRef", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.refcontainertype != 0 {
            struct_ser.serialize_field("refcontainertype", &self.refcontainertype)?;
        }
        if self.refelemtype != 0 {
            struct_ser.serialize_field("refelemtype", &self.refelemtype)?;
        }
        if self.refrestype != 0 {
            struct_ser.serialize_field("refrestype", &self.refrestype)?;
        }
        if self.reftypmod != 0 {
            struct_ser.serialize_field("reftypmod", &self.reftypmod)?;
        }
        if self.refcollid != 0 {
            struct_ser.serialize_field("refcollid", &self.refcollid)?;
        }
        if !self.refupperindexpr.is_empty() {
            struct_ser.serialize_field("refupperindexpr", &self.refupperindexpr)?;
        }
        if !self.reflowerindexpr.is_empty() {
            struct_ser.serialize_field("reflowerindexpr", &self.reflowerindexpr)?;
        }
        if let Some(v) = self.refexpr.as_ref() {
            struct_ser.serialize_field("refexpr", v)?;
        }
        if let Some(v) = self.refassgnexpr.as_ref() {
            struct_ser.serialize_field("refassgnexpr", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SubscriptingRef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "refcontainertype",
            "refelemtype",
            "refrestype",
            "reftypmod",
            "refcollid",
            "refupperindexpr",
            "reflowerindexpr",
            "refexpr",
            "refassgnexpr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Refcontainertype,
            Refelemtype,
            Refrestype,
            Reftypmod,
            Refcollid,
            Refupperindexpr,
            Reflowerindexpr,
            Refexpr,
            Refassgnexpr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "refcontainertype" => Ok(GeneratedField::Refcontainertype),
                            "refelemtype" => Ok(GeneratedField::Refelemtype),
                            "refrestype" => Ok(GeneratedField::Refrestype),
                            "reftypmod" => Ok(GeneratedField::Reftypmod),
                            "refcollid" => Ok(GeneratedField::Refcollid),
                            "refupperindexpr" => Ok(GeneratedField::Refupperindexpr),
                            "reflowerindexpr" => Ok(GeneratedField::Reflowerindexpr),
                            "refexpr" => Ok(GeneratedField::Refexpr),
                            "refassgnexpr" => Ok(GeneratedField::Refassgnexpr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubscriptingRef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.SubscriptingRef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubscriptingRef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut refcontainertype__ = None;
                let mut refelemtype__ = None;
                let mut refrestype__ = None;
                let mut reftypmod__ = None;
                let mut refcollid__ = None;
                let mut refupperindexpr__ = None;
                let mut reflowerindexpr__ = None;
                let mut refexpr__ = None;
                let mut refassgnexpr__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Refcontainertype => {
                            if refcontainertype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refcontainertype"));
                            }
                            refcontainertype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Refelemtype => {
                            if refelemtype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refelemtype"));
                            }
                            refelemtype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Refrestype => {
                            if refrestype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refrestype"));
                            }
                            refrestype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Reftypmod => {
                            if reftypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reftypmod"));
                            }
                            reftypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Refcollid => {
                            if refcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refcollid"));
                            }
                            refcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Refupperindexpr => {
                            if refupperindexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refupperindexpr"));
                            }
                            refupperindexpr__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Reflowerindexpr => {
                            if reflowerindexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reflowerindexpr"));
                            }
                            reflowerindexpr__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Refexpr => {
                            if refexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refexpr"));
                            }
                            refexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Refassgnexpr => {
                            if refassgnexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refassgnexpr"));
                            }
                            refassgnexpr__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SubscriptingRef {
                    xpr: xpr__,
                    refcontainertype: refcontainertype__.unwrap_or_default(),
                    refelemtype: refelemtype__.unwrap_or_default(),
                    refrestype: refrestype__.unwrap_or_default(),
                    reftypmod: reftypmod__.unwrap_or_default(),
                    refcollid: refcollid__.unwrap_or_default(),
                    refupperindexpr: refupperindexpr__.unwrap_or_default(),
                    reflowerindexpr: reflowerindexpr__.unwrap_or_default(),
                    refexpr: refexpr__,
                    refassgnexpr: refassgnexpr__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.SubscriptingRef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TableFunc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ns_uris.is_empty() {
            len += 1;
        }
        if !self.ns_names.is_empty() {
            len += 1;
        }
        if self.docexpr.is_some() {
            len += 1;
        }
        if self.rowexpr.is_some() {
            len += 1;
        }
        if !self.colnames.is_empty() {
            len += 1;
        }
        if !self.coltypes.is_empty() {
            len += 1;
        }
        if !self.coltypmods.is_empty() {
            len += 1;
        }
        if !self.colcollations.is_empty() {
            len += 1;
        }
        if !self.colexprs.is_empty() {
            len += 1;
        }
        if !self.coldefexprs.is_empty() {
            len += 1;
        }
        if !self.notnulls.is_empty() {
            len += 1;
        }
        if self.ordinalitycol != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TableFunc", len)?;
        if !self.ns_uris.is_empty() {
            struct_ser.serialize_field("ns_uris", &self.ns_uris)?;
        }
        if !self.ns_names.is_empty() {
            struct_ser.serialize_field("ns_names", &self.ns_names)?;
        }
        if let Some(v) = self.docexpr.as_ref() {
            struct_ser.serialize_field("docexpr", v)?;
        }
        if let Some(v) = self.rowexpr.as_ref() {
            struct_ser.serialize_field("rowexpr", v)?;
        }
        if !self.colnames.is_empty() {
            struct_ser.serialize_field("colnames", &self.colnames)?;
        }
        if !self.coltypes.is_empty() {
            struct_ser.serialize_field("coltypes", &self.coltypes)?;
        }
        if !self.coltypmods.is_empty() {
            struct_ser.serialize_field("coltypmods", &self.coltypmods)?;
        }
        if !self.colcollations.is_empty() {
            struct_ser.serialize_field("colcollations", &self.colcollations)?;
        }
        if !self.colexprs.is_empty() {
            struct_ser.serialize_field("colexprs", &self.colexprs)?;
        }
        if !self.coldefexprs.is_empty() {
            struct_ser.serialize_field("coldefexprs", &self.coldefexprs)?;
        }
        if !self.notnulls.is_empty() {
            struct_ser.serialize_field("notnulls", &self.notnulls.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if self.ordinalitycol != 0 {
            struct_ser.serialize_field("ordinalitycol", &self.ordinalitycol)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TableFunc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ns_uris",
            "ns_names",
            "docexpr",
            "rowexpr",
            "colnames",
            "coltypes",
            "coltypmods",
            "colcollations",
            "colexprs",
            "coldefexprs",
            "notnulls",
            "ordinalitycol",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NsUris,
            NsNames,
            Docexpr,
            Rowexpr,
            Colnames,
            Coltypes,
            Coltypmods,
            Colcollations,
            Colexprs,
            Coldefexprs,
            Notnulls,
            Ordinalitycol,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ns_uris" => Ok(GeneratedField::NsUris),
                            "ns_names" => Ok(GeneratedField::NsNames),
                            "docexpr" => Ok(GeneratedField::Docexpr),
                            "rowexpr" => Ok(GeneratedField::Rowexpr),
                            "colnames" => Ok(GeneratedField::Colnames),
                            "coltypes" => Ok(GeneratedField::Coltypes),
                            "coltypmods" => Ok(GeneratedField::Coltypmods),
                            "colcollations" => Ok(GeneratedField::Colcollations),
                            "colexprs" => Ok(GeneratedField::Colexprs),
                            "coldefexprs" => Ok(GeneratedField::Coldefexprs),
                            "notnulls" => Ok(GeneratedField::Notnulls),
                            "ordinalitycol" => Ok(GeneratedField::Ordinalitycol),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TableFunc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TableFunc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TableFunc, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ns_uris__ = None;
                let mut ns_names__ = None;
                let mut docexpr__ = None;
                let mut rowexpr__ = None;
                let mut colnames__ = None;
                let mut coltypes__ = None;
                let mut coltypmods__ = None;
                let mut colcollations__ = None;
                let mut colexprs__ = None;
                let mut coldefexprs__ = None;
                let mut notnulls__ = None;
                let mut ordinalitycol__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NsUris => {
                            if ns_uris__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ns_uris"));
                            }
                            ns_uris__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NsNames => {
                            if ns_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ns_names"));
                            }
                            ns_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Docexpr => {
                            if docexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("docexpr"));
                            }
                            docexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Rowexpr => {
                            if rowexpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rowexpr"));
                            }
                            rowexpr__ = map_.next_value()?;
                        }
                        GeneratedField::Colnames => {
                            if colnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colnames"));
                            }
                            colnames__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Coltypes => {
                            if coltypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coltypes"));
                            }
                            coltypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Coltypmods => {
                            if coltypmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coltypmods"));
                            }
                            coltypmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Colcollations => {
                            if colcollations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colcollations"));
                            }
                            colcollations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Colexprs => {
                            if colexprs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("colexprs"));
                            }
                            colexprs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Coldefexprs => {
                            if coldefexprs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coldefexprs"));
                            }
                            coldefexprs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Notnulls => {
                            if notnulls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notnulls"));
                            }
                            notnulls__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Ordinalitycol => {
                            if ordinalitycol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ordinalitycol"));
                            }
                            ordinalitycol__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(TableFunc {
                    ns_uris: ns_uris__.unwrap_or_default(),
                    ns_names: ns_names__.unwrap_or_default(),
                    docexpr: docexpr__,
                    rowexpr: rowexpr__,
                    colnames: colnames__.unwrap_or_default(),
                    coltypes: coltypes__.unwrap_or_default(),
                    coltypmods: coltypmods__.unwrap_or_default(),
                    colcollations: colcollations__.unwrap_or_default(),
                    colexprs: colexprs__.unwrap_or_default(),
                    coldefexprs: coldefexprs__.unwrap_or_default(),
                    notnulls: notnulls__.unwrap_or_default(),
                    ordinalitycol: ordinalitycol__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TableFunc", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TableLikeClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if self.options != 0 {
            len += 1;
        }
        if self.relation_oid != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TableLikeClause", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if self.options != 0 {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.relation_oid != 0 {
            struct_ser.serialize_field("relationOid", &self.relation_oid)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TableLikeClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "options",
            "relation_oid",
            "relationOid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Options,
            RelationOid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "options" => Ok(GeneratedField::Options),
                            "relationOid" | "relation_oid" => Ok(GeneratedField::RelationOid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TableLikeClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TableLikeClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TableLikeClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut options__ = None;
                let mut relation_oid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::RelationOid => {
                            if relation_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relationOid"));
                            }
                            relation_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(TableLikeClause {
                    relation: relation__,
                    options: options__.unwrap_or_default(),
                    relation_oid: relation_oid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TableLikeClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TableLikeOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "TABLE_LIKE_OPTION_UNDEFINED",
            Self::CreateTableLikeComments => "CREATE_TABLE_LIKE_COMMENTS",
            Self::CreateTableLikeCompression => "CREATE_TABLE_LIKE_COMPRESSION",
            Self::CreateTableLikeConstraints => "CREATE_TABLE_LIKE_CONSTRAINTS",
            Self::CreateTableLikeDefaults => "CREATE_TABLE_LIKE_DEFAULTS",
            Self::CreateTableLikeGenerated => "CREATE_TABLE_LIKE_GENERATED",
            Self::CreateTableLikeIdentity => "CREATE_TABLE_LIKE_IDENTITY",
            Self::CreateTableLikeIndexes => "CREATE_TABLE_LIKE_INDEXES",
            Self::CreateTableLikeStatistics => "CREATE_TABLE_LIKE_STATISTICS",
            Self::CreateTableLikeStorage => "CREATE_TABLE_LIKE_STORAGE",
            Self::CreateTableLikeAll => "CREATE_TABLE_LIKE_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for TableLikeOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TABLE_LIKE_OPTION_UNDEFINED",
            "CREATE_TABLE_LIKE_COMMENTS",
            "CREATE_TABLE_LIKE_COMPRESSION",
            "CREATE_TABLE_LIKE_CONSTRAINTS",
            "CREATE_TABLE_LIKE_DEFAULTS",
            "CREATE_TABLE_LIKE_GENERATED",
            "CREATE_TABLE_LIKE_IDENTITY",
            "CREATE_TABLE_LIKE_INDEXES",
            "CREATE_TABLE_LIKE_STATISTICS",
            "CREATE_TABLE_LIKE_STORAGE",
            "CREATE_TABLE_LIKE_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TableLikeOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TABLE_LIKE_OPTION_UNDEFINED" => Ok(TableLikeOption::Undefined),
                    "CREATE_TABLE_LIKE_COMMENTS" => Ok(TableLikeOption::CreateTableLikeComments),
                    "CREATE_TABLE_LIKE_COMPRESSION" => Ok(TableLikeOption::CreateTableLikeCompression),
                    "CREATE_TABLE_LIKE_CONSTRAINTS" => Ok(TableLikeOption::CreateTableLikeConstraints),
                    "CREATE_TABLE_LIKE_DEFAULTS" => Ok(TableLikeOption::CreateTableLikeDefaults),
                    "CREATE_TABLE_LIKE_GENERATED" => Ok(TableLikeOption::CreateTableLikeGenerated),
                    "CREATE_TABLE_LIKE_IDENTITY" => Ok(TableLikeOption::CreateTableLikeIdentity),
                    "CREATE_TABLE_LIKE_INDEXES" => Ok(TableLikeOption::CreateTableLikeIndexes),
                    "CREATE_TABLE_LIKE_STATISTICS" => Ok(TableLikeOption::CreateTableLikeStatistics),
                    "CREATE_TABLE_LIKE_STORAGE" => Ok(TableLikeOption::CreateTableLikeStorage),
                    "CREATE_TABLE_LIKE_ALL" => Ok(TableLikeOption::CreateTableLikeAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TableSampleClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tsmhandler != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.repeatable.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TableSampleClause", len)?;
        if self.tsmhandler != 0 {
            struct_ser.serialize_field("tsmhandler", &self.tsmhandler)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.repeatable.as_ref() {
            struct_ser.serialize_field("repeatable", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TableSampleClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tsmhandler",
            "args",
            "repeatable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tsmhandler,
            Args,
            Repeatable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tsmhandler" => Ok(GeneratedField::Tsmhandler),
                            "args" => Ok(GeneratedField::Args),
                            "repeatable" => Ok(GeneratedField::Repeatable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TableSampleClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TableSampleClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TableSampleClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tsmhandler__ = None;
                let mut args__ = None;
                let mut repeatable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tsmhandler => {
                            if tsmhandler__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tsmhandler"));
                            }
                            tsmhandler__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Repeatable => {
                            if repeatable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("repeatable"));
                            }
                            repeatable__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TableSampleClause {
                    tsmhandler: tsmhandler__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    repeatable: repeatable__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TableSampleClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TargetEntry {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if self.resno != 0 {
            len += 1;
        }
        if !self.resname.is_empty() {
            len += 1;
        }
        if self.ressortgroupref != 0 {
            len += 1;
        }
        if self.resorigtbl != 0 {
            len += 1;
        }
        if self.resorigcol != 0 {
            len += 1;
        }
        if self.resjunk {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TargetEntry", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if self.resno != 0 {
            struct_ser.serialize_field("resno", &self.resno)?;
        }
        if !self.resname.is_empty() {
            struct_ser.serialize_field("resname", &self.resname)?;
        }
        if self.ressortgroupref != 0 {
            struct_ser.serialize_field("ressortgroupref", &self.ressortgroupref)?;
        }
        if self.resorigtbl != 0 {
            struct_ser.serialize_field("resorigtbl", &self.resorigtbl)?;
        }
        if self.resorigcol != 0 {
            struct_ser.serialize_field("resorigcol", &self.resorigcol)?;
        }
        if self.resjunk {
            struct_ser.serialize_field("resjunk", &self.resjunk)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TargetEntry {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "expr",
            "resno",
            "resname",
            "ressortgroupref",
            "resorigtbl",
            "resorigcol",
            "resjunk",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Expr,
            Resno,
            Resname,
            Ressortgroupref,
            Resorigtbl,
            Resorigcol,
            Resjunk,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "expr" => Ok(GeneratedField::Expr),
                            "resno" => Ok(GeneratedField::Resno),
                            "resname" => Ok(GeneratedField::Resname),
                            "ressortgroupref" => Ok(GeneratedField::Ressortgroupref),
                            "resorigtbl" => Ok(GeneratedField::Resorigtbl),
                            "resorigcol" => Ok(GeneratedField::Resorigcol),
                            "resjunk" => Ok(GeneratedField::Resjunk),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TargetEntry;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TargetEntry")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TargetEntry, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut expr__ = None;
                let mut resno__ = None;
                let mut resname__ = None;
                let mut ressortgroupref__ = None;
                let mut resorigtbl__ = None;
                let mut resorigcol__ = None;
                let mut resjunk__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Resno => {
                            if resno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resno"));
                            }
                            resno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resname => {
                            if resname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resname"));
                            }
                            resname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ressortgroupref => {
                            if ressortgroupref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ressortgroupref"));
                            }
                            ressortgroupref__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resorigtbl => {
                            if resorigtbl__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resorigtbl"));
                            }
                            resorigtbl__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resorigcol => {
                            if resorigcol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resorigcol"));
                            }
                            resorigcol__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Resjunk => {
                            if resjunk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resjunk"));
                            }
                            resjunk__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TargetEntry {
                    xpr: xpr__,
                    expr: expr__,
                    resno: resno__.unwrap_or_default(),
                    resname: resname__.unwrap_or_default(),
                    ressortgroupref: ressortgroupref__.unwrap_or_default(),
                    resorigtbl: resorigtbl__.unwrap_or_default(),
                    resorigcol: resorigcol__.unwrap_or_default(),
                    resjunk: resjunk__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TargetEntry", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Token {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Nul => "NUL",
            Self::Ascii36 => "ASCII_36",
            Self::Ascii37 => "ASCII_37",
            Self::Ascii40 => "ASCII_40",
            Self::Ascii41 => "ASCII_41",
            Self::Ascii42 => "ASCII_42",
            Self::Ascii43 => "ASCII_43",
            Self::Ascii44 => "ASCII_44",
            Self::Ascii45 => "ASCII_45",
            Self::Ascii46 => "ASCII_46",
            Self::Ascii47 => "ASCII_47",
            Self::Ascii58 => "ASCII_58",
            Self::Ascii59 => "ASCII_59",
            Self::Ascii60 => "ASCII_60",
            Self::Ascii61 => "ASCII_61",
            Self::Ascii62 => "ASCII_62",
            Self::Ascii63 => "ASCII_63",
            Self::Ascii91 => "ASCII_91",
            Self::Ascii92 => "ASCII_92",
            Self::Ascii93 => "ASCII_93",
            Self::Ascii94 => "ASCII_94",
            Self::Ident => "IDENT",
            Self::Uident => "UIDENT",
            Self::Fconst => "FCONST",
            Self::Sconst => "SCONST",
            Self::Usconst => "USCONST",
            Self::Bconst => "BCONST",
            Self::Xconst => "XCONST",
            Self::Op => "Op",
            Self::Iconst => "ICONST",
            Self::Param => "PARAM",
            Self::Typecast => "TYPECAST",
            Self::DotDot => "DOT_DOT",
            Self::ColonEquals => "COLON_EQUALS",
            Self::EqualsGreater => "EQUALS_GREATER",
            Self::LessEquals => "LESS_EQUALS",
            Self::GreaterEquals => "GREATER_EQUALS",
            Self::NotEquals => "NOT_EQUALS",
            Self::SqlComment => "SQL_COMMENT",
            Self::CComment => "C_COMMENT",
            Self::AbortP => "ABORT_P",
            Self::Absent => "ABSENT",
            Self::AbsoluteP => "ABSOLUTE_P",
            Self::Access => "ACCESS",
            Self::Action => "ACTION",
            Self::AddP => "ADD_P",
            Self::Admin => "ADMIN",
            Self::After => "AFTER",
            Self::Aggregate => "AGGREGATE",
            Self::All => "ALL",
            Self::Also => "ALSO",
            Self::Alter => "ALTER",
            Self::Always => "ALWAYS",
            Self::Analyse => "ANALYSE",
            Self::Analyze => "ANALYZE",
            Self::And => "AND",
            Self::Any => "ANY",
            Self::Array => "ARRAY",
            Self::As => "AS",
            Self::Asc => "ASC",
            Self::Asensitive => "ASENSITIVE",
            Self::Assertion => "ASSERTION",
            Self::Assignment => "ASSIGNMENT",
            Self::Asymmetric => "ASYMMETRIC",
            Self::Atomic => "ATOMIC",
            Self::At => "AT",
            Self::Attach => "ATTACH",
            Self::Attribute => "ATTRIBUTE",
            Self::Authorization => "AUTHORIZATION",
            Self::Backward => "BACKWARD",
            Self::Before => "BEFORE",
            Self::BeginP => "BEGIN_P",
            Self::Between => "BETWEEN",
            Self::Bigint => "BIGINT",
            Self::Binary => "BINARY",
            Self::Bit => "BIT",
            Self::BooleanP => "BOOLEAN_P",
            Self::Both => "BOTH",
            Self::Breadth => "BREADTH",
            Self::By => "BY",
            Self::Cache => "CACHE",
            Self::Call => "CALL",
            Self::Called => "CALLED",
            Self::Cascade => "CASCADE",
            Self::Cascaded => "CASCADED",
            Self::Case => "CASE",
            Self::Cast => "CAST",
            Self::CatalogP => "CATALOG_P",
            Self::Chain => "CHAIN",
            Self::CharP => "CHAR_P",
            Self::Character => "CHARACTER",
            Self::Characteristics => "CHARACTERISTICS",
            Self::Check => "CHECK",
            Self::Checkpoint => "CHECKPOINT",
            Self::Class => "CLASS",
            Self::Close => "CLOSE",
            Self::Cluster => "CLUSTER",
            Self::Coalesce => "COALESCE",
            Self::Collate => "COLLATE",
            Self::Collation => "COLLATION",
            Self::Column => "COLUMN",
            Self::Columns => "COLUMNS",
            Self::Comment => "COMMENT",
            Self::Comments => "COMMENTS",
            Self::Commit => "COMMIT",
            Self::Committed => "COMMITTED",
            Self::Compression => "COMPRESSION",
            Self::Concurrently => "CONCURRENTLY",
            Self::Configuration => "CONFIGURATION",
            Self::Conflict => "CONFLICT",
            Self::Connection => "CONNECTION",
            Self::Constraint => "CONSTRAINT",
            Self::Constraints => "CONSTRAINTS",
            Self::ContentP => "CONTENT_P",
            Self::ContinueP => "CONTINUE_P",
            Self::ConversionP => "CONVERSION_P",
            Self::Copy => "COPY",
            Self::Cost => "COST",
            Self::Create => "CREATE",
            Self::Cross => "CROSS",
            Self::Csv => "CSV",
            Self::Cube => "CUBE",
            Self::CurrentP => "CURRENT_P",
            Self::CurrentCatalog => "CURRENT_CATALOG",
            Self::CurrentDate => "CURRENT_DATE",
            Self::CurrentRole => "CURRENT_ROLE",
            Self::CurrentSchema => "CURRENT_SCHEMA",
            Self::CurrentTime => "CURRENT_TIME",
            Self::CurrentTimestamp => "CURRENT_TIMESTAMP",
            Self::CurrentUser => "CURRENT_USER",
            Self::Cursor => "CURSOR",
            Self::Cycle => "CYCLE",
            Self::DataP => "DATA_P",
            Self::Database => "DATABASE",
            Self::DayP => "DAY_P",
            Self::Deallocate => "DEALLOCATE",
            Self::Dec => "DEC",
            Self::DecimalP => "DECIMAL_P",
            Self::Declare => "DECLARE",
            Self::Default => "DEFAULT",
            Self::Defaults => "DEFAULTS",
            Self::Deferrable => "DEFERRABLE",
            Self::Deferred => "DEFERRED",
            Self::Definer => "DEFINER",
            Self::DeleteP => "DELETE_P",
            Self::Delimiter => "DELIMITER",
            Self::Delimiters => "DELIMITERS",
            Self::Depends => "DEPENDS",
            Self::Depth => "DEPTH",
            Self::Desc => "DESC",
            Self::Detach => "DETACH",
            Self::Dictionary => "DICTIONARY",
            Self::DisableP => "DISABLE_P",
            Self::Discard => "DISCARD",
            Self::Distinct => "DISTINCT",
            Self::Do => "DO",
            Self::DocumentP => "DOCUMENT_P",
            Self::DomainP => "DOMAIN_P",
            Self::DoubleP => "DOUBLE_P",
            Self::Drop => "DROP",
            Self::Each => "EACH",
            Self::Else => "ELSE",
            Self::EnableP => "ENABLE_P",
            Self::Encoding => "ENCODING",
            Self::Encrypted => "ENCRYPTED",
            Self::EndP => "END_P",
            Self::EnumP => "ENUM_P",
            Self::Escape => "ESCAPE",
            Self::Event => "EVENT",
            Self::Except => "EXCEPT",
            Self::Exclude => "EXCLUDE",
            Self::Excluding => "EXCLUDING",
            Self::Exclusive => "EXCLUSIVE",
            Self::Execute => "EXECUTE",
            Self::Exists => "EXISTS",
            Self::Explain => "EXPLAIN",
            Self::Expression => "EXPRESSION",
            Self::Extension => "EXTENSION",
            Self::External => "EXTERNAL",
            Self::Extract => "EXTRACT",
            Self::FalseP => "FALSE_P",
            Self::Family => "FAMILY",
            Self::Fetch => "FETCH",
            Self::Filter => "FILTER",
            Self::Finalize => "FINALIZE",
            Self::FirstP => "FIRST_P",
            Self::FloatP => "FLOAT_P",
            Self::Following => "FOLLOWING",
            Self::For => "FOR",
            Self::Force => "FORCE",
            Self::Foreign => "FOREIGN",
            Self::Format => "FORMAT",
            Self::Forward => "FORWARD",
            Self::Freeze => "FREEZE",
            Self::From => "FROM",
            Self::Full => "FULL",
            Self::Function => "FUNCTION",
            Self::Functions => "FUNCTIONS",
            Self::Generated => "GENERATED",
            Self::Global => "GLOBAL",
            Self::Grant => "GRANT",
            Self::Granted => "GRANTED",
            Self::Greatest => "GREATEST",
            Self::GroupP => "GROUP_P",
            Self::Grouping => "GROUPING",
            Self::Groups => "GROUPS",
            Self::Handler => "HANDLER",
            Self::Having => "HAVING",
            Self::HeaderP => "HEADER_P",
            Self::Hold => "HOLD",
            Self::HourP => "HOUR_P",
            Self::IdentityP => "IDENTITY_P",
            Self::IfP => "IF_P",
            Self::Ilike => "ILIKE",
            Self::Immediate => "IMMEDIATE",
            Self::Immutable => "IMMUTABLE",
            Self::ImplicitP => "IMPLICIT_P",
            Self::ImportP => "IMPORT_P",
            Self::InP => "IN_P",
            Self::Include => "INCLUDE",
            Self::Including => "INCLUDING",
            Self::Increment => "INCREMENT",
            Self::Indent => "INDENT",
            Self::Index => "INDEX",
            Self::Indexes => "INDEXES",
            Self::Inherit => "INHERIT",
            Self::Inherits => "INHERITS",
            Self::Initially => "INITIALLY",
            Self::InlineP => "INLINE_P",
            Self::InnerP => "INNER_P",
            Self::Inout => "INOUT",
            Self::InputP => "INPUT_P",
            Self::Insensitive => "INSENSITIVE",
            Self::Insert => "INSERT",
            Self::Instead => "INSTEAD",
            Self::IntP => "INT_P",
            Self::Integer => "INTEGER",
            Self::Intersect => "INTERSECT",
            Self::Interval => "INTERVAL",
            Self::Into => "INTO",
            Self::Invoker => "INVOKER",
            Self::Is => "IS",
            Self::Isnull => "ISNULL",
            Self::Isolation => "ISOLATION",
            Self::Join => "JOIN",
            Self::Json => "JSON",
            Self::JsonArray => "JSON_ARRAY",
            Self::JsonArrayagg => "JSON_ARRAYAGG",
            Self::JsonObject => "JSON_OBJECT",
            Self::JsonObjectagg => "JSON_OBJECTAGG",
            Self::Key => "KEY",
            Self::Keys => "KEYS",
            Self::Label => "LABEL",
            Self::Language => "LANGUAGE",
            Self::LargeP => "LARGE_P",
            Self::LastP => "LAST_P",
            Self::LateralP => "LATERAL_P",
            Self::Leading => "LEADING",
            Self::Leakproof => "LEAKPROOF",
            Self::Least => "LEAST",
            Self::Left => "LEFT",
            Self::Level => "LEVEL",
            Self::Like => "LIKE",
            Self::Limit => "LIMIT",
            Self::Listen => "LISTEN",
            Self::Load => "LOAD",
            Self::Local => "LOCAL",
            Self::Localtime => "LOCALTIME",
            Self::Localtimestamp => "LOCALTIMESTAMP",
            Self::Location => "LOCATION",
            Self::LockP => "LOCK_P",
            Self::Locked => "LOCKED",
            Self::Logged => "LOGGED",
            Self::Mapping => "MAPPING",
            Self::Match => "MATCH",
            Self::Matched => "MATCHED",
            Self::Materialized => "MATERIALIZED",
            Self::Maxvalue => "MAXVALUE",
            Self::Merge => "MERGE",
            Self::Method => "METHOD",
            Self::MinuteP => "MINUTE_P",
            Self::Minvalue => "MINVALUE",
            Self::Mode => "MODE",
            Self::MonthP => "MONTH_P",
            Self::Move => "MOVE",
            Self::NameP => "NAME_P",
            Self::Names => "NAMES",
            Self::National => "NATIONAL",
            Self::Natural => "NATURAL",
            Self::Nchar => "NCHAR",
            Self::New => "NEW",
            Self::Next => "NEXT",
            Self::Nfc => "NFC",
            Self::Nfd => "NFD",
            Self::Nfkc => "NFKC",
            Self::Nfkd => "NFKD",
            Self::No => "NO",
            Self::None => "NONE",
            Self::Normalize => "NORMALIZE",
            Self::Normalized => "NORMALIZED",
            Self::Not => "NOT",
            Self::Nothing => "NOTHING",
            Self::Notify => "NOTIFY",
            Self::Notnull => "NOTNULL",
            Self::Nowait => "NOWAIT",
            Self::NullP => "NULL_P",
            Self::Nullif => "NULLIF",
            Self::NullsP => "NULLS_P",
            Self::Numeric => "NUMERIC",
            Self::ObjectP => "OBJECT_P",
            Self::Of => "OF",
            Self::Off => "OFF",
            Self::Offset => "OFFSET",
            Self::Oids => "OIDS",
            Self::Old => "OLD",
            Self::On => "ON",
            Self::Only => "ONLY",
            Self::Operator => "OPERATOR",
            Self::Option => "OPTION",
            Self::Options => "OPTIONS",
            Self::Or => "OR",
            Self::Order => "ORDER",
            Self::Ordinality => "ORDINALITY",
            Self::Others => "OTHERS",
            Self::OutP => "OUT_P",
            Self::OuterP => "OUTER_P",
            Self::Over => "OVER",
            Self::Overlaps => "OVERLAPS",
            Self::Overlay => "OVERLAY",
            Self::Overriding => "OVERRIDING",
            Self::Owned => "OWNED",
            Self::Owner => "OWNER",
            Self::Parallel => "PARALLEL",
            Self::Parameter => "PARAMETER",
            Self::Parser => "PARSER",
            Self::Partial => "PARTIAL",
            Self::Partition => "PARTITION",
            Self::Passing => "PASSING",
            Self::Password => "PASSWORD",
            Self::Placing => "PLACING",
            Self::Plans => "PLANS",
            Self::Policy => "POLICY",
            Self::Position => "POSITION",
            Self::Preceding => "PRECEDING",
            Self::Precision => "PRECISION",
            Self::Preserve => "PRESERVE",
            Self::Prepare => "PREPARE",
            Self::Prepared => "PREPARED",
            Self::Primary => "PRIMARY",
            Self::Prior => "PRIOR",
            Self::Privileges => "PRIVILEGES",
            Self::Procedural => "PROCEDURAL",
            Self::Procedure => "PROCEDURE",
            Self::Procedures => "PROCEDURES",
            Self::Program => "PROGRAM",
            Self::Publication => "PUBLICATION",
            Self::Quote => "QUOTE",
            Self::Range => "RANGE",
            Self::Read => "READ",
            Self::Real => "REAL",
            Self::Reassign => "REASSIGN",
            Self::Recheck => "RECHECK",
            Self::Recursive => "RECURSIVE",
            Self::RefP => "REF_P",
            Self::References => "REFERENCES",
            Self::Referencing => "REFERENCING",
            Self::Refresh => "REFRESH",
            Self::Reindex => "REINDEX",
            Self::RelativeP => "RELATIVE_P",
            Self::Release => "RELEASE",
            Self::Rename => "RENAME",
            Self::Repeatable => "REPEATABLE",
            Self::Replace => "REPLACE",
            Self::Replica => "REPLICA",
            Self::Reset => "RESET",
            Self::Restart => "RESTART",
            Self::Restrict => "RESTRICT",
            Self::Return => "RETURN",
            Self::Returning => "RETURNING",
            Self::Returns => "RETURNS",
            Self::Revoke => "REVOKE",
            Self::Right => "RIGHT",
            Self::Role => "ROLE",
            Self::Rollback => "ROLLBACK",
            Self::Rollup => "ROLLUP",
            Self::Routine => "ROUTINE",
            Self::Routines => "ROUTINES",
            Self::Row => "ROW",
            Self::Rows => "ROWS",
            Self::Rule => "RULE",
            Self::Savepoint => "SAVEPOINT",
            Self::Scalar => "SCALAR",
            Self::Schema => "SCHEMA",
            Self::Schemas => "SCHEMAS",
            Self::Scroll => "SCROLL",
            Self::Search => "SEARCH",
            Self::SecondP => "SECOND_P",
            Self::Security => "SECURITY",
            Self::Select => "SELECT",
            Self::Sequence => "SEQUENCE",
            Self::Sequences => "SEQUENCES",
            Self::Serializable => "SERIALIZABLE",
            Self::Server => "SERVER",
            Self::Session => "SESSION",
            Self::SessionUser => "SESSION_USER",
            Self::Set => "SET",
            Self::Sets => "SETS",
            Self::Setof => "SETOF",
            Self::Share => "SHARE",
            Self::Show => "SHOW",
            Self::Similar => "SIMILAR",
            Self::Simple => "SIMPLE",
            Self::Skip => "SKIP",
            Self::Smallint => "SMALLINT",
            Self::Snapshot => "SNAPSHOT",
            Self::Some => "SOME",
            Self::SqlP => "SQL_P",
            Self::Stable => "STABLE",
            Self::StandaloneP => "STANDALONE_P",
            Self::Start => "START",
            Self::Statement => "STATEMENT",
            Self::Statistics => "STATISTICS",
            Self::Stdin => "STDIN",
            Self::Stdout => "STDOUT",
            Self::Storage => "STORAGE",
            Self::Stored => "STORED",
            Self::StrictP => "STRICT_P",
            Self::StripP => "STRIP_P",
            Self::Subscription => "SUBSCRIPTION",
            Self::Substring => "SUBSTRING",
            Self::Support => "SUPPORT",
            Self::Symmetric => "SYMMETRIC",
            Self::Sysid => "SYSID",
            Self::SystemP => "SYSTEM_P",
            Self::SystemUser => "SYSTEM_USER",
            Self::Table => "TABLE",
            Self::Tables => "TABLES",
            Self::Tablesample => "TABLESAMPLE",
            Self::Tablespace => "TABLESPACE",
            Self::Temp => "TEMP",
            Self::Template => "TEMPLATE",
            Self::Temporary => "TEMPORARY",
            Self::TextP => "TEXT_P",
            Self::Then => "THEN",
            Self::Ties => "TIES",
            Self::Time => "TIME",
            Self::Timestamp => "TIMESTAMP",
            Self::To => "TO",
            Self::Trailing => "TRAILING",
            Self::Transaction => "TRANSACTION",
            Self::Transform => "TRANSFORM",
            Self::Treat => "TREAT",
            Self::Trigger => "TRIGGER",
            Self::Trim => "TRIM",
            Self::TrueP => "TRUE_P",
            Self::Truncate => "TRUNCATE",
            Self::Trusted => "TRUSTED",
            Self::TypeP => "TYPE_P",
            Self::TypesP => "TYPES_P",
            Self::Uescape => "UESCAPE",
            Self::Unbounded => "UNBOUNDED",
            Self::Uncommitted => "UNCOMMITTED",
            Self::Unencrypted => "UNENCRYPTED",
            Self::Union => "UNION",
            Self::Unique => "UNIQUE",
            Self::Unknown => "UNKNOWN",
            Self::Unlisten => "UNLISTEN",
            Self::Unlogged => "UNLOGGED",
            Self::Until => "UNTIL",
            Self::Update => "UPDATE",
            Self::User => "USER",
            Self::Using => "USING",
            Self::Vacuum => "VACUUM",
            Self::Valid => "VALID",
            Self::Validate => "VALIDATE",
            Self::Validator => "VALIDATOR",
            Self::ValueP => "VALUE_P",
            Self::Values => "VALUES",
            Self::Varchar => "VARCHAR",
            Self::Variadic => "VARIADIC",
            Self::Varying => "VARYING",
            Self::Verbose => "VERBOSE",
            Self::VersionP => "VERSION_P",
            Self::View => "VIEW",
            Self::Views => "VIEWS",
            Self::Volatile => "VOLATILE",
            Self::When => "WHEN",
            Self::Where => "WHERE",
            Self::WhitespaceP => "WHITESPACE_P",
            Self::Window => "WINDOW",
            Self::With => "WITH",
            Self::Within => "WITHIN",
            Self::Without => "WITHOUT",
            Self::Work => "WORK",
            Self::Wrapper => "WRAPPER",
            Self::Write => "WRITE",
            Self::XmlP => "XML_P",
            Self::Xmlattributes => "XMLATTRIBUTES",
            Self::Xmlconcat => "XMLCONCAT",
            Self::Xmlelement => "XMLELEMENT",
            Self::Xmlexists => "XMLEXISTS",
            Self::Xmlforest => "XMLFOREST",
            Self::Xmlnamespaces => "XMLNAMESPACES",
            Self::Xmlparse => "XMLPARSE",
            Self::Xmlpi => "XMLPI",
            Self::Xmlroot => "XMLROOT",
            Self::Xmlserialize => "XMLSERIALIZE",
            Self::Xmltable => "XMLTABLE",
            Self::YearP => "YEAR_P",
            Self::YesP => "YES_P",
            Self::Zone => "ZONE",
            Self::FormatLa => "FORMAT_LA",
            Self::NotLa => "NOT_LA",
            Self::NullsLa => "NULLS_LA",
            Self::WithLa => "WITH_LA",
            Self::WithoutLa => "WITHOUT_LA",
            Self::ModeTypeName => "MODE_TYPE_NAME",
            Self::ModePlpgsqlExpr => "MODE_PLPGSQL_EXPR",
            Self::ModePlpgsqlAssign1 => "MODE_PLPGSQL_ASSIGN1",
            Self::ModePlpgsqlAssign2 => "MODE_PLPGSQL_ASSIGN2",
            Self::ModePlpgsqlAssign3 => "MODE_PLPGSQL_ASSIGN3",
            Self::Uminus => "UMINUS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for Token {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NUL",
            "ASCII_36",
            "ASCII_37",
            "ASCII_40",
            "ASCII_41",
            "ASCII_42",
            "ASCII_43",
            "ASCII_44",
            "ASCII_45",
            "ASCII_46",
            "ASCII_47",
            "ASCII_58",
            "ASCII_59",
            "ASCII_60",
            "ASCII_61",
            "ASCII_62",
            "ASCII_63",
            "ASCII_91",
            "ASCII_92",
            "ASCII_93",
            "ASCII_94",
            "IDENT",
            "UIDENT",
            "FCONST",
            "SCONST",
            "USCONST",
            "BCONST",
            "XCONST",
            "Op",
            "ICONST",
            "PARAM",
            "TYPECAST",
            "DOT_DOT",
            "COLON_EQUALS",
            "EQUALS_GREATER",
            "LESS_EQUALS",
            "GREATER_EQUALS",
            "NOT_EQUALS",
            "SQL_COMMENT",
            "C_COMMENT",
            "ABORT_P",
            "ABSENT",
            "ABSOLUTE_P",
            "ACCESS",
            "ACTION",
            "ADD_P",
            "ADMIN",
            "AFTER",
            "AGGREGATE",
            "ALL",
            "ALSO",
            "ALTER",
            "ALWAYS",
            "ANALYSE",
            "ANALYZE",
            "AND",
            "ANY",
            "ARRAY",
            "AS",
            "ASC",
            "ASENSITIVE",
            "ASSERTION",
            "ASSIGNMENT",
            "ASYMMETRIC",
            "ATOMIC",
            "AT",
            "ATTACH",
            "ATTRIBUTE",
            "AUTHORIZATION",
            "BACKWARD",
            "BEFORE",
            "BEGIN_P",
            "BETWEEN",
            "BIGINT",
            "BINARY",
            "BIT",
            "BOOLEAN_P",
            "BOTH",
            "BREADTH",
            "BY",
            "CACHE",
            "CALL",
            "CALLED",
            "CASCADE",
            "CASCADED",
            "CASE",
            "CAST",
            "CATALOG_P",
            "CHAIN",
            "CHAR_P",
            "CHARACTER",
            "CHARACTERISTICS",
            "CHECK",
            "CHECKPOINT",
            "CLASS",
            "CLOSE",
            "CLUSTER",
            "COALESCE",
            "COLLATE",
            "COLLATION",
            "COLUMN",
            "COLUMNS",
            "COMMENT",
            "COMMENTS",
            "COMMIT",
            "COMMITTED",
            "COMPRESSION",
            "CONCURRENTLY",
            "CONFIGURATION",
            "CONFLICT",
            "CONNECTION",
            "CONSTRAINT",
            "CONSTRAINTS",
            "CONTENT_P",
            "CONTINUE_P",
            "CONVERSION_P",
            "COPY",
            "COST",
            "CREATE",
            "CROSS",
            "CSV",
            "CUBE",
            "CURRENT_P",
            "CURRENT_CATALOG",
            "CURRENT_DATE",
            "CURRENT_ROLE",
            "CURRENT_SCHEMA",
            "CURRENT_TIME",
            "CURRENT_TIMESTAMP",
            "CURRENT_USER",
            "CURSOR",
            "CYCLE",
            "DATA_P",
            "DATABASE",
            "DAY_P",
            "DEALLOCATE",
            "DEC",
            "DECIMAL_P",
            "DECLARE",
            "DEFAULT",
            "DEFAULTS",
            "DEFERRABLE",
            "DEFERRED",
            "DEFINER",
            "DELETE_P",
            "DELIMITER",
            "DELIMITERS",
            "DEPENDS",
            "DEPTH",
            "DESC",
            "DETACH",
            "DICTIONARY",
            "DISABLE_P",
            "DISCARD",
            "DISTINCT",
            "DO",
            "DOCUMENT_P",
            "DOMAIN_P",
            "DOUBLE_P",
            "DROP",
            "EACH",
            "ELSE",
            "ENABLE_P",
            "ENCODING",
            "ENCRYPTED",
            "END_P",
            "ENUM_P",
            "ESCAPE",
            "EVENT",
            "EXCEPT",
            "EXCLUDE",
            "EXCLUDING",
            "EXCLUSIVE",
            "EXECUTE",
            "EXISTS",
            "EXPLAIN",
            "EXPRESSION",
            "EXTENSION",
            "EXTERNAL",
            "EXTRACT",
            "FALSE_P",
            "FAMILY",
            "FETCH",
            "FILTER",
            "FINALIZE",
            "FIRST_P",
            "FLOAT_P",
            "FOLLOWING",
            "FOR",
            "FORCE",
            "FOREIGN",
            "FORMAT",
            "FORWARD",
            "FREEZE",
            "FROM",
            "FULL",
            "FUNCTION",
            "FUNCTIONS",
            "GENERATED",
            "GLOBAL",
            "GRANT",
            "GRANTED",
            "GREATEST",
            "GROUP_P",
            "GROUPING",
            "GROUPS",
            "HANDLER",
            "HAVING",
            "HEADER_P",
            "HOLD",
            "HOUR_P",
            "IDENTITY_P",
            "IF_P",
            "ILIKE",
            "IMMEDIATE",
            "IMMUTABLE",
            "IMPLICIT_P",
            "IMPORT_P",
            "IN_P",
            "INCLUDE",
            "INCLUDING",
            "INCREMENT",
            "INDENT",
            "INDEX",
            "INDEXES",
            "INHERIT",
            "INHERITS",
            "INITIALLY",
            "INLINE_P",
            "INNER_P",
            "INOUT",
            "INPUT_P",
            "INSENSITIVE",
            "INSERT",
            "INSTEAD",
            "INT_P",
            "INTEGER",
            "INTERSECT",
            "INTERVAL",
            "INTO",
            "INVOKER",
            "IS",
            "ISNULL",
            "ISOLATION",
            "JOIN",
            "JSON",
            "JSON_ARRAY",
            "JSON_ARRAYAGG",
            "JSON_OBJECT",
            "JSON_OBJECTAGG",
            "KEY",
            "KEYS",
            "LABEL",
            "LANGUAGE",
            "LARGE_P",
            "LAST_P",
            "LATERAL_P",
            "LEADING",
            "LEAKPROOF",
            "LEAST",
            "LEFT",
            "LEVEL",
            "LIKE",
            "LIMIT",
            "LISTEN",
            "LOAD",
            "LOCAL",
            "LOCALTIME",
            "LOCALTIMESTAMP",
            "LOCATION",
            "LOCK_P",
            "LOCKED",
            "LOGGED",
            "MAPPING",
            "MATCH",
            "MATCHED",
            "MATERIALIZED",
            "MAXVALUE",
            "MERGE",
            "METHOD",
            "MINUTE_P",
            "MINVALUE",
            "MODE",
            "MONTH_P",
            "MOVE",
            "NAME_P",
            "NAMES",
            "NATIONAL",
            "NATURAL",
            "NCHAR",
            "NEW",
            "NEXT",
            "NFC",
            "NFD",
            "NFKC",
            "NFKD",
            "NO",
            "NONE",
            "NORMALIZE",
            "NORMALIZED",
            "NOT",
            "NOTHING",
            "NOTIFY",
            "NOTNULL",
            "NOWAIT",
            "NULL_P",
            "NULLIF",
            "NULLS_P",
            "NUMERIC",
            "OBJECT_P",
            "OF",
            "OFF",
            "OFFSET",
            "OIDS",
            "OLD",
            "ON",
            "ONLY",
            "OPERATOR",
            "OPTION",
            "OPTIONS",
            "OR",
            "ORDER",
            "ORDINALITY",
            "OTHERS",
            "OUT_P",
            "OUTER_P",
            "OVER",
            "OVERLAPS",
            "OVERLAY",
            "OVERRIDING",
            "OWNED",
            "OWNER",
            "PARALLEL",
            "PARAMETER",
            "PARSER",
            "PARTIAL",
            "PARTITION",
            "PASSING",
            "PASSWORD",
            "PLACING",
            "PLANS",
            "POLICY",
            "POSITION",
            "PRECEDING",
            "PRECISION",
            "PRESERVE",
            "PREPARE",
            "PREPARED",
            "PRIMARY",
            "PRIOR",
            "PRIVILEGES",
            "PROCEDURAL",
            "PROCEDURE",
            "PROCEDURES",
            "PROGRAM",
            "PUBLICATION",
            "QUOTE",
            "RANGE",
            "READ",
            "REAL",
            "REASSIGN",
            "RECHECK",
            "RECURSIVE",
            "REF_P",
            "REFERENCES",
            "REFERENCING",
            "REFRESH",
            "REINDEX",
            "RELATIVE_P",
            "RELEASE",
            "RENAME",
            "REPEATABLE",
            "REPLACE",
            "REPLICA",
            "RESET",
            "RESTART",
            "RESTRICT",
            "RETURN",
            "RETURNING",
            "RETURNS",
            "REVOKE",
            "RIGHT",
            "ROLE",
            "ROLLBACK",
            "ROLLUP",
            "ROUTINE",
            "ROUTINES",
            "ROW",
            "ROWS",
            "RULE",
            "SAVEPOINT",
            "SCALAR",
            "SCHEMA",
            "SCHEMAS",
            "SCROLL",
            "SEARCH",
            "SECOND_P",
            "SECURITY",
            "SELECT",
            "SEQUENCE",
            "SEQUENCES",
            "SERIALIZABLE",
            "SERVER",
            "SESSION",
            "SESSION_USER",
            "SET",
            "SETS",
            "SETOF",
            "SHARE",
            "SHOW",
            "SIMILAR",
            "SIMPLE",
            "SKIP",
            "SMALLINT",
            "SNAPSHOT",
            "SOME",
            "SQL_P",
            "STABLE",
            "STANDALONE_P",
            "START",
            "STATEMENT",
            "STATISTICS",
            "STDIN",
            "STDOUT",
            "STORAGE",
            "STORED",
            "STRICT_P",
            "STRIP_P",
            "SUBSCRIPTION",
            "SUBSTRING",
            "SUPPORT",
            "SYMMETRIC",
            "SYSID",
            "SYSTEM_P",
            "SYSTEM_USER",
            "TABLE",
            "TABLES",
            "TABLESAMPLE",
            "TABLESPACE",
            "TEMP",
            "TEMPLATE",
            "TEMPORARY",
            "TEXT_P",
            "THEN",
            "TIES",
            "TIME",
            "TIMESTAMP",
            "TO",
            "TRAILING",
            "TRANSACTION",
            "TRANSFORM",
            "TREAT",
            "TRIGGER",
            "TRIM",
            "TRUE_P",
            "TRUNCATE",
            "TRUSTED",
            "TYPE_P",
            "TYPES_P",
            "UESCAPE",
            "UNBOUNDED",
            "UNCOMMITTED",
            "UNENCRYPTED",
            "UNION",
            "UNIQUE",
            "UNKNOWN",
            "UNLISTEN",
            "UNLOGGED",
            "UNTIL",
            "UPDATE",
            "USER",
            "USING",
            "VACUUM",
            "VALID",
            "VALIDATE",
            "VALIDATOR",
            "VALUE_P",
            "VALUES",
            "VARCHAR",
            "VARIADIC",
            "VARYING",
            "VERBOSE",
            "VERSION_P",
            "VIEW",
            "VIEWS",
            "VOLATILE",
            "WHEN",
            "WHERE",
            "WHITESPACE_P",
            "WINDOW",
            "WITH",
            "WITHIN",
            "WITHOUT",
            "WORK",
            "WRAPPER",
            "WRITE",
            "XML_P",
            "XMLATTRIBUTES",
            "XMLCONCAT",
            "XMLELEMENT",
            "XMLEXISTS",
            "XMLFOREST",
            "XMLNAMESPACES",
            "XMLPARSE",
            "XMLPI",
            "XMLROOT",
            "XMLSERIALIZE",
            "XMLTABLE",
            "YEAR_P",
            "YES_P",
            "ZONE",
            "FORMAT_LA",
            "NOT_LA",
            "NULLS_LA",
            "WITH_LA",
            "WITHOUT_LA",
            "MODE_TYPE_NAME",
            "MODE_PLPGSQL_EXPR",
            "MODE_PLPGSQL_ASSIGN1",
            "MODE_PLPGSQL_ASSIGN2",
            "MODE_PLPGSQL_ASSIGN3",
            "UMINUS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Token;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NUL" => Ok(Token::Nul),
                    "ASCII_36" => Ok(Token::Ascii36),
                    "ASCII_37" => Ok(Token::Ascii37),
                    "ASCII_40" => Ok(Token::Ascii40),
                    "ASCII_41" => Ok(Token::Ascii41),
                    "ASCII_42" => Ok(Token::Ascii42),
                    "ASCII_43" => Ok(Token::Ascii43),
                    "ASCII_44" => Ok(Token::Ascii44),
                    "ASCII_45" => Ok(Token::Ascii45),
                    "ASCII_46" => Ok(Token::Ascii46),
                    "ASCII_47" => Ok(Token::Ascii47),
                    "ASCII_58" => Ok(Token::Ascii58),
                    "ASCII_59" => Ok(Token::Ascii59),
                    "ASCII_60" => Ok(Token::Ascii60),
                    "ASCII_61" => Ok(Token::Ascii61),
                    "ASCII_62" => Ok(Token::Ascii62),
                    "ASCII_63" => Ok(Token::Ascii63),
                    "ASCII_91" => Ok(Token::Ascii91),
                    "ASCII_92" => Ok(Token::Ascii92),
                    "ASCII_93" => Ok(Token::Ascii93),
                    "ASCII_94" => Ok(Token::Ascii94),
                    "IDENT" => Ok(Token::Ident),
                    "UIDENT" => Ok(Token::Uident),
                    "FCONST" => Ok(Token::Fconst),
                    "SCONST" => Ok(Token::Sconst),
                    "USCONST" => Ok(Token::Usconst),
                    "BCONST" => Ok(Token::Bconst),
                    "XCONST" => Ok(Token::Xconst),
                    "Op" => Ok(Token::Op),
                    "ICONST" => Ok(Token::Iconst),
                    "PARAM" => Ok(Token::Param),
                    "TYPECAST" => Ok(Token::Typecast),
                    "DOT_DOT" => Ok(Token::DotDot),
                    "COLON_EQUALS" => Ok(Token::ColonEquals),
                    "EQUALS_GREATER" => Ok(Token::EqualsGreater),
                    "LESS_EQUALS" => Ok(Token::LessEquals),
                    "GREATER_EQUALS" => Ok(Token::GreaterEquals),
                    "NOT_EQUALS" => Ok(Token::NotEquals),
                    "SQL_COMMENT" => Ok(Token::SqlComment),
                    "C_COMMENT" => Ok(Token::CComment),
                    "ABORT_P" => Ok(Token::AbortP),
                    "ABSENT" => Ok(Token::Absent),
                    "ABSOLUTE_P" => Ok(Token::AbsoluteP),
                    "ACCESS" => Ok(Token::Access),
                    "ACTION" => Ok(Token::Action),
                    "ADD_P" => Ok(Token::AddP),
                    "ADMIN" => Ok(Token::Admin),
                    "AFTER" => Ok(Token::After),
                    "AGGREGATE" => Ok(Token::Aggregate),
                    "ALL" => Ok(Token::All),
                    "ALSO" => Ok(Token::Also),
                    "ALTER" => Ok(Token::Alter),
                    "ALWAYS" => Ok(Token::Always),
                    "ANALYSE" => Ok(Token::Analyse),
                    "ANALYZE" => Ok(Token::Analyze),
                    "AND" => Ok(Token::And),
                    "ANY" => Ok(Token::Any),
                    "ARRAY" => Ok(Token::Array),
                    "AS" => Ok(Token::As),
                    "ASC" => Ok(Token::Asc),
                    "ASENSITIVE" => Ok(Token::Asensitive),
                    "ASSERTION" => Ok(Token::Assertion),
                    "ASSIGNMENT" => Ok(Token::Assignment),
                    "ASYMMETRIC" => Ok(Token::Asymmetric),
                    "ATOMIC" => Ok(Token::Atomic),
                    "AT" => Ok(Token::At),
                    "ATTACH" => Ok(Token::Attach),
                    "ATTRIBUTE" => Ok(Token::Attribute),
                    "AUTHORIZATION" => Ok(Token::Authorization),
                    "BACKWARD" => Ok(Token::Backward),
                    "BEFORE" => Ok(Token::Before),
                    "BEGIN_P" => Ok(Token::BeginP),
                    "BETWEEN" => Ok(Token::Between),
                    "BIGINT" => Ok(Token::Bigint),
                    "BINARY" => Ok(Token::Binary),
                    "BIT" => Ok(Token::Bit),
                    "BOOLEAN_P" => Ok(Token::BooleanP),
                    "BOTH" => Ok(Token::Both),
                    "BREADTH" => Ok(Token::Breadth),
                    "BY" => Ok(Token::By),
                    "CACHE" => Ok(Token::Cache),
                    "CALL" => Ok(Token::Call),
                    "CALLED" => Ok(Token::Called),
                    "CASCADE" => Ok(Token::Cascade),
                    "CASCADED" => Ok(Token::Cascaded),
                    "CASE" => Ok(Token::Case),
                    "CAST" => Ok(Token::Cast),
                    "CATALOG_P" => Ok(Token::CatalogP),
                    "CHAIN" => Ok(Token::Chain),
                    "CHAR_P" => Ok(Token::CharP),
                    "CHARACTER" => Ok(Token::Character),
                    "CHARACTERISTICS" => Ok(Token::Characteristics),
                    "CHECK" => Ok(Token::Check),
                    "CHECKPOINT" => Ok(Token::Checkpoint),
                    "CLASS" => Ok(Token::Class),
                    "CLOSE" => Ok(Token::Close),
                    "CLUSTER" => Ok(Token::Cluster),
                    "COALESCE" => Ok(Token::Coalesce),
                    "COLLATE" => Ok(Token::Collate),
                    "COLLATION" => Ok(Token::Collation),
                    "COLUMN" => Ok(Token::Column),
                    "COLUMNS" => Ok(Token::Columns),
                    "COMMENT" => Ok(Token::Comment),
                    "COMMENTS" => Ok(Token::Comments),
                    "COMMIT" => Ok(Token::Commit),
                    "COMMITTED" => Ok(Token::Committed),
                    "COMPRESSION" => Ok(Token::Compression),
                    "CONCURRENTLY" => Ok(Token::Concurrently),
                    "CONFIGURATION" => Ok(Token::Configuration),
                    "CONFLICT" => Ok(Token::Conflict),
                    "CONNECTION" => Ok(Token::Connection),
                    "CONSTRAINT" => Ok(Token::Constraint),
                    "CONSTRAINTS" => Ok(Token::Constraints),
                    "CONTENT_P" => Ok(Token::ContentP),
                    "CONTINUE_P" => Ok(Token::ContinueP),
                    "CONVERSION_P" => Ok(Token::ConversionP),
                    "COPY" => Ok(Token::Copy),
                    "COST" => Ok(Token::Cost),
                    "CREATE" => Ok(Token::Create),
                    "CROSS" => Ok(Token::Cross),
                    "CSV" => Ok(Token::Csv),
                    "CUBE" => Ok(Token::Cube),
                    "CURRENT_P" => Ok(Token::CurrentP),
                    "CURRENT_CATALOG" => Ok(Token::CurrentCatalog),
                    "CURRENT_DATE" => Ok(Token::CurrentDate),
                    "CURRENT_ROLE" => Ok(Token::CurrentRole),
                    "CURRENT_SCHEMA" => Ok(Token::CurrentSchema),
                    "CURRENT_TIME" => Ok(Token::CurrentTime),
                    "CURRENT_TIMESTAMP" => Ok(Token::CurrentTimestamp),
                    "CURRENT_USER" => Ok(Token::CurrentUser),
                    "CURSOR" => Ok(Token::Cursor),
                    "CYCLE" => Ok(Token::Cycle),
                    "DATA_P" => Ok(Token::DataP),
                    "DATABASE" => Ok(Token::Database),
                    "DAY_P" => Ok(Token::DayP),
                    "DEALLOCATE" => Ok(Token::Deallocate),
                    "DEC" => Ok(Token::Dec),
                    "DECIMAL_P" => Ok(Token::DecimalP),
                    "DECLARE" => Ok(Token::Declare),
                    "DEFAULT" => Ok(Token::Default),
                    "DEFAULTS" => Ok(Token::Defaults),
                    "DEFERRABLE" => Ok(Token::Deferrable),
                    "DEFERRED" => Ok(Token::Deferred),
                    "DEFINER" => Ok(Token::Definer),
                    "DELETE_P" => Ok(Token::DeleteP),
                    "DELIMITER" => Ok(Token::Delimiter),
                    "DELIMITERS" => Ok(Token::Delimiters),
                    "DEPENDS" => Ok(Token::Depends),
                    "DEPTH" => Ok(Token::Depth),
                    "DESC" => Ok(Token::Desc),
                    "DETACH" => Ok(Token::Detach),
                    "DICTIONARY" => Ok(Token::Dictionary),
                    "DISABLE_P" => Ok(Token::DisableP),
                    "DISCARD" => Ok(Token::Discard),
                    "DISTINCT" => Ok(Token::Distinct),
                    "DO" => Ok(Token::Do),
                    "DOCUMENT_P" => Ok(Token::DocumentP),
                    "DOMAIN_P" => Ok(Token::DomainP),
                    "DOUBLE_P" => Ok(Token::DoubleP),
                    "DROP" => Ok(Token::Drop),
                    "EACH" => Ok(Token::Each),
                    "ELSE" => Ok(Token::Else),
                    "ENABLE_P" => Ok(Token::EnableP),
                    "ENCODING" => Ok(Token::Encoding),
                    "ENCRYPTED" => Ok(Token::Encrypted),
                    "END_P" => Ok(Token::EndP),
                    "ENUM_P" => Ok(Token::EnumP),
                    "ESCAPE" => Ok(Token::Escape),
                    "EVENT" => Ok(Token::Event),
                    "EXCEPT" => Ok(Token::Except),
                    "EXCLUDE" => Ok(Token::Exclude),
                    "EXCLUDING" => Ok(Token::Excluding),
                    "EXCLUSIVE" => Ok(Token::Exclusive),
                    "EXECUTE" => Ok(Token::Execute),
                    "EXISTS" => Ok(Token::Exists),
                    "EXPLAIN" => Ok(Token::Explain),
                    "EXPRESSION" => Ok(Token::Expression),
                    "EXTENSION" => Ok(Token::Extension),
                    "EXTERNAL" => Ok(Token::External),
                    "EXTRACT" => Ok(Token::Extract),
                    "FALSE_P" => Ok(Token::FalseP),
                    "FAMILY" => Ok(Token::Family),
                    "FETCH" => Ok(Token::Fetch),
                    "FILTER" => Ok(Token::Filter),
                    "FINALIZE" => Ok(Token::Finalize),
                    "FIRST_P" => Ok(Token::FirstP),
                    "FLOAT_P" => Ok(Token::FloatP),
                    "FOLLOWING" => Ok(Token::Following),
                    "FOR" => Ok(Token::For),
                    "FORCE" => Ok(Token::Force),
                    "FOREIGN" => Ok(Token::Foreign),
                    "FORMAT" => Ok(Token::Format),
                    "FORWARD" => Ok(Token::Forward),
                    "FREEZE" => Ok(Token::Freeze),
                    "FROM" => Ok(Token::From),
                    "FULL" => Ok(Token::Full),
                    "FUNCTION" => Ok(Token::Function),
                    "FUNCTIONS" => Ok(Token::Functions),
                    "GENERATED" => Ok(Token::Generated),
                    "GLOBAL" => Ok(Token::Global),
                    "GRANT" => Ok(Token::Grant),
                    "GRANTED" => Ok(Token::Granted),
                    "GREATEST" => Ok(Token::Greatest),
                    "GROUP_P" => Ok(Token::GroupP),
                    "GROUPING" => Ok(Token::Grouping),
                    "GROUPS" => Ok(Token::Groups),
                    "HANDLER" => Ok(Token::Handler),
                    "HAVING" => Ok(Token::Having),
                    "HEADER_P" => Ok(Token::HeaderP),
                    "HOLD" => Ok(Token::Hold),
                    "HOUR_P" => Ok(Token::HourP),
                    "IDENTITY_P" => Ok(Token::IdentityP),
                    "IF_P" => Ok(Token::IfP),
                    "ILIKE" => Ok(Token::Ilike),
                    "IMMEDIATE" => Ok(Token::Immediate),
                    "IMMUTABLE" => Ok(Token::Immutable),
                    "IMPLICIT_P" => Ok(Token::ImplicitP),
                    "IMPORT_P" => Ok(Token::ImportP),
                    "IN_P" => Ok(Token::InP),
                    "INCLUDE" => Ok(Token::Include),
                    "INCLUDING" => Ok(Token::Including),
                    "INCREMENT" => Ok(Token::Increment),
                    "INDENT" => Ok(Token::Indent),
                    "INDEX" => Ok(Token::Index),
                    "INDEXES" => Ok(Token::Indexes),
                    "INHERIT" => Ok(Token::Inherit),
                    "INHERITS" => Ok(Token::Inherits),
                    "INITIALLY" => Ok(Token::Initially),
                    "INLINE_P" => Ok(Token::InlineP),
                    "INNER_P" => Ok(Token::InnerP),
                    "INOUT" => Ok(Token::Inout),
                    "INPUT_P" => Ok(Token::InputP),
                    "INSENSITIVE" => Ok(Token::Insensitive),
                    "INSERT" => Ok(Token::Insert),
                    "INSTEAD" => Ok(Token::Instead),
                    "INT_P" => Ok(Token::IntP),
                    "INTEGER" => Ok(Token::Integer),
                    "INTERSECT" => Ok(Token::Intersect),
                    "INTERVAL" => Ok(Token::Interval),
                    "INTO" => Ok(Token::Into),
                    "INVOKER" => Ok(Token::Invoker),
                    "IS" => Ok(Token::Is),
                    "ISNULL" => Ok(Token::Isnull),
                    "ISOLATION" => Ok(Token::Isolation),
                    "JOIN" => Ok(Token::Join),
                    "JSON" => Ok(Token::Json),
                    "JSON_ARRAY" => Ok(Token::JsonArray),
                    "JSON_ARRAYAGG" => Ok(Token::JsonArrayagg),
                    "JSON_OBJECT" => Ok(Token::JsonObject),
                    "JSON_OBJECTAGG" => Ok(Token::JsonObjectagg),
                    "KEY" => Ok(Token::Key),
                    "KEYS" => Ok(Token::Keys),
                    "LABEL" => Ok(Token::Label),
                    "LANGUAGE" => Ok(Token::Language),
                    "LARGE_P" => Ok(Token::LargeP),
                    "LAST_P" => Ok(Token::LastP),
                    "LATERAL_P" => Ok(Token::LateralP),
                    "LEADING" => Ok(Token::Leading),
                    "LEAKPROOF" => Ok(Token::Leakproof),
                    "LEAST" => Ok(Token::Least),
                    "LEFT" => Ok(Token::Left),
                    "LEVEL" => Ok(Token::Level),
                    "LIKE" => Ok(Token::Like),
                    "LIMIT" => Ok(Token::Limit),
                    "LISTEN" => Ok(Token::Listen),
                    "LOAD" => Ok(Token::Load),
                    "LOCAL" => Ok(Token::Local),
                    "LOCALTIME" => Ok(Token::Localtime),
                    "LOCALTIMESTAMP" => Ok(Token::Localtimestamp),
                    "LOCATION" => Ok(Token::Location),
                    "LOCK_P" => Ok(Token::LockP),
                    "LOCKED" => Ok(Token::Locked),
                    "LOGGED" => Ok(Token::Logged),
                    "MAPPING" => Ok(Token::Mapping),
                    "MATCH" => Ok(Token::Match),
                    "MATCHED" => Ok(Token::Matched),
                    "MATERIALIZED" => Ok(Token::Materialized),
                    "MAXVALUE" => Ok(Token::Maxvalue),
                    "MERGE" => Ok(Token::Merge),
                    "METHOD" => Ok(Token::Method),
                    "MINUTE_P" => Ok(Token::MinuteP),
                    "MINVALUE" => Ok(Token::Minvalue),
                    "MODE" => Ok(Token::Mode),
                    "MONTH_P" => Ok(Token::MonthP),
                    "MOVE" => Ok(Token::Move),
                    "NAME_P" => Ok(Token::NameP),
                    "NAMES" => Ok(Token::Names),
                    "NATIONAL" => Ok(Token::National),
                    "NATURAL" => Ok(Token::Natural),
                    "NCHAR" => Ok(Token::Nchar),
                    "NEW" => Ok(Token::New),
                    "NEXT" => Ok(Token::Next),
                    "NFC" => Ok(Token::Nfc),
                    "NFD" => Ok(Token::Nfd),
                    "NFKC" => Ok(Token::Nfkc),
                    "NFKD" => Ok(Token::Nfkd),
                    "NO" => Ok(Token::No),
                    "NONE" => Ok(Token::None),
                    "NORMALIZE" => Ok(Token::Normalize),
                    "NORMALIZED" => Ok(Token::Normalized),
                    "NOT" => Ok(Token::Not),
                    "NOTHING" => Ok(Token::Nothing),
                    "NOTIFY" => Ok(Token::Notify),
                    "NOTNULL" => Ok(Token::Notnull),
                    "NOWAIT" => Ok(Token::Nowait),
                    "NULL_P" => Ok(Token::NullP),
                    "NULLIF" => Ok(Token::Nullif),
                    "NULLS_P" => Ok(Token::NullsP),
                    "NUMERIC" => Ok(Token::Numeric),
                    "OBJECT_P" => Ok(Token::ObjectP),
                    "OF" => Ok(Token::Of),
                    "OFF" => Ok(Token::Off),
                    "OFFSET" => Ok(Token::Offset),
                    "OIDS" => Ok(Token::Oids),
                    "OLD" => Ok(Token::Old),
                    "ON" => Ok(Token::On),
                    "ONLY" => Ok(Token::Only),
                    "OPERATOR" => Ok(Token::Operator),
                    "OPTION" => Ok(Token::Option),
                    "OPTIONS" => Ok(Token::Options),
                    "OR" => Ok(Token::Or),
                    "ORDER" => Ok(Token::Order),
                    "ORDINALITY" => Ok(Token::Ordinality),
                    "OTHERS" => Ok(Token::Others),
                    "OUT_P" => Ok(Token::OutP),
                    "OUTER_P" => Ok(Token::OuterP),
                    "OVER" => Ok(Token::Over),
                    "OVERLAPS" => Ok(Token::Overlaps),
                    "OVERLAY" => Ok(Token::Overlay),
                    "OVERRIDING" => Ok(Token::Overriding),
                    "OWNED" => Ok(Token::Owned),
                    "OWNER" => Ok(Token::Owner),
                    "PARALLEL" => Ok(Token::Parallel),
                    "PARAMETER" => Ok(Token::Parameter),
                    "PARSER" => Ok(Token::Parser),
                    "PARTIAL" => Ok(Token::Partial),
                    "PARTITION" => Ok(Token::Partition),
                    "PASSING" => Ok(Token::Passing),
                    "PASSWORD" => Ok(Token::Password),
                    "PLACING" => Ok(Token::Placing),
                    "PLANS" => Ok(Token::Plans),
                    "POLICY" => Ok(Token::Policy),
                    "POSITION" => Ok(Token::Position),
                    "PRECEDING" => Ok(Token::Preceding),
                    "PRECISION" => Ok(Token::Precision),
                    "PRESERVE" => Ok(Token::Preserve),
                    "PREPARE" => Ok(Token::Prepare),
                    "PREPARED" => Ok(Token::Prepared),
                    "PRIMARY" => Ok(Token::Primary),
                    "PRIOR" => Ok(Token::Prior),
                    "PRIVILEGES" => Ok(Token::Privileges),
                    "PROCEDURAL" => Ok(Token::Procedural),
                    "PROCEDURE" => Ok(Token::Procedure),
                    "PROCEDURES" => Ok(Token::Procedures),
                    "PROGRAM" => Ok(Token::Program),
                    "PUBLICATION" => Ok(Token::Publication),
                    "QUOTE" => Ok(Token::Quote),
                    "RANGE" => Ok(Token::Range),
                    "READ" => Ok(Token::Read),
                    "REAL" => Ok(Token::Real),
                    "REASSIGN" => Ok(Token::Reassign),
                    "RECHECK" => Ok(Token::Recheck),
                    "RECURSIVE" => Ok(Token::Recursive),
                    "REF_P" => Ok(Token::RefP),
                    "REFERENCES" => Ok(Token::References),
                    "REFERENCING" => Ok(Token::Referencing),
                    "REFRESH" => Ok(Token::Refresh),
                    "REINDEX" => Ok(Token::Reindex),
                    "RELATIVE_P" => Ok(Token::RelativeP),
                    "RELEASE" => Ok(Token::Release),
                    "RENAME" => Ok(Token::Rename),
                    "REPEATABLE" => Ok(Token::Repeatable),
                    "REPLACE" => Ok(Token::Replace),
                    "REPLICA" => Ok(Token::Replica),
                    "RESET" => Ok(Token::Reset),
                    "RESTART" => Ok(Token::Restart),
                    "RESTRICT" => Ok(Token::Restrict),
                    "RETURN" => Ok(Token::Return),
                    "RETURNING" => Ok(Token::Returning),
                    "RETURNS" => Ok(Token::Returns),
                    "REVOKE" => Ok(Token::Revoke),
                    "RIGHT" => Ok(Token::Right),
                    "ROLE" => Ok(Token::Role),
                    "ROLLBACK" => Ok(Token::Rollback),
                    "ROLLUP" => Ok(Token::Rollup),
                    "ROUTINE" => Ok(Token::Routine),
                    "ROUTINES" => Ok(Token::Routines),
                    "ROW" => Ok(Token::Row),
                    "ROWS" => Ok(Token::Rows),
                    "RULE" => Ok(Token::Rule),
                    "SAVEPOINT" => Ok(Token::Savepoint),
                    "SCALAR" => Ok(Token::Scalar),
                    "SCHEMA" => Ok(Token::Schema),
                    "SCHEMAS" => Ok(Token::Schemas),
                    "SCROLL" => Ok(Token::Scroll),
                    "SEARCH" => Ok(Token::Search),
                    "SECOND_P" => Ok(Token::SecondP),
                    "SECURITY" => Ok(Token::Security),
                    "SELECT" => Ok(Token::Select),
                    "SEQUENCE" => Ok(Token::Sequence),
                    "SEQUENCES" => Ok(Token::Sequences),
                    "SERIALIZABLE" => Ok(Token::Serializable),
                    "SERVER" => Ok(Token::Server),
                    "SESSION" => Ok(Token::Session),
                    "SESSION_USER" => Ok(Token::SessionUser),
                    "SET" => Ok(Token::Set),
                    "SETS" => Ok(Token::Sets),
                    "SETOF" => Ok(Token::Setof),
                    "SHARE" => Ok(Token::Share),
                    "SHOW" => Ok(Token::Show),
                    "SIMILAR" => Ok(Token::Similar),
                    "SIMPLE" => Ok(Token::Simple),
                    "SKIP" => Ok(Token::Skip),
                    "SMALLINT" => Ok(Token::Smallint),
                    "SNAPSHOT" => Ok(Token::Snapshot),
                    "SOME" => Ok(Token::Some),
                    "SQL_P" => Ok(Token::SqlP),
                    "STABLE" => Ok(Token::Stable),
                    "STANDALONE_P" => Ok(Token::StandaloneP),
                    "START" => Ok(Token::Start),
                    "STATEMENT" => Ok(Token::Statement),
                    "STATISTICS" => Ok(Token::Statistics),
                    "STDIN" => Ok(Token::Stdin),
                    "STDOUT" => Ok(Token::Stdout),
                    "STORAGE" => Ok(Token::Storage),
                    "STORED" => Ok(Token::Stored),
                    "STRICT_P" => Ok(Token::StrictP),
                    "STRIP_P" => Ok(Token::StripP),
                    "SUBSCRIPTION" => Ok(Token::Subscription),
                    "SUBSTRING" => Ok(Token::Substring),
                    "SUPPORT" => Ok(Token::Support),
                    "SYMMETRIC" => Ok(Token::Symmetric),
                    "SYSID" => Ok(Token::Sysid),
                    "SYSTEM_P" => Ok(Token::SystemP),
                    "SYSTEM_USER" => Ok(Token::SystemUser),
                    "TABLE" => Ok(Token::Table),
                    "TABLES" => Ok(Token::Tables),
                    "TABLESAMPLE" => Ok(Token::Tablesample),
                    "TABLESPACE" => Ok(Token::Tablespace),
                    "TEMP" => Ok(Token::Temp),
                    "TEMPLATE" => Ok(Token::Template),
                    "TEMPORARY" => Ok(Token::Temporary),
                    "TEXT_P" => Ok(Token::TextP),
                    "THEN" => Ok(Token::Then),
                    "TIES" => Ok(Token::Ties),
                    "TIME" => Ok(Token::Time),
                    "TIMESTAMP" => Ok(Token::Timestamp),
                    "TO" => Ok(Token::To),
                    "TRAILING" => Ok(Token::Trailing),
                    "TRANSACTION" => Ok(Token::Transaction),
                    "TRANSFORM" => Ok(Token::Transform),
                    "TREAT" => Ok(Token::Treat),
                    "TRIGGER" => Ok(Token::Trigger),
                    "TRIM" => Ok(Token::Trim),
                    "TRUE_P" => Ok(Token::TrueP),
                    "TRUNCATE" => Ok(Token::Truncate),
                    "TRUSTED" => Ok(Token::Trusted),
                    "TYPE_P" => Ok(Token::TypeP),
                    "TYPES_P" => Ok(Token::TypesP),
                    "UESCAPE" => Ok(Token::Uescape),
                    "UNBOUNDED" => Ok(Token::Unbounded),
                    "UNCOMMITTED" => Ok(Token::Uncommitted),
                    "UNENCRYPTED" => Ok(Token::Unencrypted),
                    "UNION" => Ok(Token::Union),
                    "UNIQUE" => Ok(Token::Unique),
                    "UNKNOWN" => Ok(Token::Unknown),
                    "UNLISTEN" => Ok(Token::Unlisten),
                    "UNLOGGED" => Ok(Token::Unlogged),
                    "UNTIL" => Ok(Token::Until),
                    "UPDATE" => Ok(Token::Update),
                    "USER" => Ok(Token::User),
                    "USING" => Ok(Token::Using),
                    "VACUUM" => Ok(Token::Vacuum),
                    "VALID" => Ok(Token::Valid),
                    "VALIDATE" => Ok(Token::Validate),
                    "VALIDATOR" => Ok(Token::Validator),
                    "VALUE_P" => Ok(Token::ValueP),
                    "VALUES" => Ok(Token::Values),
                    "VARCHAR" => Ok(Token::Varchar),
                    "VARIADIC" => Ok(Token::Variadic),
                    "VARYING" => Ok(Token::Varying),
                    "VERBOSE" => Ok(Token::Verbose),
                    "VERSION_P" => Ok(Token::VersionP),
                    "VIEW" => Ok(Token::View),
                    "VIEWS" => Ok(Token::Views),
                    "VOLATILE" => Ok(Token::Volatile),
                    "WHEN" => Ok(Token::When),
                    "WHERE" => Ok(Token::Where),
                    "WHITESPACE_P" => Ok(Token::WhitespaceP),
                    "WINDOW" => Ok(Token::Window),
                    "WITH" => Ok(Token::With),
                    "WITHIN" => Ok(Token::Within),
                    "WITHOUT" => Ok(Token::Without),
                    "WORK" => Ok(Token::Work),
                    "WRAPPER" => Ok(Token::Wrapper),
                    "WRITE" => Ok(Token::Write),
                    "XML_P" => Ok(Token::XmlP),
                    "XMLATTRIBUTES" => Ok(Token::Xmlattributes),
                    "XMLCONCAT" => Ok(Token::Xmlconcat),
                    "XMLELEMENT" => Ok(Token::Xmlelement),
                    "XMLEXISTS" => Ok(Token::Xmlexists),
                    "XMLFOREST" => Ok(Token::Xmlforest),
                    "XMLNAMESPACES" => Ok(Token::Xmlnamespaces),
                    "XMLPARSE" => Ok(Token::Xmlparse),
                    "XMLPI" => Ok(Token::Xmlpi),
                    "XMLROOT" => Ok(Token::Xmlroot),
                    "XMLSERIALIZE" => Ok(Token::Xmlserialize),
                    "XMLTABLE" => Ok(Token::Xmltable),
                    "YEAR_P" => Ok(Token::YearP),
                    "YES_P" => Ok(Token::YesP),
                    "ZONE" => Ok(Token::Zone),
                    "FORMAT_LA" => Ok(Token::FormatLa),
                    "NOT_LA" => Ok(Token::NotLa),
                    "NULLS_LA" => Ok(Token::NullsLa),
                    "WITH_LA" => Ok(Token::WithLa),
                    "WITHOUT_LA" => Ok(Token::WithoutLa),
                    "MODE_TYPE_NAME" => Ok(Token::ModeTypeName),
                    "MODE_PLPGSQL_EXPR" => Ok(Token::ModePlpgsqlExpr),
                    "MODE_PLPGSQL_ASSIGN1" => Ok(Token::ModePlpgsqlAssign1),
                    "MODE_PLPGSQL_ASSIGN2" => Ok(Token::ModePlpgsqlAssign2),
                    "MODE_PLPGSQL_ASSIGN3" => Ok(Token::ModePlpgsqlAssign3),
                    "UMINUS" => Ok(Token::Uminus),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if !self.savepoint_name.is_empty() {
            len += 1;
        }
        if !self.gid.is_empty() {
            len += 1;
        }
        if self.chain {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TransactionStmt", len)?;
        if self.kind != 0 {
            let v = TransactionStmtKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if !self.savepoint_name.is_empty() {
            struct_ser.serialize_field("savepoint_name", &self.savepoint_name)?;
        }
        if !self.gid.is_empty() {
            struct_ser.serialize_field("gid", &self.gid)?;
        }
        if self.chain {
            struct_ser.serialize_field("chain", &self.chain)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "options",
            "savepoint_name",
            "gid",
            "chain",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Options,
            SavepointName,
            Gid,
            Chain,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "options" => Ok(GeneratedField::Options),
                            "savepoint_name" => Ok(GeneratedField::SavepointName),
                            "gid" => Ok(GeneratedField::Gid),
                            "chain" => Ok(GeneratedField::Chain),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TransactionStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut options__ = None;
                let mut savepoint_name__ = None;
                let mut gid__ = None;
                let mut chain__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<TransactionStmtKind>()? as i32);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SavepointName => {
                            if savepoint_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("savepoint_name"));
                            }
                            savepoint_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Gid => {
                            if gid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gid"));
                            }
                            gid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Chain => {
                            if chain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chain"));
                            }
                            chain__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TransactionStmt {
                    kind: kind__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    savepoint_name: savepoint_name__.unwrap_or_default(),
                    gid: gid__.unwrap_or_default(),
                    chain: chain__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TransactionStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionStmtKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "TRANSACTION_STMT_KIND_UNDEFINED",
            Self::TransStmtBegin => "TRANS_STMT_BEGIN",
            Self::TransStmtStart => "TRANS_STMT_START",
            Self::TransStmtCommit => "TRANS_STMT_COMMIT",
            Self::TransStmtRollback => "TRANS_STMT_ROLLBACK",
            Self::TransStmtSavepoint => "TRANS_STMT_SAVEPOINT",
            Self::TransStmtRelease => "TRANS_STMT_RELEASE",
            Self::TransStmtRollbackTo => "TRANS_STMT_ROLLBACK_TO",
            Self::TransStmtPrepare => "TRANS_STMT_PREPARE",
            Self::TransStmtCommitPrepared => "TRANS_STMT_COMMIT_PREPARED",
            Self::TransStmtRollbackPrepared => "TRANS_STMT_ROLLBACK_PREPARED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for TransactionStmtKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TRANSACTION_STMT_KIND_UNDEFINED",
            "TRANS_STMT_BEGIN",
            "TRANS_STMT_START",
            "TRANS_STMT_COMMIT",
            "TRANS_STMT_ROLLBACK",
            "TRANS_STMT_SAVEPOINT",
            "TRANS_STMT_RELEASE",
            "TRANS_STMT_ROLLBACK_TO",
            "TRANS_STMT_PREPARE",
            "TRANS_STMT_COMMIT_PREPARED",
            "TRANS_STMT_ROLLBACK_PREPARED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionStmtKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TRANSACTION_STMT_KIND_UNDEFINED" => Ok(TransactionStmtKind::Undefined),
                    "TRANS_STMT_BEGIN" => Ok(TransactionStmtKind::TransStmtBegin),
                    "TRANS_STMT_START" => Ok(TransactionStmtKind::TransStmtStart),
                    "TRANS_STMT_COMMIT" => Ok(TransactionStmtKind::TransStmtCommit),
                    "TRANS_STMT_ROLLBACK" => Ok(TransactionStmtKind::TransStmtRollback),
                    "TRANS_STMT_SAVEPOINT" => Ok(TransactionStmtKind::TransStmtSavepoint),
                    "TRANS_STMT_RELEASE" => Ok(TransactionStmtKind::TransStmtRelease),
                    "TRANS_STMT_ROLLBACK_TO" => Ok(TransactionStmtKind::TransStmtRollbackTo),
                    "TRANS_STMT_PREPARE" => Ok(TransactionStmtKind::TransStmtPrepare),
                    "TRANS_STMT_COMMIT_PREPARED" => Ok(TransactionStmtKind::TransStmtCommitPrepared),
                    "TRANS_STMT_ROLLBACK_PREPARED" => Ok(TransactionStmtKind::TransStmtRollbackPrepared),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TriggerTransition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.is_new {
            len += 1;
        }
        if self.is_table {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TriggerTransition", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if self.is_new {
            struct_ser.serialize_field("isNew", &self.is_new)?;
        }
        if self.is_table {
            struct_ser.serialize_field("isTable", &self.is_table)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TriggerTransition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "is_new",
            "isNew",
            "is_table",
            "isTable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            IsNew,
            IsTable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "isNew" | "is_new" => Ok(GeneratedField::IsNew),
                            "isTable" | "is_table" => Ok(GeneratedField::IsTable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TriggerTransition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TriggerTransition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TriggerTransition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut is_new__ = None;
                let mut is_table__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsNew => {
                            if is_new__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isNew"));
                            }
                            is_new__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsTable => {
                            if is_table__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isTable"));
                            }
                            is_table__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TriggerTransition {
                    name: name__.unwrap_or_default(),
                    is_new: is_new__.unwrap_or_default(),
                    is_table: is_table__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TriggerTransition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TruncateStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.relations.is_empty() {
            len += 1;
        }
        if self.restart_seqs {
            len += 1;
        }
        if self.behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TruncateStmt", len)?;
        if !self.relations.is_empty() {
            struct_ser.serialize_field("relations", &self.relations)?;
        }
        if self.restart_seqs {
            struct_ser.serialize_field("restart_seqs", &self.restart_seqs)?;
        }
        if self.behavior != 0 {
            let v = DropBehavior::try_from(self.behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.behavior)))?;
            struct_ser.serialize_field("behavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TruncateStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relations",
            "restart_seqs",
            "behavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relations,
            RestartSeqs,
            Behavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relations" => Ok(GeneratedField::Relations),
                            "restart_seqs" => Ok(GeneratedField::RestartSeqs),
                            "behavior" => Ok(GeneratedField::Behavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TruncateStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TruncateStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TruncateStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relations__ = None;
                let mut restart_seqs__ = None;
                let mut behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relations => {
                            if relations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relations"));
                            }
                            relations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RestartSeqs => {
                            if restart_seqs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("restart_seqs"));
                            }
                            restart_seqs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Behavior => {
                            if behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("behavior"));
                            }
                            behavior__ = Some(map_.next_value::<DropBehavior>()? as i32);
                        }
                    }
                }
                Ok(TruncateStmt {
                    relations: relations__.unwrap_or_default(),
                    restart_seqs: restart_seqs__.unwrap_or_default(),
                    behavior: behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TruncateStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypeCast {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.arg.is_some() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TypeCast", len)?;
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeCast {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arg",
            "type_name",
            "typeName",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arg,
            TypeName,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arg" => Ok(GeneratedField::Arg),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeCast;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TypeCast")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeCast, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arg__ = None;
                let mut type_name__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(TypeCast {
                    arg: arg__,
                    type_name: type_name__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TypeCast", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypeName {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.type_oid != 0 {
            len += 1;
        }
        if self.setof {
            len += 1;
        }
        if self.pct_type {
            len += 1;
        }
        if !self.typmods.is_empty() {
            len += 1;
        }
        if self.typemod != 0 {
            len += 1;
        }
        if !self.array_bounds.is_empty() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.TypeName", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if self.type_oid != 0 {
            struct_ser.serialize_field("typeOid", &self.type_oid)?;
        }
        if self.setof {
            struct_ser.serialize_field("setof", &self.setof)?;
        }
        if self.pct_type {
            struct_ser.serialize_field("pct_type", &self.pct_type)?;
        }
        if !self.typmods.is_empty() {
            struct_ser.serialize_field("typmods", &self.typmods)?;
        }
        if self.typemod != 0 {
            struct_ser.serialize_field("typemod", &self.typemod)?;
        }
        if !self.array_bounds.is_empty() {
            struct_ser.serialize_field("arrayBounds", &self.array_bounds)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeName {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "type_oid",
            "typeOid",
            "setof",
            "pct_type",
            "typmods",
            "typemod",
            "array_bounds",
            "arrayBounds",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            TypeOid,
            Setof,
            PctType,
            Typmods,
            Typemod,
            ArrayBounds,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "typeOid" | "type_oid" => Ok(GeneratedField::TypeOid),
                            "setof" => Ok(GeneratedField::Setof),
                            "pct_type" => Ok(GeneratedField::PctType),
                            "typmods" => Ok(GeneratedField::Typmods),
                            "typemod" => Ok(GeneratedField::Typemod),
                            "arrayBounds" | "array_bounds" => Ok(GeneratedField::ArrayBounds),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeName;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.TypeName")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeName, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut type_oid__ = None;
                let mut setof__ = None;
                let mut pct_type__ = None;
                let mut typmods__ = None;
                let mut typemod__ = None;
                let mut array_bounds__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeOid => {
                            if type_oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeOid"));
                            }
                            type_oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Setof => {
                            if setof__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setof"));
                            }
                            setof__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PctType => {
                            if pct_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pct_type"));
                            }
                            pct_type__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Typmods => {
                            if typmods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typmods"));
                            }
                            typmods__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Typemod => {
                            if typemod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typemod"));
                            }
                            typemod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ArrayBounds => {
                            if array_bounds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arrayBounds"));
                            }
                            array_bounds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(TypeName {
                    names: names__.unwrap_or_default(),
                    type_oid: type_oid__.unwrap_or_default(),
                    setof: setof__.unwrap_or_default(),
                    pct_type: pct_type__.unwrap_or_default(),
                    typmods: typmods__.unwrap_or_default(),
                    typemod: typemod__.unwrap_or_default(),
                    array_bounds: array_bounds__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.TypeName", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnlistenStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.conditionname.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.UnlistenStmt", len)?;
        if !self.conditionname.is_empty() {
            struct_ser.serialize_field("conditionname", &self.conditionname)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnlistenStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "conditionname",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Conditionname,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "conditionname" => Ok(GeneratedField::Conditionname),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnlistenStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.UnlistenStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnlistenStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut conditionname__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Conditionname => {
                            if conditionname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditionname"));
                            }
                            conditionname__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UnlistenStmt {
                    conditionname: conditionname__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.UnlistenStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UpdateStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if !self.target_list.is_empty() {
            len += 1;
        }
        if self.where_clause.is_some() {
            len += 1;
        }
        if !self.from_clause.is_empty() {
            len += 1;
        }
        if !self.returning_list.is_empty() {
            len += 1;
        }
        if self.with_clause.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.UpdateStmt", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if !self.target_list.is_empty() {
            struct_ser.serialize_field("targetList", &self.target_list)?;
        }
        if let Some(v) = self.where_clause.as_ref() {
            struct_ser.serialize_field("whereClause", v)?;
        }
        if !self.from_clause.is_empty() {
            struct_ser.serialize_field("fromClause", &self.from_clause)?;
        }
        if !self.returning_list.is_empty() {
            struct_ser.serialize_field("returningList", &self.returning_list)?;
        }
        if let Some(v) = self.with_clause.as_ref() {
            struct_ser.serialize_field("withClause", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UpdateStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "target_list",
            "targetList",
            "where_clause",
            "whereClause",
            "from_clause",
            "fromClause",
            "returning_list",
            "returningList",
            "with_clause",
            "withClause",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            TargetList,
            WhereClause,
            FromClause,
            ReturningList,
            WithClause,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "targetList" | "target_list" => Ok(GeneratedField::TargetList),
                            "whereClause" | "where_clause" => Ok(GeneratedField::WhereClause),
                            "fromClause" | "from_clause" => Ok(GeneratedField::FromClause),
                            "returningList" | "returning_list" => Ok(GeneratedField::ReturningList),
                            "withClause" | "with_clause" => Ok(GeneratedField::WithClause),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UpdateStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.UpdateStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UpdateStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut target_list__ = None;
                let mut where_clause__ = None;
                let mut from_clause__ = None;
                let mut returning_list__ = None;
                let mut with_clause__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::TargetList => {
                            if target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetList"));
                            }
                            target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WhereClause => {
                            if where_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whereClause"));
                            }
                            where_clause__ = map_.next_value()?;
                        }
                        GeneratedField::FromClause => {
                            if from_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fromClause"));
                            }
                            from_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReturningList => {
                            if returning_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returningList"));
                            }
                            returning_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithClause => {
                            if with_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withClause"));
                            }
                            with_clause__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UpdateStmt {
                    relation: relation__,
                    target_list: target_list__.unwrap_or_default(),
                    where_clause: where_clause__,
                    from_clause: from_clause__.unwrap_or_default(),
                    returning_list: returning_list__.unwrap_or_default(),
                    with_clause: with_clause__,
                })
            }
        }
        deserializer.deserialize_struct("pg_query.UpdateStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VacuumRelation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.relation.is_some() {
            len += 1;
        }
        if self.oid != 0 {
            len += 1;
        }
        if !self.va_cols.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.VacuumRelation", len)?;
        if let Some(v) = self.relation.as_ref() {
            struct_ser.serialize_field("relation", v)?;
        }
        if self.oid != 0 {
            struct_ser.serialize_field("oid", &self.oid)?;
        }
        if !self.va_cols.is_empty() {
            struct_ser.serialize_field("va_cols", &self.va_cols)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VacuumRelation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "relation",
            "oid",
            "va_cols",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Relation,
            Oid,
            VaCols,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "relation" => Ok(GeneratedField::Relation),
                            "oid" => Ok(GeneratedField::Oid),
                            "va_cols" => Ok(GeneratedField::VaCols),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VacuumRelation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.VacuumRelation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VacuumRelation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut relation__ = None;
                let mut oid__ = None;
                let mut va_cols__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = map_.next_value()?;
                        }
                        GeneratedField::Oid => {
                            if oid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oid"));
                            }
                            oid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VaCols => {
                            if va_cols__.is_some() {
                                return Err(serde::de::Error::duplicate_field("va_cols"));
                            }
                            va_cols__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VacuumRelation {
                    relation: relation__,
                    oid: oid__.unwrap_or_default(),
                    va_cols: va_cols__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.VacuumRelation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VacuumStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.options.is_empty() {
            len += 1;
        }
        if !self.rels.is_empty() {
            len += 1;
        }
        if self.is_vacuumcmd {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.VacuumStmt", len)?;
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if !self.rels.is_empty() {
            struct_ser.serialize_field("rels", &self.rels)?;
        }
        if self.is_vacuumcmd {
            struct_ser.serialize_field("is_vacuumcmd", &self.is_vacuumcmd)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VacuumStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "options",
            "rels",
            "is_vacuumcmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Options,
            Rels,
            IsVacuumcmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "options" => Ok(GeneratedField::Options),
                            "rels" => Ok(GeneratedField::Rels),
                            "is_vacuumcmd" => Ok(GeneratedField::IsVacuumcmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VacuumStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.VacuumStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VacuumStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut options__ = None;
                let mut rels__ = None;
                let mut is_vacuumcmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rels => {
                            if rels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rels"));
                            }
                            rels__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsVacuumcmd => {
                            if is_vacuumcmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_vacuumcmd"));
                            }
                            is_vacuumcmd__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VacuumStmt {
                    options: options__.unwrap_or_default(),
                    rels: rels__.unwrap_or_default(),
                    is_vacuumcmd: is_vacuumcmd__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.VacuumStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Var {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.varno != 0 {
            len += 1;
        }
        if self.varattno != 0 {
            len += 1;
        }
        if self.vartype != 0 {
            len += 1;
        }
        if self.vartypmod != 0 {
            len += 1;
        }
        if self.varcollid != 0 {
            len += 1;
        }
        if !self.varnullingrels.is_empty() {
            len += 1;
        }
        if self.varlevelsup != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.Var", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.varno != 0 {
            struct_ser.serialize_field("varno", &self.varno)?;
        }
        if self.varattno != 0 {
            struct_ser.serialize_field("varattno", &self.varattno)?;
        }
        if self.vartype != 0 {
            struct_ser.serialize_field("vartype", &self.vartype)?;
        }
        if self.vartypmod != 0 {
            struct_ser.serialize_field("vartypmod", &self.vartypmod)?;
        }
        if self.varcollid != 0 {
            struct_ser.serialize_field("varcollid", &self.varcollid)?;
        }
        if !self.varnullingrels.is_empty() {
            struct_ser.serialize_field("varnullingrels", &self.varnullingrels.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if self.varlevelsup != 0 {
            struct_ser.serialize_field("varlevelsup", &self.varlevelsup)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Var {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "varno",
            "varattno",
            "vartype",
            "vartypmod",
            "varcollid",
            "varnullingrels",
            "varlevelsup",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Varno,
            Varattno,
            Vartype,
            Vartypmod,
            Varcollid,
            Varnullingrels,
            Varlevelsup,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "varno" => Ok(GeneratedField::Varno),
                            "varattno" => Ok(GeneratedField::Varattno),
                            "vartype" => Ok(GeneratedField::Vartype),
                            "vartypmod" => Ok(GeneratedField::Vartypmod),
                            "varcollid" => Ok(GeneratedField::Varcollid),
                            "varnullingrels" => Ok(GeneratedField::Varnullingrels),
                            "varlevelsup" => Ok(GeneratedField::Varlevelsup),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Var;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.Var")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Var, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut varno__ = None;
                let mut varattno__ = None;
                let mut vartype__ = None;
                let mut vartypmod__ = None;
                let mut varcollid__ = None;
                let mut varnullingrels__ = None;
                let mut varlevelsup__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Varno => {
                            if varno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varno"));
                            }
                            varno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Varattno => {
                            if varattno__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varattno"));
                            }
                            varattno__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Vartype => {
                            if vartype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vartype"));
                            }
                            vartype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Vartypmod => {
                            if vartypmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vartypmod"));
                            }
                            vartypmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Varcollid => {
                            if varcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varcollid"));
                            }
                            varcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Varnullingrels => {
                            if varnullingrels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varnullingrels"));
                            }
                            varnullingrels__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Varlevelsup => {
                            if varlevelsup__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varlevelsup"));
                            }
                            varlevelsup__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Var {
                    xpr: xpr__,
                    varno: varno__.unwrap_or_default(),
                    varattno: varattno__.unwrap_or_default(),
                    vartype: vartype__.unwrap_or_default(),
                    vartypmod: vartypmod__.unwrap_or_default(),
                    varcollid: varcollid__.unwrap_or_default(),
                    varnullingrels: varnullingrels__.unwrap_or_default(),
                    varlevelsup: varlevelsup__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.Var", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VariableSetKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "VARIABLE_SET_KIND_UNDEFINED",
            Self::VarSetValue => "VAR_SET_VALUE",
            Self::VarSetDefault => "VAR_SET_DEFAULT",
            Self::VarSetCurrent => "VAR_SET_CURRENT",
            Self::VarSetMulti => "VAR_SET_MULTI",
            Self::VarReset => "VAR_RESET",
            Self::VarResetAll => "VAR_RESET_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for VariableSetKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VARIABLE_SET_KIND_UNDEFINED",
            "VAR_SET_VALUE",
            "VAR_SET_DEFAULT",
            "VAR_SET_CURRENT",
            "VAR_SET_MULTI",
            "VAR_RESET",
            "VAR_RESET_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VariableSetKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VARIABLE_SET_KIND_UNDEFINED" => Ok(VariableSetKind::Undefined),
                    "VAR_SET_VALUE" => Ok(VariableSetKind::VarSetValue),
                    "VAR_SET_DEFAULT" => Ok(VariableSetKind::VarSetDefault),
                    "VAR_SET_CURRENT" => Ok(VariableSetKind::VarSetCurrent),
                    "VAR_SET_MULTI" => Ok(VariableSetKind::VarSetMulti),
                    "VAR_RESET" => Ok(VariableSetKind::VarReset),
                    "VAR_RESET_ALL" => Ok(VariableSetKind::VarResetAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for VariableSetStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.is_local {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.VariableSetStmt", len)?;
        if self.kind != 0 {
            let v = VariableSetKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.is_local {
            struct_ser.serialize_field("is_local", &self.is_local)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VariableSetStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "name",
            "args",
            "is_local",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Name,
            Args,
            IsLocal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "name" => Ok(GeneratedField::Name),
                            "args" => Ok(GeneratedField::Args),
                            "is_local" => Ok(GeneratedField::IsLocal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VariableSetStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.VariableSetStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VariableSetStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut name__ = None;
                let mut args__ = None;
                let mut is_local__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<VariableSetKind>()? as i32);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsLocal => {
                            if is_local__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is_local"));
                            }
                            is_local__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VariableSetStmt {
                    kind: kind__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    is_local: is_local__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.VariableSetStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VariableShowStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.VariableShowStmt", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VariableShowStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VariableShowStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.VariableShowStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VariableShowStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VariableShowStmt {
                    name: name__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.VariableShowStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ViewCheckOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "VIEW_CHECK_OPTION_UNDEFINED",
            Self::NoCheckOption => "NO_CHECK_OPTION",
            Self::LocalCheckOption => "LOCAL_CHECK_OPTION",
            Self::CascadedCheckOption => "CASCADED_CHECK_OPTION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ViewCheckOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VIEW_CHECK_OPTION_UNDEFINED",
            "NO_CHECK_OPTION",
            "LOCAL_CHECK_OPTION",
            "CASCADED_CHECK_OPTION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ViewCheckOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VIEW_CHECK_OPTION_UNDEFINED" => Ok(ViewCheckOption::Undefined),
                    "NO_CHECK_OPTION" => Ok(ViewCheckOption::NoCheckOption),
                    "LOCAL_CHECK_OPTION" => Ok(ViewCheckOption::LocalCheckOption),
                    "CASCADED_CHECK_OPTION" => Ok(ViewCheckOption::CascadedCheckOption),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ViewStmt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.view.is_some() {
            len += 1;
        }
        if !self.aliases.is_empty() {
            len += 1;
        }
        if self.query.is_some() {
            len += 1;
        }
        if self.replace {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.with_check_option != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.ViewStmt", len)?;
        if let Some(v) = self.view.as_ref() {
            struct_ser.serialize_field("view", v)?;
        }
        if !self.aliases.is_empty() {
            struct_ser.serialize_field("aliases", &self.aliases)?;
        }
        if let Some(v) = self.query.as_ref() {
            struct_ser.serialize_field("query", v)?;
        }
        if self.replace {
            struct_ser.serialize_field("replace", &self.replace)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.with_check_option != 0 {
            let v = ViewCheckOption::try_from(self.with_check_option)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.with_check_option)))?;
            struct_ser.serialize_field("withCheckOption", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ViewStmt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "view",
            "aliases",
            "query",
            "replace",
            "options",
            "with_check_option",
            "withCheckOption",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            View,
            Aliases,
            Query,
            Replace,
            Options,
            WithCheckOption,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "view" => Ok(GeneratedField::View),
                            "aliases" => Ok(GeneratedField::Aliases),
                            "query" => Ok(GeneratedField::Query),
                            "replace" => Ok(GeneratedField::Replace),
                            "options" => Ok(GeneratedField::Options),
                            "withCheckOption" | "with_check_option" => Ok(GeneratedField::WithCheckOption),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ViewStmt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.ViewStmt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ViewStmt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut view__ = None;
                let mut aliases__ = None;
                let mut query__ = None;
                let mut replace__ = None;
                let mut options__ = None;
                let mut with_check_option__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::View => {
                            if view__.is_some() {
                                return Err(serde::de::Error::duplicate_field("view"));
                            }
                            view__ = map_.next_value()?;
                        }
                        GeneratedField::Aliases => {
                            if aliases__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aliases"));
                            }
                            aliases__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Query => {
                            if query__.is_some() {
                                return Err(serde::de::Error::duplicate_field("query"));
                            }
                            query__ = map_.next_value()?;
                        }
                        GeneratedField::Replace => {
                            if replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replace"));
                            }
                            replace__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithCheckOption => {
                            if with_check_option__.is_some() {
                                return Err(serde::de::Error::duplicate_field("withCheckOption"));
                            }
                            with_check_option__ = Some(map_.next_value::<ViewCheckOption>()? as i32);
                        }
                    }
                }
                Ok(ViewStmt {
                    view: view__,
                    aliases: aliases__.unwrap_or_default(),
                    query: query__,
                    replace: replace__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    with_check_option: with_check_option__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.ViewStmt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WcoKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::WcokindUndefined => "WCOKIND_UNDEFINED",
            Self::WcoViewCheck => "WCO_VIEW_CHECK",
            Self::WcoRlsInsertCheck => "WCO_RLS_INSERT_CHECK",
            Self::WcoRlsUpdateCheck => "WCO_RLS_UPDATE_CHECK",
            Self::WcoRlsConflictCheck => "WCO_RLS_CONFLICT_CHECK",
            Self::WcoRlsMergeUpdateCheck => "WCO_RLS_MERGE_UPDATE_CHECK",
            Self::WcoRlsMergeDeleteCheck => "WCO_RLS_MERGE_DELETE_CHECK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WcoKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WCOKIND_UNDEFINED",
            "WCO_VIEW_CHECK",
            "WCO_RLS_INSERT_CHECK",
            "WCO_RLS_UPDATE_CHECK",
            "WCO_RLS_CONFLICT_CHECK",
            "WCO_RLS_MERGE_UPDATE_CHECK",
            "WCO_RLS_MERGE_DELETE_CHECK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WcoKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "WCOKIND_UNDEFINED" => Ok(WcoKind::WcokindUndefined),
                    "WCO_VIEW_CHECK" => Ok(WcoKind::WcoViewCheck),
                    "WCO_RLS_INSERT_CHECK" => Ok(WcoKind::WcoRlsInsertCheck),
                    "WCO_RLS_UPDATE_CHECK" => Ok(WcoKind::WcoRlsUpdateCheck),
                    "WCO_RLS_CONFLICT_CHECK" => Ok(WcoKind::WcoRlsConflictCheck),
                    "WCO_RLS_MERGE_UPDATE_CHECK" => Ok(WcoKind::WcoRlsMergeUpdateCheck),
                    "WCO_RLS_MERGE_DELETE_CHECK" => Ok(WcoKind::WcoRlsMergeDeleteCheck),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WindowClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.refname.is_empty() {
            len += 1;
        }
        if !self.partition_clause.is_empty() {
            len += 1;
        }
        if !self.order_clause.is_empty() {
            len += 1;
        }
        if self.frame_options != 0 {
            len += 1;
        }
        if self.start_offset.is_some() {
            len += 1;
        }
        if self.end_offset.is_some() {
            len += 1;
        }
        if !self.run_condition.is_empty() {
            len += 1;
        }
        if self.start_in_range_func != 0 {
            len += 1;
        }
        if self.end_in_range_func != 0 {
            len += 1;
        }
        if self.in_range_coll != 0 {
            len += 1;
        }
        if self.in_range_asc {
            len += 1;
        }
        if self.in_range_nulls_first {
            len += 1;
        }
        if self.winref != 0 {
            len += 1;
        }
        if self.copied_order {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.WindowClause", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.refname.is_empty() {
            struct_ser.serialize_field("refname", &self.refname)?;
        }
        if !self.partition_clause.is_empty() {
            struct_ser.serialize_field("partitionClause", &self.partition_clause)?;
        }
        if !self.order_clause.is_empty() {
            struct_ser.serialize_field("orderClause", &self.order_clause)?;
        }
        if self.frame_options != 0 {
            struct_ser.serialize_field("frameOptions", &self.frame_options)?;
        }
        if let Some(v) = self.start_offset.as_ref() {
            struct_ser.serialize_field("startOffset", v)?;
        }
        if let Some(v) = self.end_offset.as_ref() {
            struct_ser.serialize_field("endOffset", v)?;
        }
        if !self.run_condition.is_empty() {
            struct_ser.serialize_field("runCondition", &self.run_condition)?;
        }
        if self.start_in_range_func != 0 {
            struct_ser.serialize_field("startInRangeFunc", &self.start_in_range_func)?;
        }
        if self.end_in_range_func != 0 {
            struct_ser.serialize_field("endInRangeFunc", &self.end_in_range_func)?;
        }
        if self.in_range_coll != 0 {
            struct_ser.serialize_field("inRangeColl", &self.in_range_coll)?;
        }
        if self.in_range_asc {
            struct_ser.serialize_field("inRangeAsc", &self.in_range_asc)?;
        }
        if self.in_range_nulls_first {
            struct_ser.serialize_field("inRangeNullsFirst", &self.in_range_nulls_first)?;
        }
        if self.winref != 0 {
            struct_ser.serialize_field("winref", &self.winref)?;
        }
        if self.copied_order {
            struct_ser.serialize_field("copiedOrder", &self.copied_order)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WindowClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "refname",
            "partition_clause",
            "partitionClause",
            "order_clause",
            "orderClause",
            "frame_options",
            "frameOptions",
            "start_offset",
            "startOffset",
            "end_offset",
            "endOffset",
            "run_condition",
            "runCondition",
            "start_in_range_func",
            "startInRangeFunc",
            "end_in_range_func",
            "endInRangeFunc",
            "in_range_coll",
            "inRangeColl",
            "in_range_asc",
            "inRangeAsc",
            "in_range_nulls_first",
            "inRangeNullsFirst",
            "winref",
            "copied_order",
            "copiedOrder",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Refname,
            PartitionClause,
            OrderClause,
            FrameOptions,
            StartOffset,
            EndOffset,
            RunCondition,
            StartInRangeFunc,
            EndInRangeFunc,
            InRangeColl,
            InRangeAsc,
            InRangeNullsFirst,
            Winref,
            CopiedOrder,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "refname" => Ok(GeneratedField::Refname),
                            "partitionClause" | "partition_clause" => Ok(GeneratedField::PartitionClause),
                            "orderClause" | "order_clause" => Ok(GeneratedField::OrderClause),
                            "frameOptions" | "frame_options" => Ok(GeneratedField::FrameOptions),
                            "startOffset" | "start_offset" => Ok(GeneratedField::StartOffset),
                            "endOffset" | "end_offset" => Ok(GeneratedField::EndOffset),
                            "runCondition" | "run_condition" => Ok(GeneratedField::RunCondition),
                            "startInRangeFunc" | "start_in_range_func" => Ok(GeneratedField::StartInRangeFunc),
                            "endInRangeFunc" | "end_in_range_func" => Ok(GeneratedField::EndInRangeFunc),
                            "inRangeColl" | "in_range_coll" => Ok(GeneratedField::InRangeColl),
                            "inRangeAsc" | "in_range_asc" => Ok(GeneratedField::InRangeAsc),
                            "inRangeNullsFirst" | "in_range_nulls_first" => Ok(GeneratedField::InRangeNullsFirst),
                            "winref" => Ok(GeneratedField::Winref),
                            "copiedOrder" | "copied_order" => Ok(GeneratedField::CopiedOrder),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WindowClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.WindowClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WindowClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut refname__ = None;
                let mut partition_clause__ = None;
                let mut order_clause__ = None;
                let mut frame_options__ = None;
                let mut start_offset__ = None;
                let mut end_offset__ = None;
                let mut run_condition__ = None;
                let mut start_in_range_func__ = None;
                let mut end_in_range_func__ = None;
                let mut in_range_coll__ = None;
                let mut in_range_asc__ = None;
                let mut in_range_nulls_first__ = None;
                let mut winref__ = None;
                let mut copied_order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Refname => {
                            if refname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refname"));
                            }
                            refname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PartitionClause => {
                            if partition_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionClause"));
                            }
                            partition_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderClause => {
                            if order_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderClause"));
                            }
                            order_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FrameOptions => {
                            if frame_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frameOptions"));
                            }
                            frame_options__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StartOffset => {
                            if start_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startOffset"));
                            }
                            start_offset__ = map_.next_value()?;
                        }
                        GeneratedField::EndOffset => {
                            if end_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endOffset"));
                            }
                            end_offset__ = map_.next_value()?;
                        }
                        GeneratedField::RunCondition => {
                            if run_condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runCondition"));
                            }
                            run_condition__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StartInRangeFunc => {
                            if start_in_range_func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startInRangeFunc"));
                            }
                            start_in_range_func__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::EndInRangeFunc => {
                            if end_in_range_func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endInRangeFunc"));
                            }
                            end_in_range_func__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::InRangeColl => {
                            if in_range_coll__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inRangeColl"));
                            }
                            in_range_coll__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::InRangeAsc => {
                            if in_range_asc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inRangeAsc"));
                            }
                            in_range_asc__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InRangeNullsFirst => {
                            if in_range_nulls_first__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inRangeNullsFirst"));
                            }
                            in_range_nulls_first__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Winref => {
                            if winref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("winref"));
                            }
                            winref__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CopiedOrder => {
                            if copied_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("copiedOrder"));
                            }
                            copied_order__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WindowClause {
                    name: name__.unwrap_or_default(),
                    refname: refname__.unwrap_or_default(),
                    partition_clause: partition_clause__.unwrap_or_default(),
                    order_clause: order_clause__.unwrap_or_default(),
                    frame_options: frame_options__.unwrap_or_default(),
                    start_offset: start_offset__,
                    end_offset: end_offset__,
                    run_condition: run_condition__.unwrap_or_default(),
                    start_in_range_func: start_in_range_func__.unwrap_or_default(),
                    end_in_range_func: end_in_range_func__.unwrap_or_default(),
                    in_range_coll: in_range_coll__.unwrap_or_default(),
                    in_range_asc: in_range_asc__.unwrap_or_default(),
                    in_range_nulls_first: in_range_nulls_first__.unwrap_or_default(),
                    winref: winref__.unwrap_or_default(),
                    copied_order: copied_order__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.WindowClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WindowDef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.refname.is_empty() {
            len += 1;
        }
        if !self.partition_clause.is_empty() {
            len += 1;
        }
        if !self.order_clause.is_empty() {
            len += 1;
        }
        if self.frame_options != 0 {
            len += 1;
        }
        if self.start_offset.is_some() {
            len += 1;
        }
        if self.end_offset.is_some() {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.WindowDef", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.refname.is_empty() {
            struct_ser.serialize_field("refname", &self.refname)?;
        }
        if !self.partition_clause.is_empty() {
            struct_ser.serialize_field("partitionClause", &self.partition_clause)?;
        }
        if !self.order_clause.is_empty() {
            struct_ser.serialize_field("orderClause", &self.order_clause)?;
        }
        if self.frame_options != 0 {
            struct_ser.serialize_field("frameOptions", &self.frame_options)?;
        }
        if let Some(v) = self.start_offset.as_ref() {
            struct_ser.serialize_field("startOffset", v)?;
        }
        if let Some(v) = self.end_offset.as_ref() {
            struct_ser.serialize_field("endOffset", v)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WindowDef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "refname",
            "partition_clause",
            "partitionClause",
            "order_clause",
            "orderClause",
            "frame_options",
            "frameOptions",
            "start_offset",
            "startOffset",
            "end_offset",
            "endOffset",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Refname,
            PartitionClause,
            OrderClause,
            FrameOptions,
            StartOffset,
            EndOffset,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "refname" => Ok(GeneratedField::Refname),
                            "partitionClause" | "partition_clause" => Ok(GeneratedField::PartitionClause),
                            "orderClause" | "order_clause" => Ok(GeneratedField::OrderClause),
                            "frameOptions" | "frame_options" => Ok(GeneratedField::FrameOptions),
                            "startOffset" | "start_offset" => Ok(GeneratedField::StartOffset),
                            "endOffset" | "end_offset" => Ok(GeneratedField::EndOffset),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WindowDef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.WindowDef")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WindowDef, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut refname__ = None;
                let mut partition_clause__ = None;
                let mut order_clause__ = None;
                let mut frame_options__ = None;
                let mut start_offset__ = None;
                let mut end_offset__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Refname => {
                            if refname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refname"));
                            }
                            refname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PartitionClause => {
                            if partition_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionClause"));
                            }
                            partition_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderClause => {
                            if order_clause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderClause"));
                            }
                            order_clause__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FrameOptions => {
                            if frame_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frameOptions"));
                            }
                            frame_options__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StartOffset => {
                            if start_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startOffset"));
                            }
                            start_offset__ = map_.next_value()?;
                        }
                        GeneratedField::EndOffset => {
                            if end_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endOffset"));
                            }
                            end_offset__ = map_.next_value()?;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(WindowDef {
                    name: name__.unwrap_or_default(),
                    refname: refname__.unwrap_or_default(),
                    partition_clause: partition_clause__.unwrap_or_default(),
                    order_clause: order_clause__.unwrap_or_default(),
                    frame_options: frame_options__.unwrap_or_default(),
                    start_offset: start_offset__,
                    end_offset: end_offset__,
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.WindowDef", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WindowFunc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.winfnoid != 0 {
            len += 1;
        }
        if self.wintype != 0 {
            len += 1;
        }
        if self.wincollid != 0 {
            len += 1;
        }
        if self.inputcollid != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.aggfilter.is_some() {
            len += 1;
        }
        if self.winref != 0 {
            len += 1;
        }
        if self.winstar {
            len += 1;
        }
        if self.winagg {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.WindowFunc", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.winfnoid != 0 {
            struct_ser.serialize_field("winfnoid", &self.winfnoid)?;
        }
        if self.wintype != 0 {
            struct_ser.serialize_field("wintype", &self.wintype)?;
        }
        if self.wincollid != 0 {
            struct_ser.serialize_field("wincollid", &self.wincollid)?;
        }
        if self.inputcollid != 0 {
            struct_ser.serialize_field("inputcollid", &self.inputcollid)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.aggfilter.as_ref() {
            struct_ser.serialize_field("aggfilter", v)?;
        }
        if self.winref != 0 {
            struct_ser.serialize_field("winref", &self.winref)?;
        }
        if self.winstar {
            struct_ser.serialize_field("winstar", &self.winstar)?;
        }
        if self.winagg {
            struct_ser.serialize_field("winagg", &self.winagg)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WindowFunc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "winfnoid",
            "wintype",
            "wincollid",
            "inputcollid",
            "args",
            "aggfilter",
            "winref",
            "winstar",
            "winagg",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Winfnoid,
            Wintype,
            Wincollid,
            Inputcollid,
            Args,
            Aggfilter,
            Winref,
            Winstar,
            Winagg,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "winfnoid" => Ok(GeneratedField::Winfnoid),
                            "wintype" => Ok(GeneratedField::Wintype),
                            "wincollid" => Ok(GeneratedField::Wincollid),
                            "inputcollid" => Ok(GeneratedField::Inputcollid),
                            "args" => Ok(GeneratedField::Args),
                            "aggfilter" => Ok(GeneratedField::Aggfilter),
                            "winref" => Ok(GeneratedField::Winref),
                            "winstar" => Ok(GeneratedField::Winstar),
                            "winagg" => Ok(GeneratedField::Winagg),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WindowFunc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.WindowFunc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WindowFunc, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut winfnoid__ = None;
                let mut wintype__ = None;
                let mut wincollid__ = None;
                let mut inputcollid__ = None;
                let mut args__ = None;
                let mut aggfilter__ = None;
                let mut winref__ = None;
                let mut winstar__ = None;
                let mut winagg__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Winfnoid => {
                            if winfnoid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("winfnoid"));
                            }
                            winfnoid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Wintype => {
                            if wintype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wintype"));
                            }
                            wintype__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Wincollid => {
                            if wincollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wincollid"));
                            }
                            wincollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Inputcollid => {
                            if inputcollid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputcollid"));
                            }
                            inputcollid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aggfilter => {
                            if aggfilter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggfilter"));
                            }
                            aggfilter__ = map_.next_value()?;
                        }
                        GeneratedField::Winref => {
                            if winref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("winref"));
                            }
                            winref__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Winstar => {
                            if winstar__.is_some() {
                                return Err(serde::de::Error::duplicate_field("winstar"));
                            }
                            winstar__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Winagg => {
                            if winagg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("winagg"));
                            }
                            winagg__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(WindowFunc {
                    xpr: xpr__,
                    winfnoid: winfnoid__.unwrap_or_default(),
                    wintype: wintype__.unwrap_or_default(),
                    wincollid: wincollid__.unwrap_or_default(),
                    inputcollid: inputcollid__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    aggfilter: aggfilter__,
                    winref: winref__.unwrap_or_default(),
                    winstar: winstar__.unwrap_or_default(),
                    winagg: winagg__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.WindowFunc", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WithCheckOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind != 0 {
            len += 1;
        }
        if !self.relname.is_empty() {
            len += 1;
        }
        if !self.polname.is_empty() {
            len += 1;
        }
        if self.qual.is_some() {
            len += 1;
        }
        if self.cascaded {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.WithCheckOption", len)?;
        if self.kind != 0 {
            let v = WcoKind::try_from(self.kind)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.kind)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.relname.is_empty() {
            struct_ser.serialize_field("relname", &self.relname)?;
        }
        if !self.polname.is_empty() {
            struct_ser.serialize_field("polname", &self.polname)?;
        }
        if let Some(v) = self.qual.as_ref() {
            struct_ser.serialize_field("qual", v)?;
        }
        if self.cascaded {
            struct_ser.serialize_field("cascaded", &self.cascaded)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WithCheckOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "relname",
            "polname",
            "qual",
            "cascaded",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Relname,
            Polname,
            Qual,
            Cascaded,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "relname" => Ok(GeneratedField::Relname),
                            "polname" => Ok(GeneratedField::Polname),
                            "qual" => Ok(GeneratedField::Qual),
                            "cascaded" => Ok(GeneratedField::Cascaded),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WithCheckOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.WithCheckOption")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WithCheckOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut relname__ = None;
                let mut polname__ = None;
                let mut qual__ = None;
                let mut cascaded__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = Some(map_.next_value::<WcoKind>()? as i32);
                        }
                        GeneratedField::Relname => {
                            if relname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relname"));
                            }
                            relname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Polname => {
                            if polname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("polname"));
                            }
                            polname__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Qual => {
                            if qual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("qual"));
                            }
                            qual__ = map_.next_value()?;
                        }
                        GeneratedField::Cascaded => {
                            if cascaded__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cascaded"));
                            }
                            cascaded__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WithCheckOption {
                    kind: kind__.unwrap_or_default(),
                    relname: relname__.unwrap_or_default(),
                    polname: polname__.unwrap_or_default(),
                    qual: qual__,
                    cascaded: cascaded__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.WithCheckOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WithClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ctes.is_empty() {
            len += 1;
        }
        if self.recursive {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.WithClause", len)?;
        if !self.ctes.is_empty() {
            struct_ser.serialize_field("ctes", &self.ctes)?;
        }
        if self.recursive {
            struct_ser.serialize_field("recursive", &self.recursive)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WithClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ctes",
            "recursive",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ctes,
            Recursive,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ctes" => Ok(GeneratedField::Ctes),
                            "recursive" => Ok(GeneratedField::Recursive),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WithClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.WithClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WithClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ctes__ = None;
                let mut recursive__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ctes => {
                            if ctes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ctes"));
                            }
                            ctes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Recursive => {
                            if recursive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recursive"));
                            }
                            recursive__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(WithClause {
                    ctes: ctes__.unwrap_or_default(),
                    recursive: recursive__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.WithClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for XmlExpr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xpr.is_some() {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.named_args.is_empty() {
            len += 1;
        }
        if !self.arg_names.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.xmloption != 0 {
            len += 1;
        }
        if self.indent {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.typmod != 0 {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.XmlExpr", len)?;
        if let Some(v) = self.xpr.as_ref() {
            struct_ser.serialize_field("xpr", v)?;
        }
        if self.op != 0 {
            let v = XmlExprOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.named_args.is_empty() {
            struct_ser.serialize_field("named_args", &self.named_args)?;
        }
        if !self.arg_names.is_empty() {
            struct_ser.serialize_field("arg_names", &self.arg_names)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if self.xmloption != 0 {
            let v = XmlOptionType::try_from(self.xmloption)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.xmloption)))?;
            struct_ser.serialize_field("xmloption", &v)?;
        }
        if self.indent {
            struct_ser.serialize_field("indent", &self.indent)?;
        }
        if self.r#type != 0 {
            struct_ser.serialize_field("type", &self.r#type)?;
        }
        if self.typmod != 0 {
            struct_ser.serialize_field("typmod", &self.typmod)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for XmlExpr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xpr",
            "op",
            "name",
            "named_args",
            "arg_names",
            "args",
            "xmloption",
            "indent",
            "type",
            "typmod",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xpr,
            Op,
            Name,
            NamedArgs,
            ArgNames,
            Args,
            Xmloption,
            Indent,
            Type,
            Typmod,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xpr" => Ok(GeneratedField::Xpr),
                            "op" => Ok(GeneratedField::Op),
                            "name" => Ok(GeneratedField::Name),
                            "named_args" => Ok(GeneratedField::NamedArgs),
                            "arg_names" => Ok(GeneratedField::ArgNames),
                            "args" => Ok(GeneratedField::Args),
                            "xmloption" => Ok(GeneratedField::Xmloption),
                            "indent" => Ok(GeneratedField::Indent),
                            "type" => Ok(GeneratedField::Type),
                            "typmod" => Ok(GeneratedField::Typmod),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = XmlExpr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.XmlExpr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<XmlExpr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xpr__ = None;
                let mut op__ = None;
                let mut name__ = None;
                let mut named_args__ = None;
                let mut arg_names__ = None;
                let mut args__ = None;
                let mut xmloption__ = None;
                let mut indent__ = None;
                let mut r#type__ = None;
                let mut typmod__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xpr => {
                            if xpr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xpr"));
                            }
                            xpr__ = map_.next_value()?;
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<XmlExprOp>()? as i32);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NamedArgs => {
                            if named_args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("named_args"));
                            }
                            named_args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ArgNames => {
                            if arg_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg_names"));
                            }
                            arg_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Xmloption => {
                            if xmloption__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xmloption"));
                            }
                            xmloption__ = Some(map_.next_value::<XmlOptionType>()? as i32);
                        }
                        GeneratedField::Indent => {
                            if indent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indent"));
                            }
                            indent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Typmod => {
                            if typmod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typmod"));
                            }
                            typmod__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(XmlExpr {
                    xpr: xpr__,
                    op: op__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    named_args: named_args__.unwrap_or_default(),
                    arg_names: arg_names__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    xmloption: xmloption__.unwrap_or_default(),
                    indent: indent__.unwrap_or_default(),
                    r#type: r#type__.unwrap_or_default(),
                    typmod: typmod__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.XmlExpr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for XmlExprOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "XML_EXPR_OP_UNDEFINED",
            Self::IsXmlconcat => "IS_XMLCONCAT",
            Self::IsXmlelement => "IS_XMLELEMENT",
            Self::IsXmlforest => "IS_XMLFOREST",
            Self::IsXmlparse => "IS_XMLPARSE",
            Self::IsXmlpi => "IS_XMLPI",
            Self::IsXmlroot => "IS_XMLROOT",
            Self::IsXmlserialize => "IS_XMLSERIALIZE",
            Self::IsDocument => "IS_DOCUMENT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for XmlExprOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "XML_EXPR_OP_UNDEFINED",
            "IS_XMLCONCAT",
            "IS_XMLELEMENT",
            "IS_XMLFOREST",
            "IS_XMLPARSE",
            "IS_XMLPI",
            "IS_XMLROOT",
            "IS_XMLSERIALIZE",
            "IS_DOCUMENT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = XmlExprOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "XML_EXPR_OP_UNDEFINED" => Ok(XmlExprOp::Undefined),
                    "IS_XMLCONCAT" => Ok(XmlExprOp::IsXmlconcat),
                    "IS_XMLELEMENT" => Ok(XmlExprOp::IsXmlelement),
                    "IS_XMLFOREST" => Ok(XmlExprOp::IsXmlforest),
                    "IS_XMLPARSE" => Ok(XmlExprOp::IsXmlparse),
                    "IS_XMLPI" => Ok(XmlExprOp::IsXmlpi),
                    "IS_XMLROOT" => Ok(XmlExprOp::IsXmlroot),
                    "IS_XMLSERIALIZE" => Ok(XmlExprOp::IsXmlserialize),
                    "IS_DOCUMENT" => Ok(XmlExprOp::IsDocument),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for XmlOptionType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Undefined => "XML_OPTION_TYPE_UNDEFINED",
            Self::XmloptionDocument => "XMLOPTION_DOCUMENT",
            Self::XmloptionContent => "XMLOPTION_CONTENT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for XmlOptionType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "XML_OPTION_TYPE_UNDEFINED",
            "XMLOPTION_DOCUMENT",
            "XMLOPTION_CONTENT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = XmlOptionType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "XML_OPTION_TYPE_UNDEFINED" => Ok(XmlOptionType::Undefined),
                    "XMLOPTION_DOCUMENT" => Ok(XmlOptionType::XmloptionDocument),
                    "XMLOPTION_CONTENT" => Ok(XmlOptionType::XmloptionContent),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for XmlSerialize {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.xmloption != 0 {
            len += 1;
        }
        if self.expr.is_some() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if self.indent {
            len += 1;
        }
        if self.location != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("pg_query.XmlSerialize", len)?;
        if self.xmloption != 0 {
            let v = XmlOptionType::try_from(self.xmloption)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.xmloption)))?;
            struct_ser.serialize_field("xmloption", &v)?;
        }
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if self.indent {
            struct_ser.serialize_field("indent", &self.indent)?;
        }
        if self.location != 0 {
            struct_ser.serialize_field("location", &self.location)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for XmlSerialize {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xmloption",
            "expr",
            "type_name",
            "typeName",
            "indent",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xmloption,
            Expr,
            TypeName,
            Indent,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xmloption" => Ok(GeneratedField::Xmloption),
                            "expr" => Ok(GeneratedField::Expr),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "indent" => Ok(GeneratedField::Indent),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = XmlSerialize;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct pg_query.XmlSerialize")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<XmlSerialize, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xmloption__ = None;
                let mut expr__ = None;
                let mut type_name__ = None;
                let mut indent__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xmloption => {
                            if xmloption__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xmloption"));
                            }
                            xmloption__ = Some(map_.next_value::<XmlOptionType>()? as i32);
                        }
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::Indent => {
                            if indent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indent"));
                            }
                            indent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(XmlSerialize {
                    xmloption: xmloption__.unwrap_or_default(),
                    expr: expr__,
                    type_name: type_name__,
                    indent: indent__.unwrap_or_default(),
                    location: location__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("pg_query.XmlSerialize", FIELDS, GeneratedVisitor)
    }
}
